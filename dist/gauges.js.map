{"version":3,"sources":["webpack:///webpack/bootstrap f83ee9e8aeb9f97c9bdc","webpack:///./gauges.js","webpack:///./lib/steelseries.js","webpack:///./lib/simplegauges.js","webpack:///./~/ws/lib/browser.js","webpack:///./~/signalk-client/index.js","webpack:///./~/signalk-client/~/eventemitter3/index.js","webpack:///./~/signalk-client/~/ws/lib/browser.js","webpack:///./~/signalk-client/~/debug/browser.js","webpack:///./~/signalk-client/~/debug/debug.js","webpack:///./~/signalk-client/~/debug/~/ms/index.js","webpack:///./~/signalk-client/~/bluebird/js/browser/bluebird.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///(webpack)/~/node-libs-browser/~/timers-browserify/main.js","webpack:///./~/signalk-client/~/superagent-promise/index.js","webpack:///./~/signalk-client/~/superagent/lib/client.js","webpack:///./~/signalk-client/~/superagent/~/component-emitter/index.js","webpack:///./~/signalk-client/~/superagent/~/reduce-component/index.js","webpack:///(webpack)/~/node-libs-browser/~/util/util.js","webpack:///(webpack)/~/node-libs-browser/~/util/support/isBufferBrowser.js","webpack:///(webpack)/~/node-libs-browser/~/util/~/inherits/inherits_browser.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;ACtCA;AACA;AACA;AACA;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yHAAwH;AACxH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA0E;AAC1E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA8B,+CAA+C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,+BAA+B;AAClF;AACA,qEAAoE,gDAAgD;AACpH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC,uCAAsC;AACtC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B,4CAA2C;AAC3C,mBAAkB;AAClB,oCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B,4CAA2C;AAC3C,mBAAkB;AAClB,oCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B,4CAA2C;AAC3C,mBAAkB;AAClB;AACA,oBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B,4CAA2C;AAC3C,mBAAkB;AAClB;AACA,oBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B,YAAY;AACtC;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA,kBAAiB;AACjB;AACA,mBAAkB;AAClB;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA,2BAA0B;AAC1B;AACA,mBAAkB;AAClB;AACA,oBAAmB;AACnB;AACA;AACA;;AAEA;AACA,2BAA0B,cAAc;AACxC;AACA,mBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA,2BAA0B,UAAU;AACpC;AACA,mBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA,2BAA0B,cAAc;AACxC;AACA,mBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC;AACA,4FAA2F;AAC3F,kBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA8B,+CAA+C;AAC7E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC;AACpC,uCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B,YAAY;AACtC;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B,qCAAoC;AACpC;AACA,mBAAkB;AAClB,6BAA4B;AAC5B;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA,2BAA0B,YAAY;AACtC;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA,2BAA0B,UAAU;AACpC;AACA,mBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA,2BAA0B,cAAc;AACxC;AACA,mBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,gCAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA8B,+CAA+C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,+BAA+B;AAClF;AACA,qEAAoE,gDAAgD;AACpH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC;AACpC,uCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B,YAAY;AACtC;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA,4BAA2B;AAC3B;AACA,mBAAkB;AAClB;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA,2BAA0B;AAC1B;AACA,mBAAkB;AAClB;AACA,mBAAkB;AAClB;AACA;AACA;;AAEA;AACA,2BAA0B,cAAc;AACxC;AACA,mBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA,2BAA0B,UAAU;AACpC;AACA,mBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA,wCAAuC;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2DAA0D,0BAA0B;;AAEpF;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB;AACpB,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA8C;AAC9C;AACA,qDAAoD;AACpD,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,iDAAgD;AAChD,oDAAmD;AACnD,kBAAiB;AACjB,6CAA4C;AAC5C,mDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC;AACpC,uCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B,YAAY;AACtC;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA,2BAA0B,UAAU;AACpC;AACA,mBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;AACA;AACA,wCAAuC;AACvC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2DAA0D,0BAA0B;;AAEpF;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAkD;AAClD,qDAAoD;AACpD;AACA;AACA,kBAAiB;AACjB;AACA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC;AACA,4FAA2F;AAC3F,kBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB;AACpB,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA8C;AAC9C,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,6CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,6BAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,oCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,gDAA+C,6BAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,oCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC;AACpC,uCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B,YAAY;AACtC;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA,2BAA0B,kBAAkB;AAC5C;AACA,mBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;AACA,2BAA0B,UAAU;AACpC;AACA,mBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B;AACA,yCAAwC;AACxC,mBAAkB;AAClB;AACA,+BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B;AACA,yCAAwC;AACxC,mBAAkB;AAClB;AACA,iCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA8B,iBAAiB;AAC/C,uBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA,yCAAwC;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,iFAAgF;AAChF,0BAAyB;AACzB;AACA;AACA;AACA,mDAAkD;AAClD;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wCAAuC,gCAAgC;AACvE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,mCAAmC;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAuC,gCAAgC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAoC;AACpC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,4BAA2B,SAAS;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;;AAEA,6BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAwC;AACxC,kBAAiB;AACjB,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B,SAAS;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA,4BAA2B,UAAU;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAiC;AACjC;AACA;AACA,+CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAiC;AACjC;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA,2BAA0B,cAAc;AACxC;AACA,mBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA,2BAA0B,cAAc;AACxC;AACA,mBAAkB,cAAc;AAChC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B;AACA,2BAA0B;AAC1B,mBAAkB;AAClB;AACA,oBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B;AACA,2BAA0B;AAC1B,mBAAkB;AAClB;AACA,oBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA,wCAAuC;AACvC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B,YAAY;AACtC;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B,8CAA6C;AAC7C;AACA,mBAAkB;AAClB,sCAAqC;AACrC;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA,4CAA2C;AAC3C;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,mBAAkB;AAClB;AACA,oCAAmC;AACnC;AACA;AACA;;AAEA;AACA,2BAA0B,eAAe;AACzC;AACA,mBAAkB,eAAe;AACjC;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;AACA;AACA,wCAAuC;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4DAA2D,2BAA2B;AACtF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA0B,YAAY;AACtC;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA,2BAA0B,mBAAmB;AAC7C;AACA,mBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA,2BAA0B,eAAe;AACzC;AACA,mBAAkB,eAAe;AACjC;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;AACA;AACA,wCAAuC;AACvC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAuD,oBAAoB;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B,YAAY;AACtC;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA,kBAAiB;AACjB;AACA,mBAAkB;AAClB;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA,2BAA0B,iBAAiB;AAC3C;AACA,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,iBAAiB;AAC3C,mBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA,wCAAuC;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA,wBAAuB,yBAAyB;AAChD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAuB,cAAc;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA2B,WAAW;AACtC;AACA;AACA;;AAEA,wBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA,4BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAuB,YAAY;AACnC;AACA,4BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA,4BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAuB,cAAc;AACrC;AACA;AACA,4BAA2B,cAAc;AACzC;AACA;AACA,oEAAmE;AACnE;AACA,oCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA,0EAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAuB,YAAY;AACnC;AACA,4BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA,wBAAuB,iBAAiB;AACxC,+BAA8B;AAC9B,qCAAoC;AACpC,oCAAmC;AACnC,uCAAsC;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAiC;AACjC,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA2C;AAC3C,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB;AACpB,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA,2BAA0B;AAC1B;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD,SAAS;AAClE;AACA,4BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;AACD;;;;;;;;;;ACj6eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;;;AAIA;;;;;;;;;;;ACjGA;AACA;AACA;;AAEA,2BAA0B,aAAa,EAAE;;AAEzC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;AC1CA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,qBAAoB,uCAAuC,WAAW,EAAE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;AChKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,MAAM;AACjB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2DAA0D,OAAO;AACjE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAAyC,SAAS;AAClD;AACA;;AAEA;AACA,IAAG;AACH;AACA;;AAEA,gBAAe,YAAY;AAC3B;;AAEA;AACA,4DAA2D;AAC3D,gEAA+D;AAC/D,oEAAmE;AACnE;AACA,2DAA0D,SAAS;AACnE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA,gDAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA,gDAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,MAAM;AACjB,YAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,iDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,kCAAiC;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpQA;AACA;AACA;;AAEA,2BAA0B,aAAa,EAAE;;AAEzC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;;;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAiB,SAAS;AAC1B,6BAA4B;AAC5B;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA,0CAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,0CAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;ACpMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,cAAc;AACzB,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,2BAA2E,2DAA2D,KAAK,MAAM,0HAA0H,YAAY,0BAA0B,0BAA0B,gBAAgB,UAAU,UAAU,0CAA0C,wBAAwB,oBAAoB,8CAA8C,kCAAkC,YAAY,YAAY,mCAAmC,iBAAiB,gBAAgB,sBAAsB,oBAAoB,0CAA0C,YAAY,WAAW,YAAY,SAAS,GAAG;AACjwB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAC,GAAG;AACJ;AACA;AACA,MAAK,kBAAkB,EAAE,YAAY;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA,kCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC,EAAE,kDAAkD;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;AACA;AACA;AACA;AACA,UAAS,yCAAyC;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,kBAAkB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA,mCAAkC;AAClC,6CAA4C;AAC5C,0BAAyB;AACzB,wDAAuD;AACvD,iEAAgE;AAChE,0EAAyE;AACzE,iDAAgD;AAChD;AACA,4DAA2D;AAC3D,cAAa;AACb,WAAU;AACV;AACA;;AAEA;AACA;AACA,sBAAqB;AACrB,iCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,gCAAgC,iBAAiB,aAAa,SAAS;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,eAAe;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,gCAAgC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA,6BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,gCAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA,sCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;;AAEA,0CAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS,mBAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,mBAAmB;AACpC,uBAAsB,mBAAmB;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,yEAAwE;AACxE;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC,EAAE,8BAA8B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAiD,SAAS;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC,EAAE,8CAA8C;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,+CAA+C;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,eAAe;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;;AAEA;AACA;;AAEA,gBAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,6BAA6B;AAChC;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,iBAAgB;AAChB,iBAAgB;AAChB,mBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,eAAe;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,gCAAgC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB;AACzB,mCAAkC;AAClC,2CAA0C;AAC1C;AACA;;AAEA;AACA;AACA,wBAAuB,YAAY;AACnC;AACA,0BAAyB;AACzB,sCAAqC;AACrC,qCAAoC;AACpC;AACA;AACA;AACA;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,0BAAyB;AACzB;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,4BAA4B,iBAAiB,aAAa,SAAS;AACpG;AACA;AACA;AACA;;AAEA;;AAEA,EAAC,EAAE,eAAe;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA,EAAC,EAAE,8BAA8B;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,EAAC,EAAE,eAAe;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,8BAA8B;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;;AAGA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,8BAA8B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,aAAa;AAChC;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oC;AACA,8C;AACA,gC;AACA,uC;AACA,wC;AACA,sC;AACA,qC;AACA,6B;AACA,8B;AACA,iC;AACA,M;AACA;AACA;AACA,gBAAe,KAAK,E;AACpB,gBAAe,KAAK,E;AACpB,gBAAe,KAAK,E;AACpB,kB;AACA,2BAA0B,E;AAC1B,0B;AACA,sB;AACA,sC;AACA,uE;AACA,oB;;AAEA;;AAEA,EAAC,EAAE,mmBAAmmB;AACtmB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC,EAAE,eAAe;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT,0CAAyC,gCAAgC,iBAAiB,aAAa,SAAS;AAChH;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAC,EAAE,8CAA8C;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,4BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAwC,UAAU;AAClD;AACA;AACA,yCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAA+C,MAAM,YAAY,OAAO;AACxE,UAAS;AACT;AACA,qCAAoC,MAAM,YAAY,OAAO;AAC7D,oDAAmD,MAAM,YAAY,OAAO;AAC5E;AACA,+BAA8B,MAAM;AACpC;;AAEA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA;AACA,2CAA0C;AAC1C,uBAAsB;AACtB,4BAA2B,SAAS,OAAO;AAC3C,uCAAsC;AACtC,cAAa;AACb,gCAA+B;AAC/B;AACA,mBAAkB;AAClB;AACA,qEAAoE;AACpE,yEAAwE;AACxE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD;AACjD,0CAAyC;AACzC,0BAAyB;AACzB,wCAAuC;AACvC,iDAAgD;AAChD,0CAAyC;AACzC,wDAAuD;AACvD,qBAAoB;AACpB,wDAAuD;AACvD,0BAAyB;AACzB;AACA,cAAa;AACb,oCAAmC;AACnC,8EAA6E;AAC7E,cAAa;AACb,4BAA2B;AAC3B,WAAU;AACV,2DAA0D;AAC1D,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA,EAAC,EAAE,wDAAwD;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,6BAA6B;AAChC;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAC,GAAG;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,SAAS;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAC,EAAE,eAAe;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,8BAA8B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,qCAAqC;AACrE,iCAAgC,mCAAmC;AACnE,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,iBAAiB;AAChD,4BAA2B,6BAA6B;AACxD;AACA;AACA,EAAC;AACD;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;;AAEA,EAAC,EAAE,YAAY;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,EAAE,eAAe;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC,EAAE,gCAAgC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,EAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC,EAAE,eAAe;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAkC,uCAAuC;AACzE;AACA;AACA;AACA;AACA;AACA,gCAA+B,gBAAgB,EAAE;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA,EAAC,EAAE,eAAe;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA8B,SAAS;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,wBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAC,EAAE,gCAAgC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,gCAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,yBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,oCAAmC,+BAA+B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,WAAW;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,yBAAwB;AACxB;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA,cAAa;AACb;;AAEA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA,MAAK,kBAAkB,EAAE,YAAY;AACrC;;AAEA,EAAC,EAAE,cAAc,EAAE,GAAG;AACtB,EAAC,EAAE,qBAAqB,uDAAuD,yDAAyD,sDAAsD,yDAAyD,mDAAmD,0D;;;;;;;;;;ACtxJ1S;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;;;;AC1FtC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,iBAAiB;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,G;;;;;;;;;;AC3EA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;ACzHA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAoC;AACpC;AACA,EAAC,wCAAwC;AACzC;AACA,EAAC,OAAO;AACR;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA,eAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,UAAS,+CAA+C,EAAE;AAC1D,UAAS,gDAAgD,EAAE;AAC3D,UAAS,gDAAgD,EAAE;AAC3D,UAAS,4CAA4C,EAAE;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA,kBAAiB,iBAAiB;AAClC,kBAAiB,sCAAsC;;AAEvD;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC,SAAS;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAc;;AAEd,sCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA,wBAAuB;AACvB;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA,+BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA,IAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C;AAC5C,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,kBAAiB,aAAa;AAC9B,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAiB,aAAa,iBAAiB;AAC/C;AACA;AACA;AACA;AACA,2BAA0B,aAAa;AACvC,+BAA8B;AAC9B;AACA;AACA;AACA;AACA,2BAA0B,aAAa,iBAAiB;AACxD;AACA,YAAW,eAAe;AAC1B,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,oDAAoD;AACpE;AACA;AACA,YAAW,cAAc;AACzB,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,gBAAgB;AAC9B;AACA,WAAU,cAAc;AACxB,YAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,iBAAiB;AAC5B,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA6D,mBAAmB;AAChF;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,UAAU;AACrB,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,kBAAkB;AACpC,mBAAkB,gBAAgB;AAClC,mBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,mBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,cAAc;AACzB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS,sBAAsB,WAAW,YAAY;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yFAAwF;AACxF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,aAAY;AACZ;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,gBAAgB;AAC3B,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,eAAe;AAC1B,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,eAAe;AAC1B,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,eAAe;AAC1B,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC/qCA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AClKA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,SAAS;AACpB,YAAW,MAAM;AACjB;AACA;AACA;;AAEA,6C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,G;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,wBAAuB,SAAS;AAChC;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,oCAAmC,OAAO;AAC1C;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;AAGA;AACA;AACA,0DAAyD;AACzD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA,YAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;ACzkBA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"gauges.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f83ee9e8aeb9f97c9bdc\n **/","steelseries = require('./lib/steelseries.js');\nsimplegauges = require('./lib/simplegauges.js');\nWebSocket = require('ws');\nSignalK = require('signalk-client');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./gauges.js\n ** module id = 0\n ** module chunks = 0\n **/","/*!\n * Name          : steelseries.js\n * Authors       : Gerrit Grunwald, Mark Crossley\n * Last modified : 29.01.2014\n * Revision      : 0.14.7\n *\n * Copyright (c) 2011, Gerrit Grunwald, Mark Crossley\n * All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without modification, are permitted\n *  provided that the following conditions are met:\n *\n *  # Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *  # Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided with the distribution.\n *\n *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n *   BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\n *   SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n *   OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/*globals Tween */\n/*jshint onevar:false,plusplus:false,nomen:false,bitwise:false*/\n'option strict';\n\nvar steelseries = (function () {\n\n    // Constants\n    var HALF_PI     = Math.PI * 0.5,\n        TWO_PI      = Math.PI * 2,\n        PI          = Math.PI,\n        RAD_FACTOR  = Math.PI / 180,\n        DEG_FACTOR  = 180 / Math.PI,\n        doc         = document,\n        lcdFontName = 'LCDMono2Ultra,Arial,Verdana,sans-serif',\n        stdFontName = 'Arial,Verdana,sans-serif';\n\n    //*************************************   C O M P O N O N E N T S   ************************************************\n    var radial = function (canvas, parameters) {\n        parameters = parameters || {};\n        var gaugeType = (undefined === parameters.gaugeType ? steelseries.GaugeType.TYPE4 : parameters.gaugeType),\n            size = (undefined === parameters.size ? 0 : parameters.size),\n            minValue = (undefined === parameters.minValue ? 0 : parameters.minValue),\n            maxValue = (undefined === parameters.maxValue ? (minValue + 100) : parameters.maxValue),\n            niceScale = (undefined === parameters.niceScale ? true : parameters.niceScale),\n            threshold = (undefined === parameters.threshold ? (maxValue - minValue) / 2 + minValue: parameters.threshold),\n            thresholdRising = (undefined === parameters.thresholdRising ? true : parameters.thresholdRising),\n            section = (undefined === parameters.section ? null : parameters.section),\n            area = (undefined === parameters.area ? null : parameters.area),\n            titleString = (undefined === parameters.titleString ? '' : parameters.titleString),\n            unitString = (undefined === parameters.unitString ? '' : parameters.unitString),\n            frameDesign = (undefined === parameters.frameDesign ? steelseries.FrameDesign.METAL : parameters.frameDesign),\n            frameVisible = (undefined === parameters.frameVisible ? true : parameters.frameVisible),\n            backgroundColor = (undefined === parameters.backgroundColor ? steelseries.BackgroundColor.DARK_GRAY : parameters.backgroundColor),\n            backgroundVisible = (undefined === parameters.backgroundVisible ? true : parameters.backgroundVisible),\n            pointerType = (undefined === parameters.pointerType ? steelseries.PointerType.TYPE1 : parameters.pointerType),\n            pointerColor = (undefined === parameters.pointerColor ? steelseries.ColorDef.RED : parameters.pointerColor),\n            knobType = (undefined === parameters.knobType ? steelseries.KnobType.STANDARD_KNOB : parameters.knobType),\n            knobStyle = (undefined === parameters.knobStyle ? steelseries.KnobStyle.SILVER : parameters.knobStyle),\n            lcdColor = (undefined === parameters.lcdColor ? steelseries.LcdColor.STANDARD : parameters.lcdColor),\n            lcdVisible = (undefined === parameters.lcdVisible ? true : parameters.lcdVisible),\n            lcdDecimals = (undefined === parameters.lcdDecimals ? 2 : parameters.lcdDecimals),\n            digitalFont = (undefined === parameters.digitalFont ? false : parameters.digitalFont),\n            fractionalScaleDecimals = (undefined === parameters.fractionalScaleDecimals ? 1 : parameters.fractionalScaleDecimals),\n            ledColor = (undefined === parameters.ledColor ? steelseries.LedColor.RED_LED : parameters.ledColor),\n            ledVisible = (undefined === parameters.ledVisible ? true : parameters.ledVisible),\n            userLedColor = (undefined === parameters.userLedColor ? steelseries.LedColor.GREEN_LED : parameters.userLedColor),\n            userLedVisible = (undefined === parameters.userLedVisible ? false : parameters.userLedVisible),\n            thresholdVisible = (undefined === parameters.thresholdVisible ? true : parameters.thresholdVisible),\n            minMeasuredValueVisible = (undefined === parameters.minMeasuredValueVisible ? false : parameters.minMeasuredValueVisible),\n            maxMeasuredValueVisible = (undefined === parameters.maxMeasuredValueVisible ? false : parameters.maxMeasuredValueVisible),\n            foregroundType = (undefined === parameters.foregroundType ? steelseries.ForegroundType.TYPE1 : parameters.foregroundType),\n            foregroundVisible = (undefined === parameters.foregroundVisible ? true : parameters.foregroundVisible),\n            labelNumberFormat = (undefined === parameters.labelNumberFormat ? steelseries.LabelNumberFormat.STANDARD : parameters.labelNumberFormat),\n            playAlarm = (undefined === parameters.playAlarm ? false : parameters.playAlarm),\n            alarmSound = (undefined === parameters.alarmSound ? false : parameters.alarmSound),\n            customLayer = (undefined === parameters.customLayer ? null : parameters.customLayer),\n            tickLabelOrientation = (undefined === parameters.tickLabelOrientation ? (gaugeType === steelseries.GaugeType.TYPE1 ? steelseries.TickLabelOrientation.TANGENT : steelseries.TickLabelOrientation.NORMAL) : parameters.tickLabelOrientation),\n            trendVisible = (undefined === parameters.trendVisible ? false : parameters.trendVisible),\n            trendColors = (undefined === parameters.trendColors ? [steelseries.LedColor.RED_LED, steelseries.LedColor.GREEN_LED, steelseries.LedColor.CYAN_LED] : parameters.trendColors),\n            useOdometer = (undefined === parameters.useOdometer ? false : parameters.useOdometer),\n            odometerParams = (undefined === parameters.odometerParams ? {} : parameters.odometerParams),\n            odometerUseValue = (undefined === parameters.odometerUseValue ? false : parameters.odometerUseValue),\n            fullScaleDeflectionTime = (undefined === parameters.fullScaleDeflectionTime ? 2.5 : parameters.fullScaleDeflectionTime);\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (size === 0) {\n            size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height);\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = size;\n        mainCtx.canvas.height = size;\n\n        // Create audio tag for alarm sound\n        var audioElement;\n        if (playAlarm && alarmSound !== false) {\n            audioElement = doc.createElement('audio');\n            audioElement.setAttribute('src', alarmSound);\n            audioElement.setAttribute('preload', 'auto');\n        }\n\n        var value = minValue;\n        var odoValue = minValue;\n        var self = this;\n\n        // Properties\n        var minMeasuredValue = maxValue;\n        var maxMeasuredValue = minValue;\n\n        var ledBlinking = false;\n        var userLedBlinking = false;\n\n        var ledTimerId = 0;\n        var userLedTimerId = 0;\n        var tween;\n        var repainting = false;\n\n        var trendIndicator = steelseries.TrendState.OFF;\n        var trendSize = size * 0.06;\n        var trendPosX = size * 0.29;\n        var trendPosY = size * 0.36;\n\n        // GaugeType specific private variables\n        var freeAreaAngle;\n        var rotationOffset;\n        var tickmarkOffset;\n        var angleRange;\n        var angleStep;\n\n        var angle = rotationOffset + (value - minValue) * angleStep;\n\n        var imageWidth = size;\n        var imageHeight = size;\n\n        var centerX = imageWidth / 2;\n        var centerY = imageHeight / 2;\n\n        // Misc\n        var ledSize = size * 0.093457;\n        var ledPosX = 0.6 * imageWidth;\n        var ledPosY = 0.4 * imageHeight;\n        var userLedPosX = gaugeType === steelseries.GaugeType.TYPE3 ? 0.6 * imageWidth : centerX - ledSize / 2;\n        var userLedPosY = gaugeType === steelseries.GaugeType.TYPE3 ? 0.72 * imageHeight : 0.75 * imageHeight;\n        var lcdFontHeight = Math.floor(imageWidth / 10);\n        var stdFont = lcdFontHeight + 'px ' + stdFontName;\n        var lcdFont = lcdFontHeight + 'px ' + lcdFontName;\n        var lcdHeight = imageHeight * 0.13;\n        var lcdWidth = imageWidth * 0.4;\n        var lcdPosX = (imageWidth - lcdWidth) / 2;\n        var lcdPosY = imageHeight * 0.57;\n        var odoPosX, odoPosY = imageHeight * 0.61;\n        var shadowOffset = imageWidth * 0.006;\n\n        // Constants\n        var initialized = false;\n\n        // Tickmark specific private variables\n        var niceMinValue = minValue;\n        var niceMaxValue = maxValue;\n        var niceRange = maxValue - minValue;\n        var range = niceMaxValue - niceMinValue;\n        var minorTickSpacing = 0;\n        var majorTickSpacing = 0;\n        var maxNoOfMinorTicks = 10;\n        var maxNoOfMajorTicks = 10;\n\n        // Method to calculate nice values for min, max and range for the tickmarks\n        var calculate = function calculate() {\n            if (niceScale) {\n                niceRange = calcNiceNumber(maxValue - minValue, false);\n                majorTickSpacing = calcNiceNumber(niceRange / (maxNoOfMajorTicks - 1), true);\n                niceMinValue = Math.floor(minValue / majorTickSpacing) * majorTickSpacing;\n                niceMaxValue = Math.ceil(maxValue / majorTickSpacing) * majorTickSpacing;\n                minorTickSpacing = calcNiceNumber(majorTickSpacing / (maxNoOfMinorTicks - 1), true);\n                minValue = niceMinValue;\n                maxValue = niceMaxValue;\n                range = maxValue - minValue;\n            } else {\n                niceRange = (maxValue - minValue);\n                niceMinValue = minValue;\n                niceMaxValue = maxValue;\n                range = niceRange;\n                majorTickSpacing = calcNiceNumber(niceRange / (maxNoOfMajorTicks - 1), true);\n                minorTickSpacing = calcNiceNumber(majorTickSpacing / (maxNoOfMinorTicks - 1), true);\n            }\n\n            switch (gaugeType.type) {\n            case 'type1':\n                freeAreaAngle = 0;\n                rotationOffset = PI;\n                tickmarkOffset = HALF_PI;\n                angleRange = HALF_PI;\n                angleStep = angleRange / range;\n                break;\n\n            case 'type2':\n                freeAreaAngle = 0;\n                rotationOffset = PI;\n                tickmarkOffset = HALF_PI;\n                angleRange = PI;\n                angleStep = angleRange / range;\n                break;\n\n            case 'type3':\n                freeAreaAngle = 0;\n                rotationOffset = HALF_PI;\n                tickmarkOffset = 0;\n                angleRange = 1.5 * PI;\n                angleStep = angleRange / range;\n                break;\n\n            case 'type4':\n            /* falls through */\n            default:\n                freeAreaAngle = 60 * RAD_FACTOR;\n                rotationOffset = HALF_PI + (freeAreaAngle / 2);\n                tickmarkOffset = 0;\n                angleRange = TWO_PI - freeAreaAngle;\n                angleStep = angleRange / range;\n                break;\n            }\n            angle = rotationOffset + (value - minValue) * angleStep;\n        };\n\n        // **************   Buffer creation  ********************\n        // Buffer for the frame\n        var frameBuffer = createBuffer(size, size);\n        var frameContext = frameBuffer.getContext('2d');\n\n        // Buffer for the background\n        var backgroundBuffer = createBuffer(size, size);\n        var backgroundContext = backgroundBuffer.getContext('2d');\n\n        var lcdBuffer;\n\n        // Buffer for led on painting code\n        var ledBufferOn = createBuffer(ledSize, ledSize);\n        var ledContextOn = ledBufferOn.getContext('2d');\n\n        // Buffer for led off painting code\n        var ledBufferOff = createBuffer(ledSize, ledSize);\n        var ledContextOff = ledBufferOff.getContext('2d');\n\n        // Buffer for current led painting code\n        var ledBuffer = ledBufferOff;\n\n        // Buffer for user led on painting code\n        var userLedBufferOn = createBuffer(ledSize, ledSize);\n        var userLedContextOn = userLedBufferOn.getContext('2d');\n\n        // Buffer for user led off painting code\n        var userLedBufferOff = createBuffer(ledSize, ledSize);\n        var userLedContextOff = userLedBufferOff.getContext('2d');\n\n        // Buffer for current user led painting code\n        var userLedBuffer = userLedBufferOff;\n\n        // Buffer for the minMeasuredValue indicator\n        var minMeasuredValueBuffer = createBuffer(Math.ceil(size * 0.028037), Math.ceil(size * 0.028037));\n        var minMeasuredValueCtx = minMeasuredValueBuffer.getContext('2d');\n\n        // Buffer for the maxMeasuredValue indicator\n        var maxMeasuredValueBuffer = createBuffer(Math.ceil(size * 0.028037), Math.ceil(size * 0.028037));\n        var maxMeasuredValueCtx = maxMeasuredValueBuffer.getContext('2d');\n\n        // Buffer for pointer image painting code\n        var pointerBuffer = createBuffer(size, size);\n        var pointerContext = pointerBuffer.getContext('2d');\n\n        // Buffer for static foreground painting code\n        var foregroundBuffer = createBuffer(size, size);\n        var foregroundContext = foregroundBuffer.getContext('2d');\n\n        // Buffers for trend indicators\n        var trendUpBuffer, trendSteadyBuffer, trendDownBuffer, trendOffBuffer;\n\n        // Buffer for odometer\n        var odoGauge, odoBuffer, odoContext;\n        if (useOdometer && lcdVisible) {\n            odoBuffer = createBuffer(10, 10);          // size doesn't matter, it will get reset by odometer code\n            odoContext = odoBuffer.getContext('2d');\n        }\n\n        // **************   Image creation  ********************\n        var drawLcdText = function (ctx, value) {\n            ctx.restore();\n            ctx.save();\n            ctx.textAlign = 'right';\n            ctx.strokeStyle = lcdColor.textColor;\n            ctx.fillStyle = lcdColor.textColor;\n\n            if (lcdColor === steelseries.LcdColor.STANDARD || lcdColor === steelseries.LcdColor.STANDARD_GREEN) {\n                ctx.shadowColor = 'gray';\n                ctx.shadowOffsetX = imageWidth * 0.007;\n                ctx.shadowOffsetY = imageWidth * 0.007;\n                ctx.shadowBlur = imageWidth * 0.007;\n            }\n            if (digitalFont) {\n                ctx.font = lcdFont;\n            } else {\n                ctx.font = stdFont;\n            }\n            ctx.fillText(value.toFixed(lcdDecimals), lcdPosX + lcdWidth - lcdWidth * 0.05, lcdPosY + lcdHeight * 0.5 + lcdFontHeight * 0.38, lcdWidth * 0.9);\n\n            ctx.restore();\n        };\n\n        var drawPostsImage = function (ctx) {\n            ctx.save();\n\n            if ('type1' === gaugeType.type) {\n                // Draw max center top post\n                ctx.drawImage(createKnobImage(Math.ceil(imageHeight * 0.037383), steelseries.KnobType.STANDARD_KNOB, knobStyle), imageWidth * 0.523364, imageHeight * 0.130841);\n            }\n\n            if ('type1' === gaugeType.type || 'type2' === gaugeType.type) {\n                // Draw min left post\n                ctx.drawImage(createKnobImage(Math.ceil(imageHeight * 0.037383), steelseries.KnobType.STANDARD_KNOB, knobStyle), imageWidth * 0.130841, imageHeight * 0.514018);\n            }\n\n            if ('type2' === gaugeType.type || 'type3' === gaugeType.type) {\n                // Draw max right post\n                ctx.drawImage(createKnobImage(Math.ceil(imageHeight * 0.037383), steelseries.KnobType.STANDARD_KNOB, knobStyle), imageWidth * 0.831775, imageHeight * 0.514018);\n            }\n\n            if ('type3' === gaugeType.type) {\n                // Draw min center bottom post\n                ctx.drawImage(createKnobImage(Math.ceil(imageHeight * 0.037383), steelseries.KnobType.STANDARD_KNOB, knobStyle), imageWidth * 0.523364, imageHeight * 0.831775);\n            }\n\n            if ('type4' === gaugeType.type) {\n                // Min post\n                ctx.drawImage(createKnobImage(Math.ceil(imageHeight * 0.037383), steelseries.KnobType.STANDARD_KNOB, knobStyle), imageWidth * 0.336448, imageHeight * 0.803738);\n\n                // Max post\n                ctx.drawImage(createKnobImage(Math.ceil(imageHeight * 0.037383), steelseries.KnobType.STANDARD_KNOB, knobStyle), imageWidth * 0.626168, imageHeight * 0.803738);\n            }\n\n            ctx.restore();\n\n        };\n\n        var createThresholdImage = function () {\n            var thresholdBuffer = doc.createElement('canvas');\n            thresholdBuffer.width = Math.ceil(size * 0.046728);\n            thresholdBuffer.height = Math.ceil(thresholdBuffer.width * 0.9);\n            var thresholdCtx = thresholdBuffer.getContext('2d');\n\n            thresholdCtx.save();\n            var gradThreshold = thresholdCtx.createLinearGradient(0, 0.1, 0, thresholdBuffer.height * 0.9);\n            gradThreshold.addColorStop(0, '#520000');\n            gradThreshold.addColorStop(0.3, '#fc1d00');\n            gradThreshold.addColorStop(0.59, '#fc1d00');\n            gradThreshold.addColorStop(1, '#520000');\n            thresholdCtx.fillStyle = gradThreshold;\n\n            thresholdCtx.beginPath();\n            thresholdCtx.moveTo(thresholdBuffer.width * 0.5, 0.1);\n            thresholdCtx.lineTo(thresholdBuffer.width * 0.9, thresholdBuffer.height * 0.9);\n            thresholdCtx.lineTo(thresholdBuffer.width * 0.1, thresholdBuffer.height * 0.9);\n            thresholdCtx.lineTo(thresholdBuffer.width * 0.5, 0.1);\n            thresholdCtx.closePath();\n\n            thresholdCtx.fill();\n            thresholdCtx.strokeStyle = '#FFFFFF';\n            thresholdCtx.stroke();\n\n            thresholdCtx.restore();\n\n            return thresholdBuffer;\n        };\n\n        var drawAreaSectionImage = function (ctx, start, stop, color, filled) {\n            if (start < minValue) {\n                start = minValue;\n            } else if (start > maxValue) {\n                start = maxValue;\n            }\n            if (stop < minValue) {\n                stop = minValue;\n            } else if (stop > maxValue) {\n                stop = maxValue;\n            }\n            if (start >= stop) {\n                return;\n            }\n            ctx.save();\n            ctx.strokeStyle = color;\n            ctx.fillStyle = color;\n            ctx.lineWidth = imageWidth * 0.035;\n            var startAngle = (angleRange / range * start - angleRange / range * minValue);\n            var stopAngle = startAngle + (stop - start) / (range / angleRange);\n            ctx.translate(centerX, centerY);\n            ctx.rotate(rotationOffset);\n            ctx.beginPath();\n            if (filled) {\n                ctx.moveTo(0, 0);\n                ctx.arc(0, 0, imageWidth * 0.365 - ctx.lineWidth / 2, startAngle, stopAngle, false);\n            } else {\n                ctx.arc(0, 0, imageWidth * 0.365, startAngle, stopAngle, false);\n            }\n            if (filled) {\n                ctx.moveTo(0, 0);\n                ctx.fill();\n            } else {\n                ctx.stroke();\n            }\n\n            ctx.translate(-centerX, -centerY);\n            ctx.restore();\n        };\n\n        var drawTickmarksImage = function (ctx, labelNumberFormat) {\n            var fontSize = Math.ceil(imageWidth * 0.04),\n                alpha = rotationOffset,      // Tracks total rotation\n                rotationStep = angleStep * minorTickSpacing,\n                textRotationAngle,\n                valueCounter = minValue,\n                majorTickCounter = maxNoOfMinorTicks - 1,\n                OUTER_POINT = imageWidth * 0.38,\n                MAJOR_INNER_POINT = imageWidth * 0.35,\n                MED_INNER_POINT = imageWidth * 0.355,\n                MINOR_INNER_POINT = imageWidth * 0.36,\n                TEXT_TRANSLATE_X = imageWidth * 0.3,\n                TEXT_WIDTH = imageWidth * 0.1,\n                HALF_MAX_NO_OF_MINOR_TICKS = maxNoOfMinorTicks / 2,\n                MAX_VALUE_ROUNDED = parseFloat(maxValue.toFixed(2)),\n                i;\n\n            backgroundColor.labelColor.setAlpha(1);\n            ctx.save();\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.font = fontSize + 'px' + stdFontName;\n            ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.translate(centerX, centerY);\n            ctx.rotate(rotationOffset);\n\n            if (gaugeType.type === 'type1' || gaugeType.type === 'type2') {\n                TEXT_WIDTH = imageWidth * 0.04;\n            }\n\n            for (i = minValue; parseFloat(i.toFixed(2)) <= MAX_VALUE_ROUNDED; i += minorTickSpacing) {\n                textRotationAngle = rotationStep + HALF_PI;\n                majorTickCounter++;\n                // Draw major tickmarks\n                if (majorTickCounter === maxNoOfMinorTicks) {\n                    ctx.lineWidth = 1.5;\n                    ctx.beginPath();\n                    ctx.moveTo(OUTER_POINT, 0);\n                    ctx.lineTo(MAJOR_INNER_POINT, 0);\n                    ctx.closePath();\n                    ctx.stroke();\n                    ctx.save();\n                    ctx.translate(TEXT_TRANSLATE_X, 0);\n\n                    switch (tickLabelOrientation.type) {\n                    case 'horizontal':\n                        textRotationAngle = -alpha;\n                        break;\n\n                    case 'tangent':\n                        textRotationAngle = (alpha <= HALF_PI + PI ? PI : 0);\n                        break;\n\n                    case 'normal':\n                    /* falls through */\n                    default:\n                        textRotationAngle = HALF_PI;\n                        break;\n                    }\n                    ctx.rotate(textRotationAngle);\n\n                    switch (labelNumberFormat.format) {\n                    case 'fractional':\n                        ctx.fillText((valueCounter.toFixed(fractionalScaleDecimals)), 0, 0, TEXT_WIDTH);\n                        break;\n\n                    case 'scientific':\n                        ctx.fillText((valueCounter.toPrecision(2)), 0, 0, TEXT_WIDTH);\n                        break;\n\n                    case 'standard':\n                    /* falls through */\n                    default:\n                        ctx.fillText((valueCounter.toFixed(0)), 0, 0, TEXT_WIDTH);\n                        break;\n                    }\n                    ctx.translate(-TEXT_TRANSLATE_X, 0);\n                    ctx.restore();\n\n                    valueCounter += majorTickSpacing;\n                    majorTickCounter = 0;\n                    ctx.rotate(rotationStep);\n                    alpha += rotationStep;\n                    continue;\n                }\n\n                // Draw tickmark every minor tickmark spacing\n                if (0 === maxNoOfMinorTicks % 2 && majorTickCounter === (HALF_MAX_NO_OF_MINOR_TICKS)) {\n                    ctx.lineWidth = 1;\n                    ctx.beginPath();\n                    ctx.moveTo(OUTER_POINT, 0);\n                    ctx.lineTo(MED_INNER_POINT, 0);\n                    ctx.closePath();\n                    ctx.stroke();\n                } else {\n                    ctx.lineWidth = 0.5;\n                    ctx.beginPath();\n                    ctx.moveTo(OUTER_POINT, 0);\n                    ctx.lineTo(MINOR_INNER_POINT, 0);\n                    ctx.closePath();\n                    ctx.stroke();\n                }\n                ctx.rotate(rotationStep);\n                alpha += rotationStep;\n            }\n\n            /*\n             // Logarithmic scale\n             var tmp = 0.1;\n             var minValueLog10 = 0.1;\n             var maxValueLog10 = parseInt(Math.pow(10, Math.ceil(Math.log10(maxValue))));\n             var drawLabel = true;\n             angleStep = angleRange / (maxValueLog10 - minValueLog10)\n             for (var scaleFactor = minValueLog10 ; scaleFactor <= maxValueLog10 ; scaleFactor *= 10)\n             {\n             for (var i = parseFloat((1 * scaleFactor).toFixed(1)) ; i < parseFloat((10 * scaleFactor).toFixed(1)) ; i += scaleFactor)\n             {\n             textRotationAngle =+ rotationStep + HALF_PI;\n\n             if(drawLabel)\n             {\n             ctx.lineWidth = 1.5;\n             ctx.beginPath();\n             ctx.moveTo(imageWidth * 0.38,0);\n             ctx.lineTo(imageWidth * 0.35,0);\n             ctx.closePath();\n             ctx.stroke();\n             ctx.save();\n             ctx.translate(imageWidth * 0.31, 0);\n             ctx.rotate(textRotationAngle);\n             ctx.fillText(parseFloat((i).toFixed(1)), 0, 0, imageWidth * 0.0375);\n             ctx.translate(-imageWidth * 0.31, 0);\n             ctx.restore();\n             drawLabel = false;\n             }\n             else\n             {\n             ctx.lineWidth = 0.5;\n             ctx.beginPath();\n             ctx.moveTo(imageWidth * 0.38,0);\n             ctx.lineTo(imageWidth * 0.36,0);\n             ctx.closePath();\n             ctx.stroke();\n             }\n             //doc.write('log10 scale value: ' + parseFloat((i).toFixed(1)) + '<br>');\n             //Math.log10(parseFloat((i).toFixed(1)));\n\n             ctx.rotate(rotationStep);\n             }\n             tmp = 0.1;\n             drawLabel = true;\n             }\n             */\n\n            ctx.translate(-centerX, -centerY);\n            ctx.restore();\n        };\n\n        // **************   Initialization  ********************\n        // Draw all static painting code to background\n        var init = function (parameters) {\n            parameters = parameters || {};\n            var drawFrame = (undefined === parameters.frame ? false : parameters.frame);\n            var drawBackground = (undefined === parameters.background ? false : parameters.background);\n            var drawLed = (undefined === parameters.led ? false : parameters.led);\n            var drawUserLed = (undefined === parameters.userLed ? false : parameters.userLed);\n            var drawPointer = (undefined === parameters.pointer ? false : parameters.pointer);\n            var drawForeground = (undefined === parameters.foreground ? false : parameters.foreground);\n            var drawTrend = (undefined === parameters.trend ? false : parameters.trend);\n            var drawOdo = (undefined === parameters.odo ? false : parameters.odo);\n\n            initialized = true;\n\n            // Calculate the current min and max values and the range\n            calculate();\n\n            // Create frame in frame buffer (backgroundBuffer)\n            if (drawFrame && frameVisible) {\n                drawRadialFrameImage(frameContext, frameDesign, centerX, centerY, imageWidth, imageHeight);\n            }\n\n            // Create background in background buffer (backgroundBuffer)\n            if (drawBackground && backgroundVisible) {\n                drawRadialBackgroundImage(backgroundContext, backgroundColor, centerX, centerY, imageWidth, imageHeight);\n\n                // Create custom layer in background buffer (backgroundBuffer)\n                drawRadialCustomImage(backgroundContext, customLayer, centerX, centerY, imageWidth, imageHeight);\n            }\n\n            if (drawLed) {\n                // Draw LED ON in ledBuffer_ON\n                ledContextOn.drawImage(createLedImage(Math.ceil(size * 0.093457), 1, ledColor), 0, 0);\n\n                // Draw LED OFF in ledBuffer_OFF\n                ledContextOff.drawImage(createLedImage(Math.ceil(size * 0.093457), 0, ledColor), 0, 0);\n            }\n\n            if (drawUserLed) {\n                // Draw user LED ON in userLedBuffer_ON\n                userLedContextOn.drawImage(createLedImage(Math.ceil(size * 0.093457), 1, userLedColor), 0, 0);\n\n                // Draw user LED OFF in userLedBuffer_OFF\n                userLedContextOff.drawImage(createLedImage(Math.ceil(size * 0.093457), 0, userLedColor), 0, 0);\n            }\n\n            // Draw min measured value indicator in minMeasuredValueBuffer\n            if (minMeasuredValueVisible) {\n                minMeasuredValueCtx.drawImage(createMeasuredValueImage(Math.ceil(size * 0.028037), steelseries.ColorDef.BLUE.dark.getRgbaColor(), true, true), 0, 0);\n            }\n\n            // Draw max measured value indicator in maxMeasuredValueBuffer\n            if (maxMeasuredValueVisible) {\n                maxMeasuredValueCtx.drawImage(createMeasuredValueImage(Math.ceil(size * 0.028037), steelseries.ColorDef.RED.medium.getRgbaColor(), true), 0, 0);\n            }\n\n            // Create alignment posts in background buffer (backgroundBuffer)\n            if (drawBackground && backgroundVisible) {\n                drawPostsImage(backgroundContext);\n\n                // Create section in background buffer (backgroundBuffer)\n                if (null !== section && 0 < section.length) {\n                    var sectionIndex = section.length;\n                    do {\n                        sectionIndex--;\n                        drawAreaSectionImage(backgroundContext, section[sectionIndex].start, section[sectionIndex].stop, section[sectionIndex].color, false);\n                    }\n                    while (0 < sectionIndex);\n                }\n\n                // Create area in background buffer (backgroundBuffer)\n                if (null !== area && 0 < area.length) {\n                    var areaIndex = area.length;\n                    do {\n                        areaIndex--;\n                        drawAreaSectionImage(backgroundContext, area[areaIndex].start, area[areaIndex].stop, area[areaIndex].color, true);\n                    }\n                    while (0 < areaIndex);\n                }\n\n                // Create tickmarks in background buffer (backgroundBuffer)\n                drawTickmarksImage(backgroundContext, labelNumberFormat);\n\n                // Create title in background buffer (backgroundBuffer)\n                drawTitleImage(backgroundContext, imageWidth, imageHeight, titleString, unitString, backgroundColor, true, true);\n            }\n\n            // Draw threshold image to background context\n            if (drawBackground && thresholdVisible) {\n                backgroundContext.save();\n                backgroundContext.translate(centerX, centerY);\n                backgroundContext.rotate(rotationOffset + (threshold - minValue) * angleStep + HALF_PI);\n                backgroundContext.translate(-centerX, -centerY);\n                backgroundContext.drawImage(createThresholdImage(), imageWidth * 0.475, imageHeight * 0.13);\n                backgroundContext.translate(centerX, centerY);\n                backgroundContext.restore();\n            }\n\n            // Create lcd background if selected in background buffer (backgroundBuffer)\n            if (drawBackground && lcdVisible) {\n                if (useOdometer && drawOdo) {\n                    odoGauge = new steelseries.Odometer('', {\n                            _context: odoContext,\n                            height: size * 0.075,\n                            decimals: odometerParams.decimals,\n                            digits: (odometerParams.digits === undefined ? 5 : odometerParams.digits),\n                            valueForeColor: odometerParams.valueForeColor,\n                            valueBackColor: odometerParams.valueBackColor,\n                            decimalForeColor: odometerParams.decimalForeColor,\n                            decimalBackColor: odometerParams.decimalBackColor,\n                            font: odometerParams.font,\n                            value: value\n                        });\n                    odoPosX = (imageWidth - odoBuffer.width) / 2;\n                } else if (!useOdometer) {\n                    lcdBuffer = createLcdBackgroundImage(lcdWidth, lcdHeight, lcdColor);\n                    backgroundContext.drawImage(lcdBuffer, lcdPosX, lcdPosY);\n                }\n            }\n\n            // Create pointer image in pointer buffer (contentBuffer)\n            if (drawPointer) {\n                drawPointerImage(pointerContext, imageWidth, pointerType, pointerColor, backgroundColor.labelColor);\n            }\n\n            // Create foreground in foreground buffer (foregroundBuffer)\n            if (drawForeground && foregroundVisible) {\n                var knobVisible = (pointerType.type === 'type15' || pointerType.type === 'type16' ? false : true);\n                drawRadialForegroundImage(foregroundContext, foregroundType, imageWidth, imageHeight, knobVisible, knobType, knobStyle, gaugeType);\n            }\n\n            // Create the trend indicator buffers\n            if (drawTrend && trendVisible) {\n                trendUpBuffer = createTrendIndicator(trendSize, steelseries.TrendState.UP, trendColors);\n                trendSteadyBuffer = createTrendIndicator(trendSize, steelseries.TrendState.STEADY, trendColors);\n                trendDownBuffer = createTrendIndicator(trendSize, steelseries.TrendState.DOWN, trendColors);\n                trendOffBuffer = createTrendIndicator(trendSize, steelseries.TrendState.OFF, trendColors);\n            }\n        };\n\n        var resetBuffers = function (buffers) {\n            buffers = buffers || {};\n            var resetFrame = (undefined === buffers.frame ? false : buffers.frame);\n            var resetBackground = (undefined === buffers.background ? false : buffers.background);\n            var resetLed = (undefined === buffers.led ? false : buffers.led);\n            var resetUserLed = (undefined === buffers.userLed ? false : buffers.userLed);\n            var resetPointer = (undefined === buffers.pointer ? false : buffers.pointer);\n            var resetForeground = (undefined === buffers.foreground ? false : buffers.foreground);\n\n            if (resetFrame) {\n                frameBuffer.width = size;\n                frameBuffer.height = size;\n                frameContext = frameBuffer.getContext('2d');\n            }\n\n            if (resetBackground) {\n                backgroundBuffer.width = size;\n                backgroundBuffer.height = size;\n                backgroundContext = backgroundBuffer.getContext('2d');\n            }\n\n            if (resetLed) {\n                ledBufferOn.width = Math.ceil(size * 0.093457);\n                ledBufferOn.height = Math.ceil(size * 0.093457);\n                ledContextOn = ledBufferOn.getContext('2d');\n\n                ledBufferOff.width = Math.ceil(size * 0.093457);\n                ledBufferOff.height = Math.ceil(size * 0.093457);\n                ledContextOff = ledBufferOff.getContext('2d');\n\n                // Buffer for current led painting code\n                ledBuffer = ledBufferOff;\n            }\n\n            if (resetUserLed) {\n                userLedBufferOn.width = Math.ceil(size * 0.093457);\n                userLedBufferOn.height = Math.ceil(size * 0.093457);\n                userLedContextOn = userLedBufferOn.getContext('2d');\n\n                userLedBufferOff.width = Math.ceil(size * 0.093457);\n                userLedBufferOff.height = Math.ceil(size * 0.093457);\n                userLedContextOff = userLedBufferOff.getContext('2d');\n\n                // Buffer for current user led painting code\n                userLedBuffer = userLedBufferOff;\n            }\n\n            if (resetPointer) {\n                pointerBuffer.width = size;\n                pointerBuffer.height = size;\n                pointerContext = pointerBuffer.getContext('2d');\n            }\n\n            if (resetForeground) {\n                foregroundBuffer.width = size;\n                foregroundBuffer.height = size;\n                foregroundContext = foregroundBuffer.getContext('2d');\n            }\n        };\n\n        var toggleAndRepaintLed = function () {\n            if (ledVisible) {\n                if (ledBuffer === ledBufferOn) {\n                    ledBuffer = ledBufferOff;\n                } else {\n                    ledBuffer = ledBufferOn;\n                }\n                if (!repainting) {\n                    repainting = true;\n                    requestAnimFrame(self.repaint);\n                }\n            }\n        };\n\n        var toggleAndRepaintUserLed = function () {\n            if (userLedVisible) {\n                if (userLedBuffer === userLedBufferOn) {\n                    userLedBuffer = userLedBufferOff;\n                } else {\n                    userLedBuffer = userLedBufferOn;\n                }\n                if (!repainting) {\n                    repainting = true;\n                    requestAnimFrame(self.repaint);\n                }\n            }\n        };\n\n        var blink = function (blinking) {\n            if (blinking) {\n                ledTimerId = setInterval(toggleAndRepaintLed, 1000);\n            } else {\n                clearInterval(ledTimerId);\n                ledBuffer = ledBufferOff;\n            }\n        };\n\n        var blinkUser = function (blinking) {\n            if (blinking) {\n                userLedTimerId = setInterval(toggleAndRepaintUserLed, 1000);\n            } else {\n                clearInterval(userLedTimerId);\n                userLedBuffer = userLedBufferOff;\n            }\n        };\n\n        //************************************ Public methods **************************************\n        this.setValue = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue);\n            if (value !== targetValue) {\n                value = targetValue;\n\n                if (value > maxMeasuredValue) {\n                    maxMeasuredValue = value;\n                }\n                if (value < minMeasuredValue) {\n                    minMeasuredValue = value;\n                }\n\n                if ((value >= threshold && !ledBlinking && thresholdRising) ||\n                    (value <= threshold && !ledBlinking && !thresholdRising)) {\n                    ledBlinking = true;\n                    blink(ledBlinking);\n                    if (playAlarm) {\n                        audioElement.play();\n                    }\n                } else if ((value < threshold && ledBlinking && thresholdRising) ||\n                           (value > threshold && ledBlinking && !thresholdRising)) {\n                    ledBlinking = false;\n                    blink(ledBlinking);\n                    if (playAlarm) {\n                        audioElement.pause();\n                    }\n                }\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getValue = function () {\n            return value;\n        };\n\n        this.setOdoValue = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = (newValue < 0 ? 0 : newValue);\n            if (odoValue !== targetValue) {\n                odoValue = targetValue;\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getOdoValue = function () {\n            return odoValue;\n        };\n\n        this.setValueAnimated = function (newValue, callback) {\n            newValue = parseFloat(newValue);\n            var targetValue = (newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue)),\n                gauge = this,\n                time;\n\n            if (value !== targetValue) {\n                if (undefined !== tween && tween.isPlaying) {\n                    tween.stop();\n                }\n                time = fullScaleDeflectionTime * Math.abs(targetValue - value) / (maxValue - minValue);\n                time = Math.max(time, fullScaleDeflectionTime / 5);\n                tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, time);\n                //tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, 1);\n                //tween = new Tween(new Object(), '', Tween.strongEaseInOut, value, targetValue, 1);\n\n                tween.onMotionChanged = function (event) {\n                    value = event.target._pos;\n\n                    if ((value >= threshold && !ledBlinking && thresholdRising) ||\n                        (value <= threshold && !ledBlinking && !thresholdRising)) {\n                        ledBlinking = true;\n                        blink(ledBlinking);\n                        if (playAlarm) {\n                            audioElement.play();\n                        }\n                    } else if ((value < threshold && ledBlinking && thresholdRising) ||\n                               (value > threshold && ledBlinking && !thresholdRising)) {\n                        ledBlinking = false;\n                        blink(ledBlinking);\n                        if (playAlarm) {\n                            audioElement.pause();\n                        }\n                    }\n\n                    if (value > maxMeasuredValue) {\n                        maxMeasuredValue = value;\n                    }\n                    if (value < minMeasuredValue) {\n                        minMeasuredValue = value;\n                    }\n                    if (!repainting) {\n                        repainting = true;\n                        requestAnimFrame(gauge.repaint);\n                    }\n                };\n\n                // do we have a callback function to process?\n                if (callback && typeof(callback) === \"function\") {\n                    tween.onMotionFinished = callback;\n                }\n\n                tween.start();\n            }\n            return this;\n        };\n\n        this.resetMinMeasuredValue = function () {\n            minMeasuredValue = value;\n            this.repaint();\n        };\n\n        this.resetMaxMeasuredValue = function () {\n            maxMeasuredValue = value;\n            this.repaint();\n            return this;\n        };\n\n        this.setMinMeasuredValueVisible = function (visible) {\n            minMeasuredValueVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setMaxMeasuredValueVisible = function (visible) {\n            maxMeasuredValueVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setMaxMeasuredValue = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue);\n            maxMeasuredValue = targetValue;\n            this.repaint();\n            return this;\n        };\n\n        this.setMinMeasuredValue = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue);\n            minMeasuredValue = targetValue;\n            this.repaint();\n            return this;\n        };\n\n        this.setTitleString = function (title) {\n            titleString = title;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setUnitString = function (unit) {\n            unitString = unit;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setMinValue = function (value) {\n            minValue = parseFloat(value);\n            resetBuffers({frame: true,\n                          background: true});\n            init({frame: true,\n                  background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.getMinValue = function () {\n            return minValue;\n        };\n\n        this.setMaxValue = function (value) {\n            maxValue = parseFloat(value);\n            resetBuffers({frame: true,\n                          background: true});\n            init({frame: true,\n                  background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.getMaxValue = function () {\n            return maxValue;\n        };\n\n        this.setThreshold = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue);\n            threshold = targetValue;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setArea = function (areaVal) {\n            area = areaVal;\n            resetBuffers({background: true,\n                          foreground: true});\n            init({background: true,\n                  foreground: true\n                  });\n            this.repaint();\n            return this;\n        };\n\n        this.setSection = function (areaSec) {\n            section = areaSec;\n            resetBuffers({background: true,\n                          foreground: true});\n            init({background: true,\n                  foreground: true\n                  });\n            this.repaint();\n            return this;\n        };\n\n        this.setThresholdVisible = function (visible) {\n            thresholdVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setThresholdRising = function (rising) {\n            thresholdRising = !!rising;\n            // reset existing threshold alerts\n            ledBlinking = !ledBlinking;\n            blink(ledBlinking);\n            this.repaint();\n            return this;\n        };\n\n        this.setLcdDecimals = function (decimals) {\n            lcdDecimals = parseInt(decimals, 10);\n            this.repaint();\n            return this;\n        };\n\n        this.setFrameDesign = function (newFrameDesign) {\n            resetBuffers({frame: true});\n            frameDesign = newFrameDesign;\n            init({frame: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setBackgroundColor = function (newBackgroundColor) {\n            resetBuffers({background: true,\n                          pointer: (pointerType.type === 'type2' || pointerType.type === 'type13' ? true : false)       // type2 & 13 depend on background\n                });\n            backgroundColor = newBackgroundColor;\n            init({background: true,   // type2 & 13 depend on background\n                  pointer: (pointerType.type === 'type2' || pointerType.type === 'type13' ? true : false)\n                });\n            this.repaint();\n            return this;\n        };\n\n        this.setForegroundType = function (newForegroundType) {\n            resetBuffers({foreground: true});\n            foregroundType = newForegroundType;\n            init({foreground: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerType = function (newPointerType) {\n            resetBuffers({pointer: true,\n                          foreground: true\n                         });\n            pointerType = newPointerType;\n            init({pointer: true,\n                  foreground: true\n                  });\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerColor = function (newPointerColor) {\n            resetBuffers({pointer: true});\n            pointerColor = newPointerColor;\n            init({pointer: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLedColor = function (newLedColor) {\n            resetBuffers({led: true});\n            ledColor = newLedColor;\n            init({led: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setUserLedColor = function (newLedColor) {\n            resetBuffers({userLed: true});\n            userLedColor = newLedColor;\n            init({userLed: true});\n            this.repaint();\n            return this;\n        };\n\n        this.toggleUserLed = function () {\n            if (userLedBuffer === userLedBufferOn) {\n                userLedBuffer = userLedBufferOff;\n            } else {\n                userLedBuffer = userLedBufferOn;\n            }\n            this.repaint();\n            return this;\n        };\n\n        this.setUserLedOnOff = function (on) {\n            if (true === on) {\n                userLedBuffer = userLedBufferOn;\n            } else {\n                userLedBuffer = userLedBufferOff;\n            }\n            this.repaint();\n            return this;\n        };\n\n        this.blinkUserLed = function (blink) {\n            if (blink) {\n                if (!userLedBlinking) {\n                    blinkUser(true);\n                    userLedBlinking = true;\n                }\n            } else {\n                if (userLedBlinking) {\n                    clearInterval(userLedTimerId);\n                    userLedBlinking = false;\n                }\n            }\n            return this;\n        };\n\n        this.setLedVisible = function (visible) {\n            ledVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setUserLedVisible = function (visible) {\n            userLedVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setLcdColor = function (newLcdColor) {\n            lcdColor = newLcdColor;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setTrend = function (newValue) {\n            trendIndicator = newValue;\n            this.repaint();\n            return this;\n        };\n\n        this.setTrendVisible = function (visible) {\n            trendVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setFractionalScaleDecimals = function (decimals) {\n            fractionalScaleDecimals = parseInt(decimals, 10);\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLabelNumberFormat = function (format) {\n            labelNumberFormat = format;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init({frame: true,\n                      background: true,\n                      led: true,\n                      userLed: true,\n                      pointer: true,\n                      trend: true,\n                      foreground: true,\n                      odo: true});\n            }\n            mainCtx.clearRect(0, 0, size, size);\n\n            // Draw frame\n            if (frameVisible) {\n                mainCtx.drawImage(frameBuffer, 0, 0);\n            }\n\n            // Draw buffered image to visible canvas\n            mainCtx.drawImage(backgroundBuffer, 0, 0);\n\n            // Draw lcd display\n            if (lcdVisible) {\n                if (useOdometer) {\n                    odoGauge.setValue(odometerUseValue ? value : odoValue);\n                    mainCtx.drawImage(odoBuffer, odoPosX, odoPosY);\n                } else {\n                    drawLcdText(mainCtx, value);\n                }\n            }\n\n            // Draw led\n            if (ledVisible) {\n                mainCtx.drawImage(ledBuffer, ledPosX, ledPosY);\n            }\n\n            // Draw user led\n            if (userLedVisible) {\n                mainCtx.drawImage(userLedBuffer, userLedPosX, userLedPosY);\n            }\n\n            // Draw the trend indicator\n            if (trendVisible) {\n                switch (trendIndicator.state) {\n                case 'up':\n                    mainCtx.drawImage(trendUpBuffer, trendPosX, trendPosY);\n                    break;\n                case 'steady':\n                    mainCtx.drawImage(trendSteadyBuffer, trendPosX, trendPosY);\n                    break;\n                case 'down':\n                    mainCtx.drawImage(trendDownBuffer, trendPosX, trendPosY);\n                    break;\n                case 'off':\n                    mainCtx.drawImage(trendOffBuffer, trendPosX, trendPosY);\n                    break;\n                }\n            }\n\n            // Draw min measured value indicator\n            if (minMeasuredValueVisible) {\n                mainCtx.save();\n                mainCtx.translate(centerX, centerY);\n                mainCtx.rotate(rotationOffset + HALF_PI + (minMeasuredValue - minValue) * angleStep);\n                mainCtx.translate(-centerX, -centerY);\n                mainCtx.drawImage(minMeasuredValueBuffer, mainCtx.canvas.width * 0.4865, mainCtx.canvas.height * 0.105);\n                mainCtx.restore();\n            }\n\n            // Draw max measured value indicator\n            if (maxMeasuredValueVisible) {\n                mainCtx.save();\n                mainCtx.translate(centerX, centerY);\n                mainCtx.rotate(rotationOffset + HALF_PI + (maxMeasuredValue - minValue) * angleStep);\n                mainCtx.translate(-centerX, -centerY);\n                mainCtx.drawImage(maxMeasuredValueBuffer, mainCtx.canvas.width * 0.4865, mainCtx.canvas.height * 0.105);\n                mainCtx.restore();\n            }\n\n            angle = rotationOffset + HALF_PI + (value - minValue) * angleStep;\n\n            // Define rotation center\n            mainCtx.save();\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate(angle);\n            mainCtx.translate(-centerX, -centerY);\n            // Set the pointer shadow params\n            mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n            mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset;\n            mainCtx.shadowBlur = shadowOffset * 2;\n            // Draw the pointer\n            mainCtx.drawImage(pointerBuffer, 0, 0);\n            // Undo the translations & shadow settings\n            mainCtx.restore();\n\n            // Draw foreground\n            if (foregroundVisible) {\n                mainCtx.drawImage(foregroundBuffer, 0, 0);\n            }\n\n            repainting = false;\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var radialBargraph = function (canvas, parameters) {\n        parameters = parameters || {};\n        var gaugeType = (undefined === parameters.gaugeType ? steelseries.GaugeType.TYPE4 : parameters.gaugeType),\n            size = (undefined === parameters.size ? 0 : parameters.size),\n            minValue = (undefined === parameters.minValue ? 0 : parameters.minValue),\n            maxValue = (undefined === parameters.maxValue ? (minValue + 100) : parameters.maxValue),\n            niceScale = (undefined === parameters.niceScale ? true : parameters.niceScale),\n            threshold = (undefined === parameters.threshold ? (maxValue - minValue) / 2 + minValue: parameters.threshold),\n            thresholdRising = (undefined === parameters.thresholdRising ? true : parameters.thresholdRising),\n            section = (undefined === parameters.section ? null : parameters.section),\n            useSectionColors = (undefined === parameters.useSectionColors ? false : parameters.useSectionColors),\n            titleString = (undefined === parameters.titleString ? '' : parameters.titleString),\n            unitString = (undefined === parameters.unitString ? '' : parameters.unitString),\n            frameDesign = (undefined === parameters.frameDesign ? steelseries.FrameDesign.METAL : parameters.frameDesign),\n            frameVisible = (undefined === parameters.frameVisible ? true : parameters.frameVisible),\n            backgroundColor = (undefined === parameters.backgroundColor ? steelseries.BackgroundColor.DARK_GRAY : parameters.backgroundColor),\n            backgroundVisible = (undefined === parameters.backgroundVisible ? true : parameters.backgroundVisible),\n            valueColor = (undefined === parameters.valueColor ? steelseries.ColorDef.RED : parameters.valueColor),\n            lcdColor = (undefined === parameters.lcdColor ? steelseries.LcdColor.STANDARD : parameters.lcdColor),\n            lcdVisible = (undefined === parameters.lcdVisible ? true : parameters.lcdVisible),\n            lcdDecimals = (undefined === parameters.lcdDecimals ? 2 : parameters.lcdDecimals),\n            digitalFont = (undefined === parameters.digitalFont ? false : parameters.digitalFont),\n            fractionalScaleDecimals = (undefined === parameters.fractionalScaleDecimals ? 1 : parameters.fractionalScaleDecimals),\n            customLayer = (undefined === parameters.customLayer ? null : parameters.customLayer),\n            ledColor = (undefined === parameters.ledColor ? steelseries.LedColor.RED_LED : parameters.ledColor),\n            ledVisible = (undefined === parameters.ledVisible ? true : parameters.ledVisible),\n            userLedColor = (undefined === parameters.userLedColor ? steelseries.LedColor.GREEN_LED : parameters.userLedColor),\n            userLedVisible = (undefined === parameters.userLedVisible ? false : parameters.userLedVisible),\n            labelNumberFormat = (undefined === parameters.labelNumberFormat ? steelseries.LabelNumberFormat.STANDARD : parameters.labelNumberFormat),\n            foregroundType = (undefined === parameters.foregroundType ? steelseries.ForegroundType.TYPE1 : parameters.foregroundType),\n            foregroundVisible = (undefined === parameters.foregroundVisible ? true : parameters.foregroundVisible),\n            playAlarm = (undefined === parameters.playAlarm ? false : parameters.playAlarm),\n            alarmSound = (undefined === parameters.alarmSound ? false : parameters.alarmSound),\n            valueGradient = (undefined === parameters.valueGradient ? null : parameters.valueGradient),\n            useValueGradient = (undefined === parameters.useValueGradient ? false : parameters.useValueGradient),\n            tickLabelOrientation = (undefined === parameters.tickLabelOrientation ? (gaugeType === steelseries.GaugeType.TYPE1 ? steelseries.TickLabelOrientation.TANGENT : steelseries.TickLabelOrientation.NORMAL) : parameters.tickLabelOrientation),\n            trendVisible = (undefined === parameters.trendVisible ? false : parameters.trendVisible),\n            trendColors = (undefined === parameters.trendColors ? [steelseries.LedColor.RED_LED, steelseries.LedColor.GREEN_LED, steelseries.LedColor.CYAN_LED] : parameters.trendColors),\n            fullScaleDeflectionTime = (undefined === parameters.fullScaleDeflectionTime ? 2.5 : parameters.fullScaleDeflectionTime);\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (size === 0) {\n            size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height);\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = size;\n        mainCtx.canvas.height = size;\n\n        // Create audio tag for alarm sound\n        if (playAlarm && alarmSound !== false) {\n            var audioElement = doc.createElement('audio');\n            audioElement.setAttribute('src', alarmSound);\n            audioElement.setAttribute('preload', 'auto');\n        }\n\n        var value = minValue;\n        var range = maxValue - minValue;\n        var ledBlinking = false;\n        var ledTimerId = 0;\n        var userLedBlinking = false;\n        var userLedTimerId = 0;\n        var tween;\n        var self = this;\n        var repainting = false;\n\n        // GaugeType specific private variables\n        var freeAreaAngle;\n        var rotationOffset;\n        var bargraphOffset;\n        var tickmarkOffset;\n        var angleRange;\n        var degAngleRange;\n        var angleStep;\n        var angle;\n\n        var sectionAngles = [];\n        var isSectionsVisible = false;\n        var isGradientVisible = false;\n\n        var imageWidth = size;\n        var imageHeight = size;\n\n        var centerX = imageWidth / 2;\n        var centerY = imageHeight / 2;\n\n        // Misc\n        var lcdFontHeight = Math.floor(imageWidth / 10);\n        var stdFont = lcdFontHeight + 'px ' + stdFontName;\n        var lcdFont = lcdFontHeight + 'px ' + lcdFontName;\n        var lcdHeight = imageHeight * 0.13;\n        var lcdWidth = imageWidth * 0.4;\n        var lcdPosX = (imageWidth - lcdWidth) / 2;\n        var lcdPosY = imageHeight / 2 - lcdHeight / 2;\n\n        // Constants\n        var ACTIVE_LED_POS_X = imageWidth * 0.116822;\n        var ACTIVE_LED_POS_Y = imageWidth * 0.485981;\n        var LED_SIZE = Math.ceil(size * 0.093457);\n        //var LED_POS_X = imageWidth * 0.453271;\n        var LED_POS_X = imageWidth * 0.53;\n        var LED_POS_Y = imageHeight * 0.61;\n        var USER_LED_POS_X = gaugeType === steelseries.GaugeType.TYPE3 ? 0.7 * imageWidth : centerX - LED_SIZE / 2;\n        var USER_LED_POS_Y = gaugeType === steelseries.GaugeType.TYPE3 ? 0.61 * imageHeight : 0.75 * imageHeight;\n\n        var trendIndicator = steelseries.TrendState.OFF;\n        var trendSize = size * 0.06;\n        var trendPosX = size * 0.38;\n        var trendPosY = size * 0.57;\n\n        switch (gaugeType.type) {\n        case 'type1':\n            freeAreaAngle = 0;\n            rotationOffset = PI;\n            bargraphOffset = 0;\n            tickmarkOffset = HALF_PI;\n            angleRange = HALF_PI;\n            degAngleRange = angleRange * DEG_FACTOR;\n            angleStep = angleRange / range;\n            break;\n\n        case 'type2':\n            freeAreaAngle = 0;\n            rotationOffset = PI;\n            bargraphOffset = 0;\n            tickmarkOffset = HALF_PI;\n            angleRange = PI;\n            degAngleRange = angleRange * DEG_FACTOR;\n            angleStep = angleRange / range;\n            break;\n\n        case 'type3':\n            freeAreaAngle = 0;\n            rotationOffset = HALF_PI;\n            bargraphOffset = -HALF_PI;\n            tickmarkOffset = 0;\n            angleRange = 1.5 * PI;\n            degAngleRange = angleRange * DEG_FACTOR;\n            angleStep = angleRange / range;\n            break;\n\n        case 'type4':\n        /* falls through */\n        default:\n            freeAreaAngle = 60 * RAD_FACTOR;\n            rotationOffset = HALF_PI + (freeAreaAngle / 2);\n            bargraphOffset = -TWO_PI / 6;\n            tickmarkOffset = 0;\n            angleRange = TWO_PI - freeAreaAngle;\n            degAngleRange = angleRange * DEG_FACTOR;\n            angleStep = angleRange / range;\n            break;\n        }\n\n        // Buffer for the frame\n        var frameBuffer = createBuffer(size, size);\n        var frameContext = frameBuffer.getContext('2d');\n\n        // Buffer for static background painting code\n        var backgroundBuffer = createBuffer(size, size);\n        var backgroundContext = backgroundBuffer.getContext('2d');\n\n        var lcdBuffer;\n\n        // Buffer for active bargraph led\n        var activeLedBuffer = createBuffer(Math.ceil(size * 0.060747), Math.ceil(size * 0.023364));\n        var activeLedContext = activeLedBuffer.getContext('2d');\n\n        // Buffer for led on painting code\n        var ledBufferOn = createBuffer(LED_SIZE, LED_SIZE);\n        var ledContextOn = ledBufferOn.getContext('2d');\n\n        // Buffer for led off painting code\n        var ledBufferOff = createBuffer(LED_SIZE, LED_SIZE);\n        var ledContextOff = ledBufferOff.getContext('2d');\n\n        // Buffer for current led painting code\n        var ledBuffer = ledBufferOff;\n\n        // Buffer for user led on painting code\n        var userLedBufferOn = createBuffer(LED_SIZE, LED_SIZE);\n        var userLedContextOn = userLedBufferOn.getContext('2d');\n\n        // Buffer for user led off painting code\n        var userLedBufferOff = createBuffer(LED_SIZE, LED_SIZE);\n        var userLedContextOff = userLedBufferOff.getContext('2d');\n\n        // Buffer for current user led painting code\n        var userLedBuffer = userLedBufferOff;\n        // Buffer for the background of the led\n        var ledBackground;\n\n        // Buffer for static foreground painting code\n        var foregroundBuffer = createBuffer(size, size);\n        var foregroundContext = foregroundBuffer.getContext('2d');\n\n        // Buffers for trend indicators\n        var trendUpBuffer, trendSteadyBuffer, trendDownBuffer, trendOffBuffer;\n\n        var initialized = false;\n\n        // Tickmark specific private variables\n        var niceMinValue = minValue;\n        var niceMaxValue = maxValue;\n        var niceRange = maxValue - minValue;\n        range = niceMaxValue - niceMinValue;\n        var minorTickSpacing = 0;\n        var majorTickSpacing = 0;\n        var maxNoOfMinorTicks = 10;\n        var maxNoOfMajorTicks = 10;\n\n        // Method to calculate nice values for min, max and range for the tickmarks\n        var calculate = function calculate() {\n            if (niceScale) {\n                niceRange = calcNiceNumber(maxValue - minValue, false);\n                majorTickSpacing = calcNiceNumber(niceRange / (maxNoOfMajorTicks - 1), true);\n                niceMinValue = Math.floor(minValue / majorTickSpacing) * majorTickSpacing;\n                niceMaxValue = Math.ceil(maxValue / majorTickSpacing) * majorTickSpacing;\n                minorTickSpacing = calcNiceNumber(majorTickSpacing / (maxNoOfMinorTicks - 1), true);\n                minValue = niceMinValue;\n                maxValue = niceMaxValue;\n                range = maxValue - minValue;\n            } else {\n                niceRange = (maxValue - minValue);\n                niceMinValue = minValue;\n                niceMaxValue = maxValue;\n                range = niceRange;\n                //minorTickSpacing = 1;\n                //majorTickSpacing = 10;\n                majorTickSpacing = calcNiceNumber(niceRange / (maxNoOfMajorTicks - 1), true);\n                minorTickSpacing = calcNiceNumber(majorTickSpacing / (maxNoOfMinorTicks - 1), true);\n            }\n\n            switch (gaugeType.type) {\n            case 'type1':\n                freeAreaAngle = 0;\n                rotationOffset = PI;\n                tickmarkOffset = HALF_PI;\n                angleRange = HALF_PI;\n                angleStep = angleRange / range;\n                break;\n\n            case 'type2':\n                freeAreaAngle = 0;\n                rotationOffset = PI;\n                tickmarkOffset = HALF_PI;\n                angleRange = PI;\n                angleStep = angleRange / range;\n                break;\n\n            case 'type3':\n                freeAreaAngle = 0;\n                rotationOffset = HALF_PI;\n                tickmarkOffset = 0;\n                angleRange = 1.5 * PI;\n                angleStep = angleRange / range;\n                break;\n\n            case 'type4':       // fall through\n            /* falls through */\n            default:\n                freeAreaAngle = 60 * RAD_FACTOR;\n                rotationOffset = HALF_PI + (freeAreaAngle / 2);\n                tickmarkOffset = 0;\n                angleRange = TWO_PI - freeAreaAngle;\n                angleStep = angleRange / range;\n                break;\n            }\n            angle = rotationOffset + (value - minValue) * angleStep;\n        };\n\n        //********************************* Private methods *********************************\n        // Draw all static painting code to background\n        var init = function (parameters) {\n            parameters = parameters || {};\n            var drawFrame = (undefined === parameters.frame ? false : parameters.frame);\n            var drawBackground = (undefined === parameters.background ? false : parameters.background);\n            var drawLed = (undefined === parameters.led ? false : parameters.led);\n            var drawUserLed = (undefined === parameters.userLed ? false : parameters.userLed);\n            var drawValue =  (undefined === parameters.value ? false : parameters.value);\n            var drawForeground = (undefined === parameters.foreground ? false : parameters.foreground);\n            var drawTrend = (undefined === parameters.trend ? false : parameters.trend);\n\n            initialized = true;\n\n            calculate();\n\n            // Create frame in frame buffer (frameBuffer)\n            if (drawFrame && frameVisible) {\n                drawRadialFrameImage(frameContext, frameDesign, centerX, centerY, imageWidth, imageHeight);\n            }\n\n            // Create background in background buffer (backgroundBuffer)\n            if (drawBackground && backgroundVisible) {\n                drawRadialBackgroundImage(backgroundContext, backgroundColor, centerX, centerY, imageWidth, imageHeight);\n\n                // Create custom layer in background buffer (backgroundBuffer)\n                drawRadialCustomImage(backgroundContext, customLayer, centerX, centerY, imageWidth, imageHeight);\n            }\n\n            if (drawLed) {\n                // Draw LED ON in ledBuffer_ON\n                ledContextOn.drawImage(createLedImage(LED_SIZE, 1, ledColor), 0, 0);\n\n                // Draw LED OFF in ledBuffer_OFF\n                ledContextOff.drawImage(createLedImage(LED_SIZE, 0, ledColor), 0, 0);\n\n                // Buffer the background of the led for blinking\n                ledBackground = backgroundContext.getImageData(LED_POS_X, LED_POS_Y, LED_SIZE, LED_SIZE);\n            }\n\n            if (drawUserLed) {\n                // Draw user LED ON in userLedBuffer_ON\n                userLedContextOn.drawImage(createLedImage(Math.ceil(LED_SIZE), 1, userLedColor), 0, 0);\n\n                // Draw user LED OFF in userLedBuffer_OFF\n                userLedContextOff.drawImage(createLedImage(Math.ceil(LED_SIZE), 0, userLedColor), 0, 0);\n            }\n\n            if (drawBackground) {\n                // Create bargraphtrack in background buffer (backgroundBuffer)\n                drawBargraphTrackImage(backgroundContext);\n            }\n\n            // Create tickmarks in background buffer (backgroundBuffer)\n            if (drawBackground  && backgroundVisible) {\n                drawTickmarksImage(backgroundContext, labelNumberFormat);\n\n                // Create title in background buffer (backgroundBuffer)\n                drawTitleImage(backgroundContext, imageWidth, imageHeight, titleString, unitString, backgroundColor, true, true);\n            }\n\n            // Create lcd background if selected in background buffer (backgroundBuffer)\n            if (drawBackground && lcdVisible) {\n                lcdBuffer = createLcdBackgroundImage(lcdWidth, lcdHeight, lcdColor);\n                backgroundContext.drawImage(lcdBuffer, lcdPosX, lcdPosY);\n            }\n\n            // Convert Section values into angles\n            isSectionsVisible = false;\n            if (useSectionColors && null !== section && 0 < section.length) {\n                isSectionsVisible = true;\n                var sectionIndex = section.length;\n                sectionAngles = [];\n                do {\n                    sectionIndex--;\n                    sectionAngles.push({start: (((section[sectionIndex].start + Math.abs(minValue)) / (maxValue - minValue)) * degAngleRange),\n                                         stop: (((section[sectionIndex].stop + Math.abs(minValue)) / (maxValue - minValue)) * degAngleRange),\n                                        color: customColorDef(section[sectionIndex].color)});\n                } while (0 < sectionIndex);\n            }\n\n            // Use a gradient for the valueColor?\n            isGradientVisible = false;\n            if (useValueGradient && valueGradient !== null) {\n                // force section colors off!\n                isSectionsVisible = false;\n                isGradientVisible = true;\n            }\n\n            // Create an image of an active led in active led buffer (activeLedBuffer)\n            if (drawValue) {\n                drawActiveLed(activeLedContext, valueColor);\n            }\n\n            // Create foreground in foreground buffer (foregroundBuffer)\n            if (drawForeground && foregroundVisible) {\n                drawRadialForegroundImage(foregroundContext, foregroundType, imageWidth, imageHeight, false);\n            }\n\n            // Create the trend indicator buffers\n            if (drawTrend && trendVisible) {\n                trendUpBuffer = createTrendIndicator(trendSize, steelseries.TrendState.UP, trendColors);\n                trendSteadyBuffer = createTrendIndicator(trendSize, steelseries.TrendState.STEADY, trendColors);\n                trendDownBuffer = createTrendIndicator(trendSize, steelseries.TrendState.DOWN, trendColors);\n                trendOffBuffer = createTrendIndicator(trendSize, steelseries.TrendState.OFF, trendColors);\n            }\n        };\n\n        var resetBuffers = function (buffers) {\n            buffers = buffers || {};\n            var resetFrame = (undefined === buffers.frame ? false : buffers.frame);\n            var resetBackground = (undefined === buffers.background ? false : buffers.background);\n            var resetLed = (undefined === buffers.led ? false : buffers.led);\n            var resetUserLed = (undefined === buffers.userLed ? false : buffers.userLed);\n            var resetValue = (undefined === buffers.value ? false : buffers.value);\n            var resetForeground = (undefined === buffers.foreground ? false : buffers.foreground);\n\n            // Buffer for the frame\n            if (resetFrame) {\n                frameBuffer.width = size;\n                frameBuffer.height = size;\n                frameContext = frameBuffer.getContext('2d');\n            }\n\n            // Buffer for static background painting code\n            if (resetBackground) {\n                backgroundBuffer.width = size;\n                backgroundBuffer.height = size;\n                backgroundContext = backgroundBuffer.getContext('2d');\n            }\n\n            // Buffer for active bargraph led\n            if (resetValue) {\n                activeLedBuffer.width = Math.ceil(size * 0.060747);\n                activeLedBuffer.height = Math.ceil(size * 0.023364);\n                activeLedContext = activeLedBuffer.getContext('2d');\n            }\n\n            if (resetLed) {\n                // Buffer for led on painting code\n                ledBufferOn.width = Math.ceil(LED_SIZE);\n                ledBufferOn.height = Math.ceil(LED_SIZE);\n                ledContextOn = ledBufferOn.getContext('2d');\n\n                // Buffer for led off painting code\n                ledBufferOff.width = Math.ceil(LED_SIZE);\n                ledBufferOff.height = Math.ceil(LED_SIZE);\n                ledContextOff = ledBufferOff.getContext('2d');\n\n                // Buffer for current led painting code\n                ledBuffer = ledBufferOff;\n            }\n\n            if (resetUserLed) {\n                userLedBufferOn.width = Math.ceil(LED_SIZE);\n                userLedBufferOn.height = Math.ceil(LED_SIZE);\n                userLedContextOn = userLedBufferOn.getContext('2d');\n\n                userLedBufferOff.width = Math.ceil(LED_SIZE);\n                userLedBufferOff.height = Math.ceil(LED_SIZE);\n                userLedContextOff = userLedBufferOff.getContext('2d');\n\n                // Buffer for current user led painting code\n                userLedBuffer = userLedBufferOff;\n            }\n\n            // Buffer for static foreground painting code\n            if (resetForeground) {\n                foregroundBuffer.width = size;\n                foregroundBuffer.height = size;\n                foregroundContext = foregroundBuffer.getContext('2d');\n            }\n        };\n\n        var drawBargraphTrackImage = function (ctx) {\n\n            ctx.save();\n\n            // Bargraphtrack\n\n            // Frame\n            ctx.save();\n            ctx.lineWidth = size * 0.085;\n            ctx.beginPath();\n            ctx.translate(centerX, centerY);\n            ctx.rotate(rotationOffset - 4 * RAD_FACTOR);\n            ctx.translate(-centerX, -centerY);\n            ctx.arc(centerX, centerY, imageWidth * 0.355140, 0, angleRange + 8 * RAD_FACTOR, false);\n            ctx.rotate(-rotationOffset);\n            var ledTrackFrameGradient = ctx.createLinearGradient(0, 0.107476 * imageHeight, 0, 0.897195 * imageHeight);\n            ledTrackFrameGradient.addColorStop(0, '#000000');\n            ledTrackFrameGradient.addColorStop(0.22, '#333333');\n            ledTrackFrameGradient.addColorStop(0.76, '#333333');\n            ledTrackFrameGradient.addColorStop(1, '#cccccc');\n            ctx.strokeStyle = ledTrackFrameGradient;\n            ctx.stroke();\n            ctx.restore();\n\n            // Main\n            ctx.save();\n            ctx.lineWidth = size * 0.075;\n            ctx.beginPath();\n            ctx.translate(centerX, centerY);\n            ctx.rotate(rotationOffset - 4 * RAD_FACTOR);\n            ctx.translate(-centerX, -centerY);\n            ctx.arc(centerX, centerY, imageWidth * 0.355140, 0, angleRange + 8 * RAD_FACTOR, false);\n            ctx.rotate(-rotationOffset);\n            var ledTrackMainGradient = ctx.createLinearGradient(0, 0.112149 * imageHeight, 0, 0.892523 * imageHeight);\n            ledTrackMainGradient.addColorStop(0, '#111111');\n            ledTrackMainGradient.addColorStop(1, '#333333');\n            ctx.strokeStyle = ledTrackMainGradient;\n            ctx.stroke();\n            ctx.restore();\n\n            // Draw inactive leds\n            var ledCenterX = (imageWidth * 0.116822 + imageWidth * 0.060747) / 2;\n            var ledCenterY = (imageWidth * 0.485981 + imageWidth * 0.023364) / 2;\n            var ledOffGradient = ctx.createRadialGradient(ledCenterX, ledCenterY, 0, ledCenterX, ledCenterY, 0.030373 * imageWidth);\n            ledOffGradient.addColorStop(0, '#3c3c3c');\n            ledOffGradient.addColorStop(1, '#323232');\n            var angle = 0;\n            for (angle = 0; angle <= degAngleRange; angle += 5) {\n                ctx.save();\n                ctx.translate(centerX, centerY);\n                ctx.rotate((angle * RAD_FACTOR) + bargraphOffset);\n                ctx.translate(-centerX, -centerY);\n                ctx.beginPath();\n                ctx.rect(imageWidth * 0.116822, imageWidth * 0.485981, imageWidth * 0.060747, imageWidth * 0.023364);\n                ctx.closePath();\n                ctx.fillStyle = ledOffGradient;\n                ctx.fill();\n                ctx.restore();\n            }\n\n            ctx.restore();\n        };\n\n        var drawActiveLed = function (ctx, color) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            ctx.closePath();\n            var ledCenterX = (ctx.canvas.width / 2);\n            var ledCenterY = (ctx.canvas.height / 2);\n            var ledGradient = mainCtx.createRadialGradient(ledCenterX, ledCenterY, 0, ledCenterX, ledCenterY, ctx.canvas.width / 2);\n            ledGradient.addColorStop(0, color.light.getRgbaColor());\n            ledGradient.addColorStop(1, color.dark.getRgbaColor());\n            ctx.fillStyle = ledGradient;\n            ctx.fill();\n            ctx.restore();\n        };\n\n        var drawLcdText = function (ctx, value) {\n\n            ctx.save();\n            ctx.textAlign = 'right';\n            ctx.strokeStyle = lcdColor.textColor;\n            ctx.fillStyle = lcdColor.textColor;\n\n            if (lcdColor === steelseries.LcdColor.STANDARD || lcdColor === steelseries.LcdColor.STANDARD_GREEN) {\n                ctx.shadowColor = 'gray';\n                ctx.shadowOffsetX = imageWidth * 0.007;\n                ctx.shadowOffsetY = imageWidth * 0.007;\n                ctx.shadowBlur = imageWidth * 0.007;\n            }\n\n            if (digitalFont) {\n                ctx.font = lcdFont;\n            } else {\n                ctx.font = stdFont;\n            }\n            ctx.fillText(value.toFixed(lcdDecimals), lcdPosX + lcdWidth - lcdWidth * 0.05, lcdPosY + lcdHeight * 0.5 + lcdFontHeight * 0.38, lcdWidth * 0.9);\n\n            ctx.restore();\n        };\n\n        var drawTickmarksImage = function (ctx, labelNumberFormat) {\n            var alpha = rotationOffset,      // Tracks total rotation\n                rotationStep = angleStep * minorTickSpacing,\n                textRotationAngle,\n                fontSize = Math.ceil(imageWidth * 0.04),\n                valueCounter = minValue,\n                majorTickCounter = maxNoOfMinorTicks - 1,\n                TEXT_TRANSLATE_X = imageWidth * 0.28,\n                TEXT_WIDTH = imageWidth * 0.1,\n                MAX_VALUE_ROUNDED = parseFloat(maxValue.toFixed(2)),\n                i;\n\n            backgroundColor.labelColor.setAlpha(1);\n            ctx.save();\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.font = fontSize + 'px ' + stdFontName;\n            ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.translate(centerX, centerY);\n            ctx.rotate(rotationOffset);\n\n            if (gaugeType.type === 'type1' || gaugeType.type === 'type2') {\n                TEXT_WIDTH = imageWidth * 0.0375;\n            }\n\n            for (i = minValue; parseFloat(i.toFixed(2)) <= MAX_VALUE_ROUNDED; i += minorTickSpacing) {\n                textRotationAngle = + rotationStep + HALF_PI;\n                majorTickCounter++;\n                // Draw major tickmarks\n                if (majorTickCounter === maxNoOfMinorTicks) {\n                    ctx.save();\n                    ctx.translate(TEXT_TRANSLATE_X, 0);\n\n                    switch (tickLabelOrientation.type) {\n                    case 'horizontal':\n                        textRotationAngle = -alpha;\n                        break;\n\n                    case 'tangent':\n                        textRotationAngle = (alpha <= HALF_PI + PI ? PI : 0);\n                        break;\n\n                    case 'normal':\n                    /* falls through */\n                    default:\n                        textRotationAngle = HALF_PI;\n                        break;\n                    }\n                    ctx.rotate(textRotationAngle);\n\n                    switch (labelNumberFormat.format) {\n                    case 'fractional':\n                        ctx.fillText((valueCounter.toFixed(fractionalScaleDecimals)), 0, 0, TEXT_WIDTH);\n                        break;\n\n                    case 'scientific':\n                        ctx.fillText((valueCounter.toPrecision(2)), 0, 0, TEXT_WIDTH);\n                        break;\n\n                    case 'standard':\n                    /* falls through */\n                    default:\n                        ctx.fillText((valueCounter.toFixed(0)), 0, 0, TEXT_WIDTH);\n                        break;\n                    }\n                    ctx.translate(-TEXT_TRANSLATE_X, 0);\n                    ctx.restore();\n\n                    valueCounter += majorTickSpacing;\n                    majorTickCounter = 0;\n                    ctx.rotate(rotationStep);\n                    alpha += rotationStep;\n                    continue;\n                }\n                ctx.rotate(rotationStep);\n                alpha += rotationStep;\n            }\n\n            ctx.translate(-centerX, -centerY);\n            ctx.restore();\n        };\n\n        var blink = function (blinking) {\n            if (blinking) {\n                ledTimerId = setInterval(toggleAndRepaintLed, 1000);\n            } else {\n                clearInterval(ledTimerId);\n                ledBuffer = ledBufferOff;\n            }\n        };\n\n        var blinkUser = function (blinking) {\n            if (blinking) {\n                userLedTimerId = setInterval(toggleAndRepaintUserLed, 1000);\n            } else {\n                clearInterval(userLedTimerId);\n                userLedBuffer = userLedBufferOff;\n            }\n        };\n\n        var toggleAndRepaintLed = function () {\n            if (ledVisible) {\n                if (ledBuffer === ledBufferOn) {\n                    ledBuffer = ledBufferOff;\n                } else {\n                    ledBuffer = ledBufferOn;\n                }\n                if (!repainting) {\n                    repainting = true;\n                    requestAnimFrame(self.repaint);\n                }\n            }\n        };\n\n        var toggleAndRepaintUserLed = function () {\n            if (userLedVisible) {\n                if (userLedBuffer === userLedBufferOn) {\n                    userLedBuffer = userLedBufferOff;\n                } else {\n                    userLedBuffer = userLedBufferOn;\n                }\n                if (!repainting) {\n                    repainting = true;\n                    requestAnimFrame(self.repaint);\n                }\n            }\n        };\n\n        //********************************* Public methods *********************************\n        this.setValue = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = (newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue));\n            if (value !== targetValue) {\n                value = targetValue;\n                if ((value >= threshold && !ledBlinking && thresholdRising) ||\n                    (value <= threshold && !ledBlinking && !thresholdRising)) {\n                    ledBlinking = true;\n                    blink(ledBlinking);\n                    if (playAlarm) {\n                        audioElement.play();\n                    }\n                } else if ((value < threshold && ledBlinking && thresholdRising) ||\n                           (value > threshold && ledBlinking && !thresholdRising)) {\n                    ledBlinking = false;\n                    blink(ledBlinking);\n                    if (playAlarm) {\n                        audioElement.pause();\n                    }\n                }\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getValue = function () {\n            return value;\n        };\n\n        this.setValueAnimated = function (newValue, callback) {\n            newValue = parseFloat(newValue);\n            var targetValue = (newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue)),\n                gauge = this,\n                time;\n\n            if (value !== targetValue) {\n                if (undefined !== tween && tween.isPlaying) {\n                    tween.stop();\n                }\n\n                time = fullScaleDeflectionTime * Math.abs(targetValue - value) / (maxValue - minValue);\n                time = Math.max(time, fullScaleDeflectionTime / 5);\n                tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, time);\n                //tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, 1);\n                //tween = new Tween(new Object(), '', Tween.strongEaseInOut, this.value, targetValue, 1);\n                tween.onMotionChanged = function (event) {\n                    value = event.target._pos;\n\n                    if ((value >= threshold && !ledBlinking && thresholdRising) ||\n                        (value <= threshold && !ledBlinking && !thresholdRising)) {\n                        ledBlinking = true;\n                        blink(ledBlinking);\n                        if (playAlarm) {\n                            audioElement.play();\n                        }\n                    } else if ((value < threshold && ledBlinking && thresholdRising) ||\n                               (value > threshold && ledBlinking && !thresholdRising)) {\n                        ledBlinking = false;\n                        blink(ledBlinking);\n                        if (playAlarm) {\n                            audioElement.pause();\n                        }\n                    }\n                    if (!repainting) {\n                        repainting = true;\n                        requestAnimFrame(gauge.repaint);\n                    }\n                };\n\n                // do we have a callback function to process?\n                if (callback && typeof(callback) === \"function\") {\n                    tween.onMotionFinished = callback;\n                }\n\n                tween.start();\n            }\n            return this;\n        };\n\n        this.setFrameDesign = function (newFrameDesign) {\n            resetBuffers({frame: true});\n            frameDesign = newFrameDesign;\n            init({frame: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setBackgroundColor = function (newBackgroundColor) {\n            resetBuffers({background: true,\n                          led: true});\n            backgroundColor = newBackgroundColor;\n            init({background: true,\n                  led: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setForegroundType = function (newForegroundType) {\n            resetBuffers({foreground: true});\n            foregroundType = newForegroundType;\n            init({foreground: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setValueColor = function (newValueColor) {\n            resetBuffers({value: true});\n            valueColor = newValueColor;\n            init({value: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLedColor = function (newLedColor) {\n            resetBuffers({led: true});\n            ledColor = newLedColor;\n            init({led: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setUserLedColor = function (newLedColor) {\n            resetBuffers({userLed: true});\n            userLedColor = newLedColor;\n            init({userLed: true});\n            this.repaint();\n            return this;\n        };\n\n        this.toggleUserLed = function () {\n            if (userLedBuffer === userLedBufferOn) {\n                userLedBuffer = userLedBufferOff;\n            } else {\n                userLedBuffer = userLedBufferOn;\n            }\n            this.repaint();\n            return this;\n        };\n\n        this.setUserLedOnOff = function (on) {\n            if (true === on) {\n                userLedBuffer = userLedBufferOn;\n            } else {\n                userLedBuffer = userLedBufferOff;\n            }\n            this.repaint();\n            return this;\n        };\n\n        this.blinkUserLed = function (blink) {\n            if (blink) {\n                if (!userLedBlinking) {\n                    blinkUser(true);\n                    userLedBlinking = true;\n                }\n            } else {\n                if (userLedBlinking) {\n                    clearInterval(userLedTimerId);\n                    userLedBlinking = false;\n                }\n            }\n            return this;\n        };\n\n        this.setLedVisible = function (visible) {\n            ledVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setUserLedVisible = function (visible) {\n            userLedVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setLcdColor = function (newLcdColor) {\n            lcdColor = newLcdColor;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLcdDecimals = function (decimals) {\n            lcdDecimals = parseInt(decimals, 10);\n            this.repaint();\n            return this;\n        };\n\n        this.setSection = function (areaSec) {\n            section = areaSec;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setSectionActive = function (value) {\n            useSectionColors = value;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setGradient = function (grad) {\n            valueGradient = grad;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setGradientActive = function (value) {\n            useValueGradient = value;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setMinValue = function (value) {\n            minValue = value;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.getMinValue = function () {\n            return minValue;\n        };\n\n        this.setMaxValue = function (value) {\n            maxValue = value;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.getMaxValue = function () {\n            return maxValue;\n        };\n\n        this.setThreshold = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue);\n            threshold = targetValue;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setThresholdRising = function (rising) {\n            thresholdRising = !!rising;\n            // reset existing threshold alerts\n            ledBlinking = !ledBlinking;\n            blink(ledBlinking);\n            this.repaint();\n            return this;\n        };\n\n        this.setTitleString = function (title) {\n            titleString = title;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setUnitString = function (unit) {\n            unitString = unit;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setTrend = function (newValue) {\n            trendIndicator = newValue;\n            this.repaint();\n            return this;\n        };\n\n        this.setTrendVisible = function (visible) {\n            trendVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setFractionalScaleDecimals = function (decimals) {\n            fractionalScaleDecimals = parseInt(decimals, 10);\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n        };\n\n        this.setLabelNumberFormat = function (format) {\n            labelNumberFormat = format;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.repaint = function () {\n            var activeLedAngle = ((value - minValue) / (maxValue - minValue)) * degAngleRange,\n                activeLedColor,\n                lastActiveLedColor = valueColor,\n                angle, i,\n                currentValue,\n                gradRange,\n                fraction;\n\n            if (!initialized) {\n                init({frame: true,\n                      background: true,\n                      led: true,\n                      userLed: true,\n                      value: true,\n                      trend: true,\n                      foreground: true});\n            }\n\n            mainCtx.clearRect(0, 0, size, size);\n\n            // Draw frame image\n            if (frameVisible) {\n                mainCtx.drawImage(frameBuffer, 0, 0);\n            }\n\n            // Draw buffered image to visible canvas\n            mainCtx.drawImage(backgroundBuffer, 0, 0);\n\n            // Draw active leds\n            for (angle = 0; angle <= activeLedAngle; angle += 5) {\n                //check for LED color\n                activeLedColor = valueColor;\n                // Use a gradient for value colors?\n                if (isGradientVisible) {\n                    // Convert angle back to value\n                    currentValue = minValue + (angle / degAngleRange) * (maxValue - minValue);\n                    gradRange = valueGradient.getEnd() - valueGradient.getStart();\n                    fraction = currentValue / gradRange;\n                    fraction = Math.max(Math.min(fraction, 1), 0);\n                    activeLedColor = customColorDef(valueGradient.getColorAt(fraction).getRgbaColor());\n                } else if (isSectionsVisible) {\n                    for (i = 0; i < sectionAngles.length; i++) {\n                        if (angle >= sectionAngles[i].start && angle < sectionAngles[i].stop) {\n                            activeLedColor = sectionAngles[i].color;\n                            break;\n                        }\n                    }\n                }\n                // Has LED color changed? If so redraw the buffer\n                if (lastActiveLedColor.medium.getHexColor() !== activeLedColor.medium.getHexColor()) {\n                    drawActiveLed(activeLedContext, activeLedColor);\n                    lastActiveLedColor = activeLedColor;\n                }\n                mainCtx.save();\n                mainCtx.translate(centerX, centerY);\n                mainCtx.rotate((angle * RAD_FACTOR) + bargraphOffset);\n                mainCtx.translate(-centerX, -centerY);\n                mainCtx.drawImage(activeLedBuffer, ACTIVE_LED_POS_X, ACTIVE_LED_POS_Y);\n                mainCtx.restore();\n            }\n\n            // Draw lcd display\n            if (lcdVisible) {\n                drawLcdText(mainCtx, value);\n            }\n\n            // Draw led\n            if (ledVisible) {\n                mainCtx.drawImage(ledBuffer, LED_POS_X, LED_POS_Y);\n            }\n\n            // Draw user led\n            if (userLedVisible) {\n                mainCtx.drawImage(userLedBuffer, USER_LED_POS_X, USER_LED_POS_Y);\n            }\n\n            // Draw the trend indicator\n            if (trendVisible) {\n                switch (trendIndicator.state) {\n                case 'up':\n                    mainCtx.drawImage(trendUpBuffer, trendPosX, trendPosY);\n                    break;\n                case 'steady':\n                    mainCtx.drawImage(trendSteadyBuffer, trendPosX, trendPosY);\n                    break;\n                case 'down':\n                    mainCtx.drawImage(trendDownBuffer, trendPosX, trendPosY);\n                    break;\n                case 'off':\n                    mainCtx.drawImage(trendOffBuffer, trendPosX, trendPosY);\n                    break;\n                }\n            }\n\n            // Draw foreground\n            if (foregroundVisible) {\n                mainCtx.drawImage(foregroundBuffer, 0, 0);\n            }\n\n            repainting = false;\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var radialVertical = function (canvas, parameters) {\n        parameters = parameters || {};\n        var orientation = (undefined === parameters.orientation ? steelseries.Orientation.NORTH : parameters.orientation),\n            size = (undefined === parameters.size ? 0 : parameters.size),\n            minValue = (undefined === parameters.minValue ? 0 : parameters.minValue),\n            maxValue = (undefined === parameters.maxValue ? (minValue + 100) : parameters.maxValue),\n            niceScale = (undefined === parameters.niceScale ? true : parameters.niceScale),\n            threshold = (undefined === parameters.threshold ? (maxValue - minValue) / 2 + minValue: parameters.threshold),\n            section = (undefined === parameters.section ? null : parameters.section),\n            area = (undefined === parameters.area ? null : parameters.area),\n            titleString = (undefined === parameters.titleString ? '' : parameters.titleString),\n            unitString = (undefined === parameters.unitString ? '' : parameters.unitString),\n            frameDesign = (undefined === parameters.frameDesign ? steelseries.FrameDesign.METAL : parameters.frameDesign),\n            frameVisible = (undefined === parameters.frameVisible ? true : parameters.frameVisible),\n            backgroundColor = (undefined === parameters.backgroundColor ? steelseries.BackgroundColor.DARK_GRAY : parameters.backgroundColor),\n            backgroundVisible = (undefined === parameters.backgroundVisible ? true : parameters.backgroundVisible),\n            pointerType = (undefined === parameters.pointerType ? steelseries.PointerType.TYPE1 : parameters.pointerType),\n            pointerColor = (undefined === parameters.pointerColor ? steelseries.ColorDef.RED : parameters.pointerColor),\n            knobType = (undefined === parameters.knobType ? steelseries.KnobType.STANDARD_KNOB : parameters.knobType),\n            knobStyle = (undefined === parameters.knobStyle ? steelseries.KnobStyle.SILVER : parameters.knobStyle),\n            ledColor = (undefined === parameters.ledColor ? steelseries.LedColor.RED_LED : parameters.ledColor),\n            ledVisible = (undefined === parameters.ledVisible ? true : parameters.ledVisible),\n            thresholdVisible = (undefined === parameters.thresholdVisible ? true : parameters.thresholdVisible),\n            thresholdRising = (undefined === parameters.thresholdRising ? true : parameters.thresholdRising),\n            minMeasuredValueVisible = (undefined === parameters.minMeasuredValueVisible ? false : parameters.minMeasuredValueVisible),\n            maxMeasuredValueVisible = (undefined === parameters.maxMeasuredValueVisible ? false : parameters.maxMeasuredValueVisible),\n            foregroundType = (undefined === parameters.foregroundType ? steelseries.ForegroundType.TYPE1 : parameters.foregroundType),\n            foregroundVisible = (undefined === parameters.foregroundVisible ? true : parameters.foregroundVisible),\n            labelNumberFormat = (undefined === parameters.labelNumberFormat ? steelseries.LabelNumberFormat.STANDARD : parameters.labelNumberFormat),\n            playAlarm = (undefined === parameters.playAlarm ? false : parameters.playAlarm),\n            alarmSound = (undefined === parameters.alarmSound ? false : parameters.alarmSound),\n            fullScaleDeflectionTime = (undefined === parameters.fullScaleDeflectionTime ? 2.5 : parameters.fullScaleDeflectionTime);\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (size === 0) {\n            size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height);\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = size;\n        mainCtx.canvas.height = size;\n\n        // Create audio tag for alarm sound\n        if (playAlarm && alarmSound !== false) {\n            var audioElement = doc.createElement('audio');\n            audioElement.setAttribute('src', alarmSound);\n            audioElement.setAttribute('preload', 'auto');\n        }\n        var gaugeType = steelseries.GaugeType.TYPE5;\n\n        var self = this;\n        var value = minValue;\n\n        // Properties\n        var minMeasuredValue = maxValue;\n        var maxMeasuredValue = minValue;\n        var imageWidth = size;\n        var imageHeight = size;\n\n        var ledBlinking = false;\n\n        var ledTimerId = 0;\n        var tween;\n        var repainting = false;\n\n        // Tickmark specific private variables\n        var niceMinValue = minValue;\n        var niceMaxValue = maxValue;\n        var niceRange = maxValue - minValue;\n        var range = niceMaxValue - niceMinValue;\n        var minorTickSpacing = 0;\n        var majorTickSpacing = 0;\n        var maxNoOfMinorTicks = 10;\n        var maxNoOfMajorTicks = 10;\n\n        var freeAreaAngle = 0;\n        var rotationOffset = 1.25 * PI;\n        var tickmarkOffset = 1.25 * PI;\n        var angleRange = HALF_PI;\n        var angleStep = angleRange / range;\n        var shadowOffset = imageWidth * 0.006;\n        var pointerOffset = imageWidth * 1.17 / 2;\n\n        var initialized = false;\n\n        var angle = rotationOffset + (value - minValue) * angleStep;\n\n        var centerX = imageWidth / 2;\n        var centerY = imageHeight * 0.733644;\n\n        // Misc\n        var ledPosX = 0.455 * imageWidth;\n        var ledPosY = 0.51 * imageHeight;\n\n        // Method to calculate nice values for min, max and range for the tickmarks\n        var calculate = function calculate() {\n            if (niceScale) {\n                niceRange = calcNiceNumber(maxValue - minValue, false);\n                majorTickSpacing = calcNiceNumber(niceRange / (maxNoOfMajorTicks - 1), true);\n                niceMinValue = Math.floor(minValue / majorTickSpacing) * majorTickSpacing;\n                niceMaxValue = Math.ceil(maxValue / majorTickSpacing) * majorTickSpacing;\n                minorTickSpacing = calcNiceNumber(majorTickSpacing / (maxNoOfMinorTicks - 1), true);\n                minValue = niceMinValue;\n                maxValue = niceMaxValue;\n                range = maxValue - minValue;\n            }\n            else {\n                niceRange = (maxValue - minValue);\n                niceMinValue = minValue;\n                niceMaxValue = maxValue;\n                range = niceRange;\n                minorTickSpacing = 1;\n                majorTickSpacing = 10;\n            }\n\n            freeAreaAngle = 0;\n            rotationOffset = 1.25 * PI;\n            tickmarkOffset = 1.25 * PI;\n            angleRange = HALF_PI;\n            angleStep = angleRange / range;\n\n            angle = rotationOffset + (value - minValue) * angleStep;\n        };\n\n        // **************   Buffer creation  ********************\n        // Buffer for the frame\n        var frameBuffer = createBuffer(size, size);\n        var frameContext = frameBuffer.getContext('2d');\n\n        // Buffer for the background\n        var backgroundBuffer = createBuffer(size, size);\n        var backgroundContext = backgroundBuffer.getContext('2d');\n\n        // Buffer for led on painting code\n        var ledBufferOn = createBuffer(size * 0.093457, size * 0.093457);\n        var ledContextOn = ledBufferOn.getContext('2d');\n\n        // Buffer for led off painting code\n        var ledBufferOff = createBuffer(size * 0.093457, size * 0.093457);\n        var ledContextOff = ledBufferOff.getContext('2d');\n\n        // Buffer for current led painting code\n        var ledBuffer = ledBufferOff;\n\n        // Buffer for the minMeasuredValue indicator\n        var minMeasuredValueBuffer = createBuffer(Math.ceil(size * 0.028037), Math.ceil(size * 0.028037));\n        var minMeasuredValueCtx = minMeasuredValueBuffer.getContext('2d');\n\n        // Buffer for the maxMeasuredValue indicator\n        var maxMeasuredValueBuffer = createBuffer(Math.ceil(size * 0.028037), Math.ceil(size * 0.028037));\n        var maxMeasuredValueCtx = maxMeasuredValueBuffer.getContext('2d');\n\n        // Buffer for pointer image painting code\n        var pointerBuffer = createBuffer(size, size);\n        var pointerContext = pointerBuffer.getContext('2d');\n\n        // Buffer for static foreground painting code\n        var foregroundBuffer = createBuffer(size, size);\n        var foregroundContext = foregroundBuffer.getContext('2d');\n\n        // **************   Image creation  ********************\n        var drawPostsImage = function (ctx) {\n            if ('type5' === gaugeType.type) {\n                ctx.save();\n                if (orientation.type === 'west') {\n                    // Min post\n                    ctx.drawImage(createKnobImage(Math.ceil(imageHeight * 0.037383), steelseries.KnobType.STANDARD_KNOB, knobStyle), imageWidth * 0.44, imageHeight * 0.80);\n                    // Max post\n                    ctx.drawImage(createKnobImage(Math.ceil(imageHeight * 0.037383), steelseries.KnobType.STANDARD_KNOB, knobStyle), imageWidth * 0.44, imageHeight * 0.16);\n                } else if (orientation.type === 'east') {\n                    // Min post\n                    ctx.drawImage(createKnobImage(Math.ceil(imageHeight * 0.037383), steelseries.KnobType.STANDARD_KNOB, knobStyle), imageWidth * 0.52, imageHeight * 0.80);\n                    // Max post\n                    ctx.drawImage(createKnobImage(Math.ceil(imageHeight * 0.037383), steelseries.KnobType.STANDARD_KNOB, knobStyle), imageWidth * 0.52, imageHeight * 0.16);\n                } else {\n                    // Min post\n                    ctx.drawImage(createKnobImage(Math.ceil(imageHeight * 0.037383), steelseries.KnobType.STANDARD_KNOB, knobStyle), imageWidth * 0.2 - imageHeight * 0.037383, imageHeight * 0.446666);\n                    // Max post\n                    ctx.drawImage(createKnobImage(Math.ceil(imageHeight * 0.037383), steelseries.KnobType.STANDARD_KNOB, knobStyle), imageWidth * 0.8, imageHeight * 0.446666);\n                }\n                ctx.restore();\n            }\n        };\n\n        var createThresholdImage = function () {\n            var thresholdBuffer = doc.createElement('canvas');\n            thresholdBuffer.width = Math.ceil(size * 0.046728);\n            thresholdBuffer.height = Math.ceil(thresholdBuffer.width * 0.9);\n            var thresholdCtx = thresholdBuffer.getContext('2d');\n\n            thresholdCtx.save();\n            var gradThreshold = thresholdCtx.createLinearGradient(0, 0.1, 0, thresholdBuffer.height * 0.9);\n            gradThreshold.addColorStop(0, '#520000');\n            gradThreshold.addColorStop(0.3, '#fc1d00');\n            gradThreshold.addColorStop(0.59, '#fc1d00');\n            gradThreshold.addColorStop(1, '#520000');\n            thresholdCtx.fillStyle = gradThreshold;\n\n            thresholdCtx.beginPath();\n            thresholdCtx.moveTo(thresholdBuffer.width * 0.5, 0.1);\n            thresholdCtx.lineTo(thresholdBuffer.width * 0.9, thresholdBuffer.height * 0.9);\n            thresholdCtx.lineTo(thresholdBuffer.width * 0.1, thresholdBuffer.height * 0.9);\n            thresholdCtx.lineTo(thresholdBuffer.width * 0.5, 0.1);\n            thresholdCtx.closePath();\n\n            thresholdCtx.fill();\n            thresholdCtx.strokeStyle = '#FFFFFF';\n            thresholdCtx.stroke();\n\n            thresholdCtx.restore();\n\n            return thresholdBuffer;\n        };\n\n        var drawAreaSectionImage = function (ctx, start, stop, color, filled) {\n            ctx.save();\n            ctx.strokeStyle = color;\n            ctx.fillStyle = color;\n            ctx.lineWidth = imageWidth * 0.035;\n            var startAngle = (angleRange / range * start - angleRange / range * minValue);\n            var stopAngle = startAngle + (stop - start) / (range / angleRange);\n            ctx.translate(centerX, centerY);\n            ctx.rotate(rotationOffset);\n            ctx.beginPath();\n            if (filled) {\n                ctx.moveTo(0, 0);\n                ctx.arc(0, 0, imageWidth * 0.365 - ctx.lineWidth / 2, startAngle, stopAngle, false);\n            } else {\n                ctx.arc(0, 0, imageWidth * 0.365, startAngle, stopAngle, false);\n            }\n            if (filled) {\n                ctx.moveTo(0, 0);\n                ctx.fill();\n            } else {\n                ctx.stroke();\n            }\n\n            ctx.translate(-centerX, -centerY);\n            ctx.restore();\n        };\n\n        var drawTitleImage = function (ctx) {\n            var titleWidth, unitWidth;\n            ctx.save();\n            ctx.textAlign = 'left';\n            ctx.textBaseline = 'middle';\n            ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n\n            ctx.font = 0.046728 * imageWidth + 'px ' + stdFontName;\n            titleWidth = ctx.measureText(titleString).width;\n            ctx.fillText(titleString, (imageWidth - titleWidth) / 2, imageHeight * 0.4, imageWidth * 0.3);\n            unitWidth = ctx.measureText(unitString).width;\n            ctx.fillText(unitString, (imageWidth - unitWidth) / 2, imageHeight * 0.47, imageWidth * 0.2);\n\n            ctx.restore();\n        };\n\n        var drawTickmarksImage = function (ctx, labelNumberFormat) {\n            backgroundColor.labelColor.setAlpha(1);\n            ctx.save();\n\n            if (steelseries.Orientation.WEST === orientation) {\n                ctx.translate(centerX, centerX);\n                ctx.rotate(-HALF_PI);\n                ctx.translate(-centerX, -centerX);\n            }\n            if (steelseries.Orientation.EAST === orientation) {\n                ctx.translate(centerX, centerX);\n                ctx.rotate(HALF_PI);\n                ctx.translate(-centerX, -centerX);\n            }\n\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            var fontSize = Math.ceil(imageWidth * 0.04);\n            ctx.font = fontSize + 'px ' + stdFontName;\n            ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.translate(centerX, centerY);\n            ctx.rotate(rotationOffset);\n            var rotationStep = angleStep * minorTickSpacing;\n            var textRotationAngle;\n\n            var valueCounter = minValue;\n            var majorTickCounter = maxNoOfMinorTicks - 1;\n\n            var OUTER_POINT = imageWidth * 0.44;\n            var MAJOR_INNER_POINT = imageWidth * 0.41;\n            var MED_INNER_POINT = imageWidth * 0.415;\n            var MINOR_INNER_POINT = imageWidth * 0.42;\n            var TEXT_TRANSLATE_X = imageWidth * 0.48;\n            var TEXT_WIDTH = imageWidth * 0.04;\n            var HALF_MAX_NO_OF_MINOR_TICKS = maxNoOfMinorTicks / 2;\n            var MAX_VALUE_ROUNDED = parseFloat(maxValue.toFixed(2));\n            var i;\n\n            for (i = minValue; parseFloat(i.toFixed(2)) <= MAX_VALUE_ROUNDED; i += minorTickSpacing) {\n                textRotationAngle = + rotationStep + HALF_PI;\n                majorTickCounter++;\n                // Draw major tickmarks\n                if (majorTickCounter === maxNoOfMinorTicks) {\n                    ctx.lineWidth = 1.5;\n                    ctx.beginPath();\n                    ctx.moveTo(OUTER_POINT, 0);\n                    ctx.lineTo(MAJOR_INNER_POINT, 0);\n                    ctx.closePath();\n                    ctx.stroke();\n                    ctx.save();\n                    ctx.translate(TEXT_TRANSLATE_X, 0);\n                    ctx.rotate(textRotationAngle);\n                    switch (labelNumberFormat.format) {\n                    case 'fractional':\n                        ctx.fillText((valueCounter.toFixed(2)), 0, 0, TEXT_WIDTH);\n                        break;\n\n                    case 'scientific':\n                        ctx.fillText((valueCounter.toPrecision(2)), 0, 0, TEXT_WIDTH);\n                        break;\n\n                    case 'standard':\n                    /* falls through */\n                    default:\n                        ctx.fillText((valueCounter.toFixed(0)), 0, 0, TEXT_WIDTH);\n                        break;\n                    }\n                    ctx.translate(-TEXT_TRANSLATE_X, 0);\n                    ctx.restore();\n\n                    valueCounter += majorTickSpacing;\n                    majorTickCounter = 0;\n                    ctx.rotate(rotationStep);\n                    continue;\n                }\n\n                // Draw tickmark every minor tickmark spacing\n                if (0 === maxNoOfMinorTicks % 2 && majorTickCounter === (HALF_MAX_NO_OF_MINOR_TICKS)) {\n                    ctx.lineWidth = 1;\n                    ctx.beginPath();\n                    ctx.moveTo(OUTER_POINT, 0);\n                    ctx.lineTo(MED_INNER_POINT, 0);\n                    ctx.closePath();\n                    ctx.stroke();\n                } else {\n                    ctx.lineWidth = 0.5;\n                    ctx.beginPath();\n                    ctx.moveTo(OUTER_POINT, 0);\n                    ctx.lineTo(MINOR_INNER_POINT, 0);\n                    ctx.closePath();\n                    ctx.stroke();\n                }\n                ctx.rotate(rotationStep);\n            }\n\n            /*\n             // Logarithmic scale\n             var tmp = 0.1;\n             var minValueLog10 = 0.1;\n             var maxValueLog10 = parseInt(Math.pow(10, Math.ceil(Math.log10(maxValue))));\n             var drawLabel = true;\n             angleStep = angleRange / (maxValueLog10 - minValueLog10)\n             for (var scaleFactor = minValueLog10 ; scaleFactor <= maxValueLog10 ; scaleFactor *= 10)\n             {\n             for (var i = parseFloat((1 * scaleFactor).toFixed(1)) ; i < parseFloat((10 * scaleFactor).toFixed(1)) ; i += scaleFactor)\n             {\n             textRotationAngle =+ rotationStep + HALF_PI;\n\n             if(drawLabel)\n             {\n             ctx.lineWidth = 1.5;\n             ctx.beginPath();\n             ctx.moveTo(imageWidth * 0.38,0);\n             ctx.lineTo(imageWidth * 0.35,0);\n             ctx.closePath();\n             ctx.stroke();\n             ctx.save();\n             ctx.translate(imageWidth * 0.31, 0);\n             ctx.rotate(textRotationAngle);\n             ctx.fillText(parseFloat((i).toFixed(1)), 0, 0, imageWidth * 0.0375);\n             ctx.translate(-imageWidth * 0.31, 0);\n             ctx.restore();\n             drawLabel = false;\n             }\n             else\n             {\n             ctx.lineWidth = 0.5;\n             ctx.beginPath();\n             ctx.moveTo(imageWidth * 0.38,0);\n             ctx.lineTo(imageWidth * 0.36,0);\n             ctx.closePath();\n             ctx.stroke();\n             }\n             //doc.write('log10 scale value: ' + parseFloat((i).toFixed(1)) + '<br>');\n             //Math.log10(parseFloat((i).toFixed(1)));\n\n             ctx.rotate(rotationStep);\n             }\n             tmp = 0.1;\n             drawLabel = true;\n             }\n             */\n\n            ctx.translate(-centerX, -centerY);\n            ctx.restore();\n        };\n\n        // **************   Initialization  ********************\n        // Draw all static painting code to background\n        var init = function (parameters) {\n            parameters = parameters || {};\n            var drawFrame = (undefined === parameters.frame ? false : parameters.frame);\n            var drawBackground = (undefined === parameters.background ? false : parameters.background);\n            var drawLed = (undefined === parameters.led ? false : parameters.led);\n            var drawPointer = (undefined === parameters.pointer ? false : parameters.pointer);\n            var drawForeground = (undefined === parameters.foreground ? false : parameters.foreground);\n\n            initialized = true;\n\n            // Calculate the current min and max values and the range\n            calculate();\n\n            // Create frame in frame buffer (backgroundBuffer)\n            if (drawFrame && frameVisible) {\n                drawRadialFrameImage(frameContext, frameDesign, centerX, size / 2, imageWidth, imageHeight);\n            }\n\n            // Create background in background buffer (backgroundBuffer)\n            if (drawBackground && backgroundVisible) {\n                drawRadialBackgroundImage(backgroundContext, backgroundColor, centerX, size / 2, imageWidth, imageHeight);\n            }\n\n            // Draw LED ON in ledBuffer_ON\n            if (drawLed) {\n                ledContextOn.drawImage(createLedImage(Math.ceil(size * 0.093457), 1, ledColor), 0, 0);\n\n                // Draw LED ON in ledBuffer_OFF\n                ledContextOff.drawImage(createLedImage(Math.ceil(size * 0.093457), 0, ledColor), 0, 0);\n            }\n\n            // Draw min measured value indicator in minMeasuredValueBuffer\n            if (minMeasuredValueVisible) {\n                minMeasuredValueCtx.drawImage(createMeasuredValueImage(Math.ceil(size * 0.028037), steelseries.ColorDef.BLUE.dark.getRgbaColor(), true, true), 0, 0);\n                minMeasuredValueCtx.restore();\n            }\n\n            // Draw max measured value indicator in maxMeasuredValueBuffer\n            if (maxMeasuredValueVisible) {\n                maxMeasuredValueCtx.drawImage(createMeasuredValueImage(Math.ceil(size * 0.028037), steelseries.ColorDef.RED.medium.getRgbaColor(), true), 0, 0);\n                maxMeasuredValueCtx.restore();\n            }\n\n            // Create alignment posts in background buffer (backgroundBuffer)\n            if (drawBackground && backgroundVisible) {\n                drawPostsImage(backgroundContext);\n\n                // Create section in background buffer (backgroundBuffer)\n                if (null !== section && 0 < section.length) {\n                    backgroundContext.save();\n                    if (steelseries.Orientation.WEST === orientation) {\n                        backgroundContext.translate(centerX, centerX);\n                        backgroundContext.rotate(-HALF_PI);\n                        backgroundContext.translate(-centerX, -centerX);\n                    } else if (steelseries.Orientation.EAST === orientation) {\n                        backgroundContext.translate(centerX, centerX);\n                        backgroundContext.rotate(HALF_PI);\n                        backgroundContext.translate(-centerX, -centerX);\n                    }\n                    var sectionIndex = section.length;\n                    do {\n                        sectionIndex--;\n                        drawAreaSectionImage(backgroundContext, section[sectionIndex].start, section[sectionIndex].stop, section[sectionIndex].color, false);\n                    }\n                    while (0 < sectionIndex);\n                    backgroundContext.restore();\n                }\n\n                // Create area in background buffer (backgroundBuffer)\n                if (null !== area && 0 < area.length) {\n                    if (steelseries.Orientation.WEST === orientation) {\n                        backgroundContext.translate(centerX, centerX);\n                        backgroundContext.rotate(-HALF_PI);\n                        backgroundContext.translate(-centerX, -centerX);\n                    }\n                    if (steelseries.Orientation.EAST === orientation) {\n                        backgroundContext.translate(centerX, centerX);\n                        backgroundContext.rotate(HALF_PI);\n                        backgroundContext.translate(-centerX, -centerX);\n                    }\n                    var areaIndex = area.length;\n                    do {\n                        areaIndex--;\n                        drawAreaSectionImage(backgroundContext, area[areaIndex].start, area[areaIndex].stop, area[areaIndex].color, true);\n                    }\n                    while (0 < areaIndex);\n                    backgroundContext.restore();\n                }\n\n                // Create tickmarks in background buffer (backgroundBuffer)\n                drawTickmarksImage(backgroundContext, labelNumberFormat);\n\n                // Create title in background buffer (backgroundBuffer)\n                drawTitleImage(backgroundContext);\n            }\n\n            // Draw threshold image to background context\n            if (thresholdVisible) {\n                backgroundContext.save();\n                if (steelseries.Orientation.WEST === orientation) {\n                    backgroundContext.translate(centerX, centerX);\n                    backgroundContext.rotate(-HALF_PI);\n                    backgroundContext.translate(-centerX, -centerX);\n                }\n                if (steelseries.Orientation.EAST === orientation) {\n                    backgroundContext.translate(centerX, centerX);\n                    backgroundContext.rotate(HALF_PI);\n                    backgroundContext.translate(-centerX, -centerX);\n                }\n                backgroundContext.translate(centerX, centerY);\n                backgroundContext.rotate(rotationOffset + (threshold - minValue) * angleStep + HALF_PI);\n                backgroundContext.translate(-centerX, -centerY);\n                backgroundContext.drawImage(createThresholdImage(), imageWidth * 0.475, imageHeight * 0.32);\n                backgroundContext.restore();\n            }\n\n            // Create pointer image in pointer buffer (contentBuffer)\n            if (drawPointer) {\n                drawPointerImage(pointerContext, imageWidth * 1.17, pointerType, pointerColor, backgroundColor.labelColor);\n\n            }\n\n            // Create foreground in foreground buffer (foregroundBuffer)\n            if (drawForeground && foregroundVisible) {\n                var knobVisible = (pointerType.type === 'type15' || pointerType.type === 'type16' ? false : true);\n                drawRadialForegroundImage(foregroundContext, foregroundType, imageWidth, imageHeight, knobVisible, knobType, knobStyle, gaugeType, orientation);\n            }\n        };\n\n        var resetBuffers = function (buffers) {\n            buffers = buffers || {};\n            var resetFrame = (undefined === buffers.frame ? false : buffers.frame);\n            var resetBackground = (undefined === buffers.background ? false : buffers.background);\n            var resetLed = (undefined === buffers.led ? false : buffers.led);\n            var resetPointer = (undefined === buffers.pointer ? false : buffers.pointer);\n            var resetForeground = (undefined === buffers.foreground ? false : buffers.foreground);\n\n            if (resetFrame) {\n                frameBuffer.width = size;\n                frameBuffer.height = size;\n                frameContext = frameBuffer.getContext('2d');\n            }\n\n            if (resetBackground) {\n                backgroundBuffer.width = size;\n                backgroundBuffer.height = size;\n                backgroundContext = backgroundBuffer.getContext('2d');\n            }\n\n            if (resetLed) {\n                ledBufferOn.width = Math.ceil(size * 0.093457);\n                ledBufferOn.height = Math.ceil(size * 0.093457);\n                ledContextOn = ledBufferOn.getContext('2d');\n\n                ledBufferOff.width = Math.ceil(size * 0.093457);\n                ledBufferOff.height = Math.ceil(size * 0.093457);\n                ledContextOff = ledBufferOff.getContext('2d');\n\n                // Buffer for current led painting code\n                ledBuffer = ledBufferOff;\n            }\n\n            if (resetPointer) {\n                pointerBuffer.width = size;\n                pointerBuffer.height = size;\n                pointerContext = pointerBuffer.getContext('2d');\n            }\n\n            if (resetForeground) {\n                foregroundBuffer.width = size;\n                foregroundBuffer.height = size;\n                foregroundContext = foregroundBuffer.getContext('2d');\n            }\n        };\n\n        var blink = function (blinking) {\n            if (blinking) {\n                ledTimerId = setInterval(toggleAndRepaintLed, 1000);\n            } else {\n                clearInterval(ledTimerId);\n                ledBuffer = ledBufferOff;\n            }\n        };\n\n        var toggleAndRepaintLed = function () {\n            if (ledVisible) {\n                if (ledBuffer === ledBufferOn) {\n                    ledBuffer = ledBufferOff;\n                } else {\n                    ledBuffer = ledBufferOn;\n                }\n                if (!repainting) {\n                    repainting = true;\n                    requestAnimFrame(self.repaint);\n                }\n            }\n        };\n\n        //************************************ Public methods **************************************\n        this.setValue = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = (newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue));\n            if (value !== targetValue) {\n                value = targetValue;\n\n                if (value > maxMeasuredValue) {\n                    maxMeasuredValue = value;\n                }\n                if (value < minMeasuredValue) {\n                    minMeasuredValue = value;\n                }\n\n                if ((value >= threshold && !ledBlinking && thresholdRising) ||\n                    (value <= threshold && !ledBlinking && !thresholdRising)) {\n                    ledBlinking = true;\n                    blink(ledBlinking);\n                    if (playAlarm) {\n                        audioElement.play();\n                    }\n                } else if ((value < threshold && ledBlinking && thresholdRising) ||\n                           (value > threshold && ledBlinking && !thresholdRising)) {\n                    ledBlinking = false;\n                    blink(ledBlinking);\n                    if (playAlarm) {\n                        audioElement.pause();\n                    }\n                }\n\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getValue = function () {\n            return value;\n        };\n\n        this.setValueAnimated = function (newValue, callback) {\n            newValue = parseFloat(newValue);\n            var targetValue = (newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue)),\n                gauge = this,\n                time;\n\n            if (value !== targetValue) {\n                if (undefined !==  tween && tween.isPlaying) {\n                    tween.stop();\n                }\n\n                time = fullScaleDeflectionTime * Math.abs(targetValue - value) / (maxValue - minValue);\n                time = Math.max(time, fullScaleDeflectionTime / 5);\n                tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, time);\n                //tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, 1);\n                //tween = new Tween(new Object(), '', Tween.strongEaseInOut, value, targetValue, 1);\n                tween.onMotionChanged = function (event) {\n                    value = event.target._pos;\n\n                    if ((value >= threshold && !ledBlinking && thresholdRising) ||\n                        (value <= threshold && !ledBlinking && !thresholdRising)) {\n                        ledBlinking = true;\n                        blink(ledBlinking);\n                        if (playAlarm) {\n                            audioElement.play();\n                        }\n                    } else if ((value < threshold && ledBlinking && thresholdRising) ||\n                               (value > threshold && ledBlinking && !thresholdRising)) {\n                        ledBlinking = false;\n                        blink(ledBlinking);\n                        if (playAlarm) {\n                            audioElement.pause();\n                        }\n                    }\n\n                    if (value > maxMeasuredValue) {\n                        maxMeasuredValue = value;\n                    }\n                    if (value < minMeasuredValue) {\n                        minMeasuredValue = value;\n                    }\n\n                    if (!repainting) {\n                        repainting = true;\n                        requestAnimFrame(gauge.repaint);\n                    }\n                };\n\n                // do we have a callback function to process?\n                if (callback && typeof(callback) === \"function\") {\n                    tween.onMotionFinished = callback;\n                }\n\n                tween.start();\n            }\n            return this;\n        };\n\n        this.resetMinMeasuredValue = function () {\n            minMeasuredValue = value;\n            this.repaint();\n            return this;\n        };\n\n        this.resetMaxMeasuredValue = function () {\n            maxMeasuredValue = value;\n            this.repaint();\n            return this;\n        };\n\n        this.setMinMeasuredValueVisible = function (visible) {\n            minMeasuredValueVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setMaxMeasuredValueVisible = function (visible) {\n            maxMeasuredValueVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setThresholdVisible = function (visible) {\n            thresholdVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setThresholdRising = function (rising) {\n            thresholdRising = !!rising;\n            // reset existing threshold alerts\n            ledBlinking = !ledBlinking;\n            blink(ledBlinking);\n            this.repaint();\n            return this;\n        };\n\n        this.setFrameDesign = function (newFrameDesign) {\n            resetBuffers({frame: true});\n            frameDesign = newFrameDesign;\n            init({frame: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setBackgroundColor = function (newBackgroundColor) {\n            resetBuffers({background: true,\n                          pointer: (pointerType.type === 'type2' || pointerType.type === 'type13' ? true : false)       // type2 & 13 depend on background\n                          });\n            backgroundColor = newBackgroundColor;\n            init({background: true,\n                  pointer: (pointerType.type === 'type2' || pointerType.type === 'type13' ? true : false)       // type2 & 13 depend on background\n                });\n            this.repaint();\n            return this;\n        };\n\n        this.setForegroundType = function (newForegroundType) {\n            resetBuffers({foreground: true});\n            foregroundType = newForegroundType;\n            init({foreground: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerType = function (newPointerType) {\n            resetBuffers({pointer: true,\n                          foreground: true  // Required as type15 does not need a knob\n                         });\n            pointerType = newPointerType;\n            init({pointer: true,\n                  foreground: true\n                 });\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerColor = function (newPointerColor) {\n            resetBuffers({pointer: true});\n            pointerColor = newPointerColor;\n            init({pointer: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLedColor = function (newLedColor) {\n            resetBuffers({led: true});\n            ledColor = newLedColor;\n            init({led: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLedVisible = function (visible) {\n            ledVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init({frame: true,\n                      background: true,\n                      led: true,\n                      pointer: true,\n                      foreground: true});\n            }\n\n            mainCtx.clearRect(0, 0, size, size);\n            mainCtx.save();\n\n            // Draw frame\n            if (frameVisible) {\n                mainCtx.drawImage(frameBuffer, 0, 0);\n            }\n\n            // Draw buffered image to visible canvas\n            mainCtx.drawImage(backgroundBuffer, 0, 0);\n\n            // Draw led\n            if (ledVisible) {\n                mainCtx.drawImage(ledBuffer, ledPosX, ledPosY);\n            }\n\n            if (steelseries.Orientation.WEST === orientation) {\n                mainCtx.translate(centerX, centerX);\n                mainCtx.rotate(-HALF_PI);\n                mainCtx.translate(-centerX, -centerX);\n            }\n            if (steelseries.Orientation.EAST === orientation) {\n                mainCtx.translate(centerX, centerX);\n                mainCtx.rotate(HALF_PI);\n                mainCtx.translate(-centerX, -centerX);\n            }\n\n            // Draw min measured value indicator\n            if (minMeasuredValueVisible) {\n                mainCtx.save();\n                mainCtx.translate(centerX, centerY);\n                mainCtx.rotate(rotationOffset + HALF_PI + (minMeasuredValue - minValue) * angleStep);\n                mainCtx.translate(-centerX, -centerY);\n                mainCtx.drawImage(minMeasuredValueBuffer, mainCtx.canvas.width * 0.4865, mainCtx.canvas.height * 0.27);\n                mainCtx.restore();\n            }\n\n            // Draw max measured value indicator\n            if (maxMeasuredValueVisible) {\n                mainCtx.save();\n                mainCtx.translate(centerX, centerY);\n                mainCtx.rotate(rotationOffset + HALF_PI + (maxMeasuredValue - minValue) * angleStep);\n                mainCtx.translate(-centerX, -centerY);\n                mainCtx.drawImage(maxMeasuredValueBuffer, mainCtx.canvas.width * 0.4865, mainCtx.canvas.height * 0.27);\n                mainCtx.restore();\n            }\n\n            angle = rotationOffset + HALF_PI + (value - minValue) * angleStep;\n\n            // Define rotation center\n            mainCtx.save();\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate(angle);\n            // Set the pointer shadow params\n            mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n            mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset;\n            mainCtx.shadowBlur = shadowOffset * 2;\n            // Draw pointer\n            mainCtx.translate(-pointerOffset, -pointerOffset);\n            mainCtx.drawImage(pointerBuffer, 0, 0);\n            // Undo the translations & shadow settings\n            mainCtx.restore();\n\n            // Draw foreground\n            if (foregroundVisible) {\n                if (steelseries.Orientation.WEST === orientation) {\n                    mainCtx.translate(centerX, centerX);\n                    mainCtx.rotate(HALF_PI);\n                    mainCtx.translate(-centerX, -centerX);\n                } else if (steelseries.Orientation.EAST === orientation) {\n                    mainCtx.translate(centerX, centerX);\n                    mainCtx.rotate(-HALF_PI);\n                    mainCtx.translate(-centerX, -centerX);\n                }\n                mainCtx.drawImage(foregroundBuffer, 0, 0);\n            }\n            mainCtx.restore();\n\n            repainting = false;\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var linear = function (canvas, parameters) {\n        parameters = parameters || {};\n        var gaugeType = (undefined === parameters.gaugeType ? steelseries.GaugeType.TYPE1 : parameters.gaugeType),\n            width = (undefined === parameters.width ? 0 : parameters.width),\n            height = (undefined === parameters.height ? 0 : parameters.height),\n            minValue = (undefined === parameters.minValue ? 0 : parameters.minValue),\n            maxValue = (undefined === parameters.maxValue ? (minValue + 100) : parameters.maxValue),\n            niceScale = (undefined === parameters.niceScale ? true : parameters.niceScale),\n            threshold = (undefined === parameters.threshold ? (maxValue - minValue) / 2 + minValue: parameters.threshold),\n            titleString = (undefined === parameters.titleString ? '' : parameters.titleString),\n            unitString = (undefined === parameters.unitString ? '' : parameters.unitString),\n            frameDesign = (undefined === parameters.frameDesign ? steelseries.FrameDesign.METAL : parameters.frameDesign),\n            frameVisible = (undefined === parameters.frameVisible ? true : parameters.frameVisible),\n            backgroundColor = (undefined === parameters.backgroundColor ? steelseries.BackgroundColor.DARK_GRAY : parameters.backgroundColor),\n            backgroundVisible = (undefined === parameters.backgroundVisible ? true : parameters.backgroundVisible),\n            valueColor = (undefined === parameters.valueColor ? steelseries.ColorDef.RED : parameters.valueColor),\n            lcdColor = (undefined === parameters.lcdColor ? steelseries.LcdColor.STANDARD : parameters.lcdColor),\n            lcdVisible = (undefined === parameters.lcdVisible ? true : parameters.lcdVisible),\n            lcdDecimals = (undefined === parameters.lcdDecimals ? 2 : parameters.lcdDecimals),\n            digitalFont = (undefined === parameters.digitalFont ? false : parameters.digitalFont),\n            ledColor = (undefined === parameters.ledColor ? steelseries.LedColor.RED_LED : parameters.ledColor),\n            ledVisible = (undefined === parameters.ledVisible ? true : parameters.ledVisible),\n            thresholdVisible = (undefined === parameters.thresholdVisible ? true : parameters.thresholdVisible),\n            thresholdRising = (undefined === parameters.thresholdRising ? true : parameters.thresholdRising),\n            minMeasuredValueVisible = (undefined === parameters.minMeasuredValueVisible ? false : parameters.minMeasuredValueVisible),\n            maxMeasuredValueVisible = (undefined === parameters.maxMeasuredValueVisible ? false : parameters.maxMeasuredValueVisible),\n            labelNumberFormat = (undefined === parameters.labelNumberFormat ? steelseries.LabelNumberFormat.STANDARD : parameters.labelNumberFormat),\n            foregroundVisible = (undefined === parameters.foregroundVisible ? true : parameters.foregroundVisible),\n            playAlarm = (undefined === parameters.playAlarm ? false : parameters.playAlarm),\n            alarmSound = (undefined === parameters.alarmSound ? false : parameters.alarmSound),\n            fullScaleDeflectionTime = (undefined === parameters.fullScaleDeflectionTime ? 2.5 : parameters.fullScaleDeflectionTime);\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (width === 0) {\n            width = mainCtx.canvas.width;\n        }\n        if (height === 0) {\n            height = mainCtx.canvas.height;\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = width;\n        mainCtx.canvas.height = height;\n\n        var imageWidth = width;\n        var imageHeight = height;\n\n        // Create audio tag for alarm sound\n        if (playAlarm && alarmSound !== false) {\n            var audioElement = doc.createElement('audio');\n            audioElement.setAttribute('src', alarmSound);\n            //audioElement.setAttribute('src', 'js/alarm.mp3');\n            audioElement.setAttribute('preload', 'auto');\n        }\n\n        var self = this;\n        var value = minValue;\n\n        // Properties\n        var minMeasuredValue = maxValue;\n        var maxMeasuredValue = minValue;\n\n        // Check gaugeType is 1 or 2\n        if (gaugeType.type !== 'type1' && gaugeType.type !== 'type2') {\n            gaugeType = steelseries.GaugeType.TYPE1;\n        }\n\n        var tween;\n        var ledBlinking = false;\n        var repainting = false;\n\n        var ledTimerId = 0;\n\n        var vertical = width <= height;\n\n        // Constants\n        var ledPosX;\n        var ledPosY;\n        var ledSize = Math.round((vertical ? height : width) * 0.05);\n        var minMaxIndSize = Math.round((vertical ? width : height) * 0.05);\n        var stdFont;\n        var lcdFont;\n\n        // Misc\n        if (vertical) {\n            ledPosX = imageWidth / 2 - ledSize / 2;\n            ledPosY = (gaugeType.type === 'type1' ? 0.053 : 0.038) * imageHeight;\n            stdFont = Math.floor(imageHeight / 22) + 'px ' + stdFontName;\n            lcdFont = Math.floor(imageHeight / 22) + 'px ' + lcdFontName;\n        } else {\n            ledPosX = 0.89 * imageWidth;\n            ledPosY = imageHeight / 2 - ledSize / 2;\n            stdFont = Math.floor(imageHeight / 10) + 'px ' + stdFontName;\n            lcdFont = Math.floor(imageHeight / 10) + 'px ' + lcdFontName;\n        }\n\n        var initialized = false;\n\n        // Tickmark specific private variables\n        var niceMinValue = minValue;\n        var niceMaxValue = maxValue;\n        var niceRange = maxValue - minValue;\n        var range = niceMaxValue - niceMinValue;\n        var minorTickSpacing = 0;\n        var majorTickSpacing = 0;\n        var maxNoOfMinorTicks = 10;\n        var maxNoOfMajorTicks = 10;\n\n        // Method to calculate nice values for min, max and range for the tickmarks\n        var calculate = function calculate() {\n            if (niceScale) {\n                niceRange = calcNiceNumber(maxValue - minValue, false);\n                majorTickSpacing = calcNiceNumber(niceRange / (maxNoOfMajorTicks - 1), true);\n                niceMinValue = Math.floor(minValue / majorTickSpacing) * majorTickSpacing;\n                niceMaxValue = Math.ceil(maxValue / majorTickSpacing) * majorTickSpacing;\n                minorTickSpacing = calcNiceNumber(majorTickSpacing / (maxNoOfMinorTicks - 1), true);\n                minValue = niceMinValue;\n                maxValue = niceMaxValue;\n                range = maxValue - minValue;\n            } else {\n                niceRange = (maxValue - minValue);\n                niceMinValue = minValue;\n                niceMaxValue = maxValue;\n                range = niceRange;\n                minorTickSpacing = 1;\n                majorTickSpacing = 10;\n            }\n        };\n\n        // **************   Buffer creation  ********************\n        // Buffer for the frame\n        var frameBuffer = createBuffer(width, height);\n        var frameContext = frameBuffer.getContext('2d');\n\n        // Buffer for the background\n        var backgroundBuffer = createBuffer(width, height);\n        var backgroundContext = backgroundBuffer.getContext('2d');\n\n        var lcdBuffer;\n\n        // Buffer for led on painting code\n        var ledBufferOn = createBuffer(ledSize, ledSize);\n        var ledContextOn = ledBufferOn.getContext('2d');\n\n        // Buffer for led off painting code\n        var ledBufferOff = createBuffer(ledSize, ledSize);\n        var ledContextOff = ledBufferOff.getContext('2d');\n\n        // Buffer for current led painting code\n        var ledBuffer = ledBufferOff;\n\n        // Buffer for the minMeasuredValue indicator\n        var minMeasuredValueBuffer = createBuffer(minMaxIndSize, minMaxIndSize);\n        var minMeasuredValueCtx = minMeasuredValueBuffer.getContext('2d');\n\n        // Buffer for the maxMeasuredValue indicator\n        var maxMeasuredValueBuffer = createBuffer(minMaxIndSize, minMaxIndSize);\n        var maxMeasuredValueCtx = maxMeasuredValueBuffer.getContext('2d');\n\n        // Buffer for static foreground painting code\n        var foregroundBuffer = createBuffer(width, height);\n        var foregroundContext = foregroundBuffer.getContext('2d');\n\n        // **************   Image creation  ********************\n        var drawLcdText = function (ctx, value, vertical) {\n            ctx.save();\n            ctx.textAlign = 'right';\n            ctx.textBaseline = 'middle';\n            ctx.strokeStyle = lcdColor.textColor;\n            ctx.fillStyle = lcdColor.textColor;\n\n            if (lcdColor === steelseries.LcdColor.STANDARD || lcdColor === steelseries.LcdColor.STANDARD_GREEN) {\n                ctx.shadowColor = 'gray';\n                if (vertical) {\n                    ctx.shadowOffsetX = imageHeight * 0.003;\n                    ctx.shadowOffsetY = imageHeight * 0.003;\n                    ctx.shadowBlur = imageHeight * 0.004;\n                } else {\n                    ctx.shadowOffsetX = imageHeight * 0.007;\n                    ctx.shadowOffsetY = imageHeight * 0.007;\n                    ctx.shadowBlur = imageHeight * 0.009;\n                }\n            }\n\n            var lcdTextX;\n            var lcdTextY;\n            var lcdTextWidth;\n\n            if (digitalFont) {\n                ctx.font = lcdFont;\n            } else {\n                ctx.font = stdFont;\n            }\n\n            if (vertical) {\n                lcdTextX = (imageWidth - (imageWidth * 0.571428)) / 2  + imageWidth * 0.571428 - 2;\n                lcdTextY = imageHeight * 0.88 + 1 + (imageHeight * 0.055 - 2) / 2;\n                lcdTextWidth = imageWidth * 0.7 - 2;\n            } else {\n                lcdTextX = (imageWidth * 0.695) + imageWidth * 0.18 - 2;\n                lcdTextY = (imageHeight * 0.22) + 1 + (imageHeight * 0.15 - 2) / 2;\n                lcdTextWidth = imageHeight * 0.22 - 2;\n            }\n\n            ctx.fillText(value.toFixed(lcdDecimals), lcdTextX, lcdTextY, lcdTextWidth);\n\n            ctx.restore();\n        };\n\n        var createThresholdImage = function (vertical) {\n            var thresholdBuffer = doc.createElement('canvas');\n            var thresholdCtx = thresholdBuffer.getContext('2d');\n            thresholdBuffer.height = thresholdBuffer.width = minMaxIndSize;\n\n            thresholdCtx.save();\n            var gradThreshold = thresholdCtx.createLinearGradient(0, 0.1, 0, thresholdBuffer.height * 0.9);\n            gradThreshold.addColorStop(0, '#520000');\n            gradThreshold.addColorStop(0.3, '#fc1d00');\n            gradThreshold.addColorStop(0.59, '#fc1d00');\n            gradThreshold.addColorStop(1, '#520000');\n            thresholdCtx.fillStyle = gradThreshold;\n\n            if (vertical) {\n                thresholdCtx.beginPath();\n                thresholdCtx.moveTo(0.1, thresholdBuffer.height * 0.5);\n                thresholdCtx.lineTo(thresholdBuffer.width * 0.9, 0.1);\n                thresholdCtx.lineTo(thresholdBuffer.width * 0.9, thresholdBuffer.height * 0.9);\n                thresholdCtx.closePath();\n            } else {\n                thresholdCtx.beginPath();\n                thresholdCtx.moveTo(0.1, 0.1);\n                thresholdCtx.lineTo(thresholdBuffer.width * 0.9, 0.1);\n                thresholdCtx.lineTo(thresholdBuffer.width * 0.5, thresholdBuffer.height * 0.9);\n                thresholdCtx.closePath();\n            }\n\n            thresholdCtx.fill();\n            thresholdCtx.strokeStyle = '#FFFFFF';\n            thresholdCtx.stroke();\n\n            thresholdCtx.restore();\n\n            return thresholdBuffer;\n        };\n\n        var drawTickmarksImage = function (ctx, labelNumberFormat, vertical) {\n            backgroundColor.labelColor.setAlpha(1);\n            ctx.save();\n            ctx.textBaseline = 'middle';\n            var TEXT_WIDTH = imageWidth * 0.1;\n            ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n\n            var valueCounter = minValue;\n            var majorTickCounter = maxNoOfMinorTicks - 1;\n            var tickCounter;\n            var currentPos;\n            var scaleBoundsX;\n            var scaleBoundsY;\n            var scaleBoundsW;\n            var scaleBoundsH;\n            var tickSpaceScaling = 1;\n\n            var minorTickStart;\n            var minorTickStop;\n            var mediumTickStart;\n            var mediumTickStop;\n            var majorTickStart;\n            var majorTickStop;\n            if (vertical) {\n                minorTickStart = (0.34 * imageWidth);\n                minorTickStop = (0.36 * imageWidth);\n                mediumTickStart = (0.33 * imageWidth);\n                mediumTickStop = (0.36 * imageWidth);\n                majorTickStart = (0.32 * imageWidth);\n                majorTickStop = (0.36 * imageWidth);\n                ctx.textAlign = 'right';\n                scaleBoundsX = 0;\n                scaleBoundsY = imageHeight * 0.128640;\n                scaleBoundsW = 0;\n                if (gaugeType.type === 'type1') {\n                    scaleBoundsH = (imageHeight * 0.856796 - imageHeight * 0.128640);\n                } else {\n                    scaleBoundsH = (imageHeight * 0.7475 - imageHeight * 0.128640);\n                }\n                tickSpaceScaling = scaleBoundsH / (maxValue - minValue);\n            } else {\n                minorTickStart = (0.65 * imageHeight);\n                minorTickStop = (0.63 * imageHeight);\n                mediumTickStart = (0.66 * imageHeight);\n                mediumTickStop = (0.63 * imageHeight);\n                majorTickStart = (0.67 * imageHeight);\n                majorTickStop = (0.63 * imageHeight);\n                ctx.textAlign = 'center';\n                scaleBoundsY = 0;\n                if (gaugeType.type === 'type1') {\n                    scaleBoundsX = imageWidth * 0.142857;\n                    scaleBoundsW = (imageWidth * 0.871012 - scaleBoundsX);\n                } else {\n                    scaleBoundsX = imageWidth * 0.19857;\n                    scaleBoundsW = (imageWidth * 0.82 - scaleBoundsX);\n                }\n                scaleBoundsH = 0;\n                tickSpaceScaling = scaleBoundsW / (maxValue - minValue);\n            }\n\n            var labelCounter;\n            for (labelCounter = minValue, tickCounter = 0; labelCounter <= maxValue; labelCounter += minorTickSpacing, tickCounter += minorTickSpacing) {\n\n                // Calculate the bounds of the scaling\n                if (vertical) {\n                    currentPos = scaleBoundsY + scaleBoundsH - tickCounter * tickSpaceScaling;\n                } else {\n                    currentPos = scaleBoundsX + tickCounter * tickSpaceScaling;\n                }\n\n                majorTickCounter++;\n\n                // Draw tickmark every major tickmark spacing\n                if (majorTickCounter === maxNoOfMinorTicks) {\n\n                    // Draw the major tickmarks\n                    ctx.lineWidth = 1.5;\n                    drawLinearTicks(ctx, majorTickStart, majorTickStop, currentPos, vertical);\n\n                    // Draw the standard tickmark labels\n                    if (vertical) {\n                        // Vertical orientation\n                        switch (labelNumberFormat.format) {\n                        case 'fractional':\n                            ctx.fillText((valueCounter.toFixed(2)), imageWidth * 0.28, currentPos, TEXT_WIDTH);\n                            break;\n\n                        case 'scientific':\n                            ctx.fillText((valueCounter.toPrecision(2)), imageWidth * 0.28, currentPos, TEXT_WIDTH);\n                            break;\n\n                        case 'standard':\n                        /* falls through */\n                        default:\n                            ctx.fillText((valueCounter.toFixed(0)), imageWidth * 0.28, currentPos, TEXT_WIDTH);\n                            break;\n                        }\n                    } else {\n                        // Horizontal orientation\n                        switch (labelNumberFormat.format) {\n                        case 'fractional':\n                            ctx.fillText((valueCounter.toFixed(2)), currentPos, (imageHeight * 0.73), TEXT_WIDTH);\n                            break;\n\n                        case 'scientific':\n                            ctx.fillText((valueCounter.toPrecision(2)), currentPos, (imageHeight * 0.73), TEXT_WIDTH);\n                            break;\n\n                        case 'standard':\n                        /* falls through */\n                        default:\n                            ctx.fillText((valueCounter.toFixed(0)), currentPos, (imageHeight * 0.73), TEXT_WIDTH);\n                            break;\n                        }\n                    }\n\n                    valueCounter += majorTickSpacing;\n                    majorTickCounter = 0;\n                    continue;\n                }\n\n                // Draw tickmark every minor tickmark spacing\n                if (0 === maxNoOfMinorTicks % 2 && majorTickCounter === (maxNoOfMinorTicks / 2)) {\n                    ctx.lineWidth = 1;\n                    drawLinearTicks(ctx, mediumTickStart, mediumTickStop, currentPos, vertical);\n                } else {\n                    ctx.lineWidth = 0.5;\n                    drawLinearTicks(ctx, minorTickStart, minorTickStop, currentPos, vertical);\n                }\n            }\n\n            ctx.restore();\n        };\n\n        var drawLinearTicks = function (ctx, tickStart, tickStop, currentPos, vertical) {\n            if (vertical) {\n                // Vertical orientation\n                ctx.beginPath();\n                ctx.moveTo(tickStart, currentPos);\n                ctx.lineTo(tickStop, currentPos);\n                ctx.closePath();\n                ctx.stroke();\n            } else {\n                // Horizontal orientation\n                ctx.beginPath();\n                ctx.moveTo(currentPos, tickStart);\n                ctx.lineTo(currentPos, tickStop);\n                ctx.closePath();\n                ctx.stroke();\n            }\n        };\n\n        // **************   Initialization  ********************\n        var init = function (parameters) {\n            parameters = parameters || {};\n            var drawFrame = (undefined === parameters.frame ? false : parameters.frame);\n            var drawBackground = (undefined === parameters.background ? false : parameters.background);\n            var drawLed = (undefined === parameters.led ? false : parameters.led);\n            var drawForeground = (undefined === parameters.foreground ? false : parameters.foreground);\n\n            var yOffset;\n            var yRange;\n            var valuePos;\n\n            initialized = true;\n\n            // Calculate the current min and max values and the range\n            calculate();\n\n            // Create frame in frame buffer (backgroundBuffer)\n            if (drawFrame && frameVisible) {\n                drawLinearFrameImage(frameContext, frameDesign, imageWidth, imageHeight, vertical);\n            }\n\n            // Create background in background buffer (backgroundBuffer)\n            if (drawBackground && backgroundVisible) {\n                drawLinearBackgroundImage(backgroundContext, backgroundColor, imageWidth, imageHeight, vertical);\n            }\n\n            // draw Thermometer outline\n            if (drawBackground && gaugeType.type === 'type2') {\n                drawBackgroundImage(backgroundContext);\n            }\n\n            if (drawLed) {\n                if (vertical) {\n                    // Draw LED ON in ledBuffer_ON\n                    ledContextOn.drawImage(createLedImage(ledSize, 1, ledColor), 0, 0);\n\n                    // Draw LED ON in ledBuffer_OFF\n                    ledContextOff.drawImage(createLedImage(ledSize, 0, ledColor), 0, 0);\n                } else {\n                    // Draw LED ON in ledBuffer_ON\n                    ledContextOn.drawImage(createLedImage(ledSize, 1, ledColor), 0, 0);\n\n                    // Draw LED ON in ledBuffer_OFF\n                    ledContextOff.drawImage(createLedImage(ledSize, 0, ledColor), 0, 0);\n                }\n            }\n\n            // Draw min measured value indicator in minMeasuredValueBuffer\n            if (minMeasuredValueVisible) {\n                if (vertical) {\n                    minMeasuredValueCtx.drawImage(createMeasuredValueImage(minMaxIndSize, steelseries.ColorDef.BLUE.dark.getRgbaColor(), false, vertical), 0, 0);\n                } else {\n                    minMeasuredValueCtx.drawImage(createMeasuredValueImage(minMaxIndSize, steelseries.ColorDef.BLUE.dark.getRgbaColor(), false, vertical), 0, 0);\n                }\n            }\n\n            // Draw max measured value indicator in maxMeasuredValueBuffer\n            if (maxMeasuredValueVisible) {\n                if (vertical) {\n                    maxMeasuredValueCtx.drawImage(createMeasuredValueImage(minMaxIndSize, steelseries.ColorDef.RED.medium.getRgbaColor(), false, vertical), 0, 0);\n                } else {\n                    maxMeasuredValueCtx.drawImage(createMeasuredValueImage(minMaxIndSize, steelseries.ColorDef.RED.medium.getRgbaColor(), false, vertical), 0, 0);\n                }\n            }\n\n            // Create alignment posts in background buffer (backgroundBuffer)\n            if (drawBackground && backgroundVisible) {\n\n                // Create tickmarks in background buffer (backgroundBuffer)\n                drawTickmarksImage(backgroundContext, labelNumberFormat, vertical);\n\n                // Create title in background buffer (backgroundBuffer)\n                if (vertical) {\n                    drawTitleImage(backgroundContext, imageWidth, imageHeight, titleString, unitString, backgroundColor, vertical, null, lcdVisible, gaugeType);\n                } else {\n                    drawTitleImage(backgroundContext, imageWidth, imageHeight, titleString, unitString, backgroundColor, vertical, null, lcdVisible, gaugeType);\n                }\n            }\n\n            // Draw threshold image to background context\n            if (drawBackground && thresholdVisible) {\n                backgroundContext.save();\n                if (vertical) {\n                    // Vertical orientation\n                    yOffset = (gaugeType.type === 'type1' ? 0.856796 : 0.7475);\n                    yRange = yOffset - 0.128640;\n                    valuePos = imageHeight * yOffset - (imageHeight * yRange) * (threshold - minValue) / (maxValue - minValue);\n                    backgroundContext.translate(imageWidth * 0.365, valuePos - minMaxIndSize / 2);\n                } else {\n                    // Horizontal orientation\n                    yOffset = (gaugeType.type === 'type1' ? 0.871012 : 0.82);\n                    yRange = yOffset - (gaugeType.type === 'type1' ? 0.142857 : 0.19857);\n                    valuePos = imageWidth * yRange * (threshold - minValue) / (maxValue - minValue);\n                    backgroundContext.translate(imageWidth * (gaugeType.type === 'type1' ? 0.142857 : 0.19857) - minMaxIndSize / 2 + valuePos, imageHeight * 0.58);\n                }\n                backgroundContext.drawImage(createThresholdImage(vertical), 0, 0);\n                backgroundContext.restore();\n            }\n\n            // Create lcd background if selected in background buffer (backgroundBuffer)\n            if (drawBackground && lcdVisible) {\n                if (vertical) {\n                    lcdBuffer = createLcdBackgroundImage(imageWidth * 0.571428, imageHeight * 0.055, lcdColor);\n                    backgroundContext.drawImage(lcdBuffer, ((imageWidth - (imageWidth * 0.571428)) / 2), imageHeight * 0.88);\n                } else {\n                    lcdBuffer = createLcdBackgroundImage(imageWidth * 0.18, imageHeight * 0.15, lcdColor);\n                    backgroundContext.drawImage(lcdBuffer, imageWidth * 0.695, imageHeight * 0.22);\n                }\n            }\n\n            // add thermometer stem foreground\n            if (drawForeground && gaugeType.type === 'type2') {\n                drawForegroundImage(foregroundContext);\n            }\n\n            // Create foreground in foreground buffer (foregroundBuffer)\n            if (drawForeground && foregroundVisible) {\n                drawLinearForegroundImage(foregroundContext, imageWidth, imageHeight, vertical, false);\n            }\n        };\n\n        var resetBuffers = function (buffers) {\n            buffers = buffers || {};\n            var resetFrame = (undefined === buffers.frame ? false : buffers.frame);\n            var resetBackground = (undefined === buffers.background ? false : buffers.background);\n            var resetLed = (undefined === buffers.led ? false : buffers.led);\n            var resetForeground = (undefined === buffers.foreground ? false : buffers.foreground);\n\n            if (resetFrame) {\n                frameBuffer.width = width;\n                frameBuffer.height = height;\n                frameContext = frameBuffer.getContext('2d');\n            }\n\n            if (resetBackground) {\n                backgroundBuffer.width = width;\n                backgroundBuffer.height = height;\n                backgroundContext = backgroundBuffer.getContext('2d');\n            }\n\n            if (resetLed) {\n                ledBufferOn.width = Math.ceil(width * 0.093457);\n                ledBufferOn.height = Math.ceil(height * 0.093457);\n                ledContextOn = ledBufferOn.getContext('2d');\n\n                ledBufferOff.width = Math.ceil(width * 0.093457);\n                ledBufferOff.height = Math.ceil(height * 0.093457);\n                ledContextOff = ledBufferOff.getContext('2d');\n\n                // Buffer for current led painting code\n                ledBuffer = ledBufferOff;\n            }\n\n            if (resetForeground) {\n                foregroundBuffer.width = width;\n                foregroundBuffer.height = height;\n                foregroundContext = foregroundBuffer.getContext('2d');\n            }\n        };\n\n        var blink = function (blinking) {\n            if (blinking) {\n                ledTimerId = setInterval(toggleAndRepaintLed, 1000);\n            } else {\n                clearInterval(ledTimerId);\n                ledBuffer = ledBufferOff;\n            }\n        };\n\n        var toggleAndRepaintLed = function () {\n            if (ledVisible) {\n                if (ledBuffer === ledBufferOn) {\n                    ledBuffer = ledBufferOff;\n                } else {\n                    ledBuffer = ledBufferOn;\n                }\n                if (!repainting) {\n                    repainting = true;\n                    requestAnimFrame(self.repaint);\n                }\n            }\n        };\n\n        var drawValue = function (ctx, imageWidth, imageHeight) {\n            var top; // position of max value\n            var bottom; // position of min value\n            var labelColor = backgroundColor.labelColor;\n            var fullSize;\n            var valueSize, valueTop;\n            var valueStartX, valueStartY, valueStopX, valueStopY;\n            var valueBackgroundStartX, valueBackgroundStartY, valueBackgroundStopX, valueBackgroundStopY;\n            var valueBorderStartX, valueBorderStartY, valueBorderStopX, valueBorderStopY;\n            var valueForegroundStartX, valueForegroundStartY, valueForegroundStopX, valueForegroundStopY;\n\n            // Orientation dependend definitions\n            if (vertical) {\n                // Vertical orientation\n                top =  imageHeight * 0.128640; // position of max value\n                if (gaugeType.type === 'type1') {\n                    bottom = imageHeight * 0.856796; // position of min value\n                } else {\n                    bottom = imageHeight * 0.7475;\n                }\n                fullSize = bottom - top;\n                valueSize = fullSize * (value - minValue) / (maxValue - minValue);\n                valueTop = bottom - valueSize;\n                valueBackgroundStartX = 0;\n                valueBackgroundStartY = top;\n                valueBackgroundStopX = 0;\n                valueBackgroundStopY = bottom;\n            } else {\n                // Horizontal orientation\n                if (gaugeType.type === 'type1') {\n                    top = imageWidth * 0.871012; // position of max value\n                    bottom = imageWidth * 0.142857; // position of min value\n                } else {\n                    top = imageWidth * 0.82; // position of max value\n                    bottom = imageWidth * 0.19857; // position of min value\n                }\n                fullSize = top - bottom;\n                valueSize = fullSize * (value - minValue) / (maxValue - minValue);\n                valueTop = bottom;\n                valueBackgroundStartX = top;\n                valueBackgroundStartY = 0;\n                valueBackgroundStopX = bottom;\n                valueBackgroundStopY = 0;\n            }\n            if (gaugeType.type === 'type1') {\n                var darker = (backgroundColor === steelseries.BackgroundColor.CARBON ||\n                              backgroundColor === steelseries.BackgroundColor.PUNCHED_SHEET ||\n                              backgroundColor === steelseries.BackgroundColor.STAINLESS ||\n                              backgroundColor === steelseries.BackgroundColor.BRUSHED_STAINLESS ||\n                              backgroundColor === steelseries.BackgroundColor.TURNED) ? 0.3 : 0;\n                var valueBackgroundTrackGradient = ctx.createLinearGradient(valueBackgroundStartX, valueBackgroundStartY, valueBackgroundStopX, valueBackgroundStopY);\n                labelColor.setAlpha(0.05 + darker);\n                valueBackgroundTrackGradient.addColorStop(0, labelColor.getRgbaColor());\n                labelColor.setAlpha(0.15 + darker);\n                valueBackgroundTrackGradient.addColorStop(0.48, labelColor.getRgbaColor());\n                labelColor.setAlpha(0.15 + darker);\n                valueBackgroundTrackGradient.addColorStop(0.49, labelColor.getRgbaColor());\n                labelColor.setAlpha(0.05 + darker);\n                valueBackgroundTrackGradient.addColorStop(1, labelColor.getRgbaColor());\n                ctx.fillStyle = valueBackgroundTrackGradient;\n\n                if (vertical) {\n                    ctx.fillRect(imageWidth * 0.435714, top, imageWidth * 0.142857, fullSize);\n                } else {\n                    ctx.fillRect(imageWidth * 0.142857, imageHeight * 0.435714, fullSize, imageHeight * 0.142857);\n                }\n\n                if (vertical) {\n                    // Vertical orientation\n                    valueBorderStartX = 0;\n                    valueBorderStartY = top;\n                    valueBorderStopX = 0;\n                    valueBorderStopY = top + fullSize;\n                } else {\n                    // Horizontal orientation\n                    valueBorderStartX = imageWidth * 0.142857 + fullSize;\n                    valueBorderStartY = 0;\n                    valueBorderStopX = imageWidth * 0.142857;\n                    valueBorderStopY = 0;\n                }\n                var valueBorderGradient = ctx.createLinearGradient(valueBorderStartX, valueBorderStartY, valueBorderStopX, valueBorderStopY);\n                labelColor.setAlpha(0.3 + darker);\n                valueBorderGradient.addColorStop(0, labelColor.getRgbaColor());\n                labelColor.setAlpha(0.69);\n                valueBorderGradient.addColorStop(0.48, labelColor.getRgbaColor());\n                labelColor.setAlpha(0.7);\n                valueBorderGradient.addColorStop(0.49, labelColor.getRgbaColor());\n                labelColor.setAlpha(0.4);\n                valueBorderGradient.addColorStop(1, labelColor.getRgbaColor());\n                ctx.fillStyle = valueBorderGradient;\n                if (vertical) {\n                    ctx.fillRect(imageWidth * 0.435714, top, imageWidth * 0.007142, fullSize);\n                    ctx.fillRect(imageWidth * 0.571428, top, imageWidth * 0.007142, fullSize);\n                } else {\n                    ctx.fillRect(imageWidth * 0.142857, imageHeight * 0.435714, fullSize, imageHeight * 0.007142);\n                    ctx.fillRect(imageWidth * 0.142857, imageHeight * 0.571428, fullSize, imageHeight * 0.007142);\n                }\n            }\n            if (vertical) {\n                // Vertical orientation\n                if (gaugeType.type === 'type1') {\n                    valueStartX = imageWidth * 0.45;\n                    valueStartY = 0;\n                    valueStopX = imageWidth * 0.45 + imageWidth * 0.114285;\n                    valueStopY = 0;\n                } else {\n                    valueStartX = imageWidth / 2 - imageHeight * 0.0486 / 2;\n                    valueStartY = 0;\n                    valueStopX = valueStartX + imageHeight * 0.053;\n                    valueStopY = 0;\n                }\n            } else {\n                // Horizontal orientation\n                if (gaugeType.type === 'type1') {\n                    valueStartX = 0;\n                    valueStartY = imageHeight * 0.45;\n                    valueStopX = 0;\n                    valueStopY = imageHeight * 0.45 + imageHeight * 0.114285;\n                } else {\n                    valueStartX = 0;\n                    valueStartY = imageHeight / 2 - imageWidth * 0.0250;\n                    valueStopX = 0;\n                    valueStopY = valueStartY + imageWidth * 0.053;\n                }\n            }\n\n            var valueBackgroundGradient = ctx.createLinearGradient(valueStartX, valueStartY, valueStopX, valueStopY);\n            valueBackgroundGradient.addColorStop(0, valueColor.medium.getRgbaColor());\n            valueBackgroundGradient.addColorStop(1, valueColor.light.getRgbaColor());\n            ctx.fillStyle = valueBackgroundGradient;\n            var thermoTweak = (gaugeType.type === 'type1' ? 0 : (vertical ? imageHeight * 0.05 : imageWidth * 0.05));\n            if (vertical) {\n                ctx.fillRect(valueStartX, valueTop, valueStopX - valueStartX, valueSize + thermoTweak);\n            } else {\n                ctx.fillRect(valueTop - thermoTweak, valueStartY, valueSize + thermoTweak, valueStopY - valueStartY);\n            }\n\n            if (gaugeType.type === 'type1') {\n                // The light effect on the value\n                if (vertical) {\n                    // Vertical orientation\n                    valueForegroundStartX = imageWidth * 0.45;\n                    valueForegroundStartY = 0;\n                    valueForegroundStopX = valueForegroundStartX + imageWidth * 0.05;\n                    valueForegroundStopY = 0;\n                } else {\n                    // Horizontal orientation\n                    valueForegroundStartX = 0;\n                    valueForegroundStartY = imageHeight * 0.45;\n                    valueForegroundStopX = 0;\n                    valueForegroundStopY = valueForegroundStartY + imageHeight * 0.05;\n                }\n                var valueForegroundGradient = ctx.createLinearGradient(valueForegroundStartX, valueForegroundStartY, valueForegroundStopX, valueForegroundStopY);\n                valueForegroundGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');\n                valueForegroundGradient.addColorStop(0.98, 'rgba(255, 255, 255, 0.0)');\n                ctx.fillStyle = valueForegroundGradient;\n                if (vertical) {\n                    ctx.fillRect(valueForegroundStartX, valueTop, valueForegroundStopX, valueSize);\n                } else {\n                    ctx.fillRect(valueTop, valueForegroundStartY, valueSize, valueForegroundStopY - valueForegroundStartY);\n                }\n            }\n        };\n\n        var drawForegroundImage = function (ctx) {\n            var foreSize = (vertical ? imageHeight : imageWidth);\n\n            ctx.save();\n            if (vertical) {\n                ctx.translate(imageWidth / 2, 0);\n            } else {\n                ctx.translate(imageWidth / 2, imageHeight / 2);\n                ctx.rotate(HALF_PI);\n                ctx.translate(0, -imageWidth / 2 + imageWidth * 0.05);\n            }\n\n            // draw bulb\n            ctx.beginPath();\n            ctx.moveTo(-0.0490 * foreSize, 0.825 * foreSize);\n            ctx.bezierCurveTo(-0.0490 * foreSize, 0.7975 * foreSize, -0.0264 * foreSize, 0.775 * foreSize, 0.0013 * foreSize, 0.775 * foreSize);\n            ctx.bezierCurveTo(0.0264 * foreSize, 0.775 * foreSize, 0.0490 * foreSize, 0.7975 * foreSize, 0.0490 * foreSize, 0.825 * foreSize);\n            ctx.bezierCurveTo(0.0490 * foreSize, 0.85 * foreSize, 0.0264 * foreSize, 0.8725 * foreSize, 0.0013 * foreSize, 0.8725 * foreSize);\n            ctx.bezierCurveTo(-0.0264 * foreSize, 0.8725 * foreSize, -0.0490 * foreSize, 0.85 * foreSize, -0.0490 * foreSize, 0.825 * foreSize);\n            ctx.closePath();\n            var grad = ctx.createRadialGradient(0 * foreSize, 0.825 * foreSize, 0, 0 * foreSize, 0.825 * foreSize, 0.0490 * foreSize);\n            grad.addColorStop(0, valueColor.medium.getRgbaColor());\n            grad.addColorStop(0.3, valueColor.medium.getRgbaColor());\n            grad.addColorStop(1, valueColor.light.getRgbaColor());\n            ctx.fillStyle = grad;\n            ctx.fill();\n\n            // draw bulb highlight\n            ctx.beginPath();\n            if (vertical) {\n                ctx.moveTo(-0.0365 * foreSize, 0.8075 * foreSize);\n                ctx.bezierCurveTo(-0.0365 * foreSize, 0.7925 * foreSize, -0.0214 * foreSize, 0.7875 * foreSize, -0.0214 * foreSize, 0.7825 * foreSize);\n                ctx.bezierCurveTo(0.0189 * foreSize, 0.785 * foreSize, 0.0365 * foreSize, 0.7925 * foreSize, 0.0365 * foreSize, 0.8075 * foreSize);\n                ctx.bezierCurveTo(0.0365 * foreSize, 0.8175 * foreSize, 0.0214 * foreSize, 0.815 * foreSize, 0.0013 * foreSize, 0.8125 * foreSize);\n                ctx.bezierCurveTo(-0.0189 * foreSize, 0.8125 * foreSize, -0.0365 * foreSize, 0.8175 * foreSize, -0.0365 * foreSize, 0.8075 * foreSize);\n                grad = ctx.createRadialGradient(0, 0.8 * foreSize, 0, 0, 0.8 * foreSize, 0.0377 * foreSize);\n            } else {\n                ctx.beginPath();\n                ctx.moveTo(-0.0214 * foreSize, 0.86 * foreSize);\n                ctx.bezierCurveTo(-0.0365 * foreSize, 0.86 * foreSize, -0.0415 * foreSize, 0.845 * foreSize, -0.0465 * foreSize, 0.825 * foreSize);\n                ctx.bezierCurveTo(-0.0465 * foreSize, 0.805 * foreSize, -0.0365 * foreSize, 0.7875 * foreSize, -0.0214 * foreSize, 0.7875 * foreSize);\n                ctx.bezierCurveTo(-0.0113 * foreSize, 0.7875 * foreSize, -0.0163 * foreSize, 0.8025 * foreSize, -0.0163 * foreSize, 0.8225 * foreSize);\n                ctx.bezierCurveTo(-0.0163 * foreSize, 0.8425 * foreSize, -0.0113 * foreSize, 0.86 * foreSize, -0.0214 * foreSize, 0.86 * foreSize);\n                grad = ctx.createRadialGradient(-0.03 * foreSize, 0.8225 * foreSize, 0, -0.03 * foreSize, 0.8225 * foreSize, 0.0377 * foreSize);\n            }\n            grad.addColorStop(0.0, 'rgba(255, 255, 255, 0.55)');\n            grad.addColorStop(1.0, 'rgba(255, 255, 255, 0.05)');\n            ctx.fillStyle = grad;\n            ctx.closePath();\n            ctx.fill();\n\n            // stem highlight\n            ctx.beginPath();\n            ctx.moveTo(-0.0214 * foreSize, 0.115 * foreSize);\n            ctx.bezierCurveTo(-0.0214 * foreSize, 0.1075 * foreSize, -0.0163 * foreSize, 0.1025 * foreSize, -0.0113 * foreSize, 0.1025 * foreSize);\n            ctx.bezierCurveTo(-0.0113 * foreSize, 0.1025 * foreSize, -0.0113 * foreSize, 0.1025 * foreSize, -0.0113 * foreSize, 0.1025 * foreSize);\n            ctx.bezierCurveTo(-0.0038 * foreSize, 0.1025 * foreSize, 0.0013 * foreSize, 0.1075 * foreSize, 0.0013 * foreSize, 0.115 * foreSize);\n            ctx.bezierCurveTo(0.0013 * foreSize, 0.115 * foreSize, 0.0013 * foreSize, 0.76 * foreSize, 0.0013 * foreSize, 0.76 * foreSize);\n            ctx.bezierCurveTo(0.0013 * foreSize, 0.7675 * foreSize, -0.0038 * foreSize, 0.7725 * foreSize, -0.0113 * foreSize, 0.7725 * foreSize);\n            ctx.bezierCurveTo(-0.0113 * foreSize, 0.7725 * foreSize, -0.0113 * foreSize, 0.7725 * foreSize, -0.0113 * foreSize, 0.7725 * foreSize);\n            ctx.bezierCurveTo(-0.0163 * foreSize, 0.7725 * foreSize, -0.0214 * foreSize, 0.7675 * foreSize, -0.0214 * foreSize, 0.76 * foreSize);\n            ctx.bezierCurveTo(-0.0214 * foreSize, 0.76 * foreSize, -0.0214 * foreSize, 0.115 * foreSize, -0.0214 * foreSize, 0.115 * foreSize);\n            ctx.closePath();\n            grad = ctx.createLinearGradient(-0.0189 * foreSize, 0, 0.0013 * foreSize, 0);\n            grad.addColorStop(0.0, 'rgba(255, 255, 255, 0.1)');\n            grad.addColorStop(0.34, 'rgba(255, 255, 255, 0.5)');\n            grad.addColorStop(1.0, 'rgba(255, 255, 255, 0.1)');\n            ctx.fillStyle = grad;\n            ctx.fill();\n\n            ctx.restore();\n        };\n\n        var drawBackgroundImage = function (ctx) {\n            var backSize = (vertical ? imageHeight : imageWidth);\n            ctx.save();\n            if (vertical) {\n                ctx.translate(imageWidth / 2, 0);\n            } else {\n                ctx.translate(imageWidth / 2, imageHeight / 2);\n                ctx.rotate(HALF_PI);\n                ctx.translate(0, -imageWidth / 2 + imageWidth * 0.05);\n            }\n            ctx.beginPath();\n            ctx.moveTo(-0.0516 * backSize, 0.825 * backSize);\n            ctx.bezierCurveTo(-0.0516 * backSize, 0.8525 * backSize, -0.0289 * backSize, 0.875 * backSize, 0.0013 * backSize, 0.875 * backSize);\n            ctx.bezierCurveTo(0.0289 * backSize, 0.875 * backSize, 0.0516 * backSize, 0.8525 * backSize, 0.0516 * backSize, 0.825 * backSize);\n            ctx.bezierCurveTo(0.0516 * backSize, 0.8075 * backSize, 0.0440 * backSize, 0.7925 * backSize, 0.0314 * backSize, 0.7825 * backSize);\n            ctx.bezierCurveTo(0.0314 * backSize, 0.7825 * backSize, 0.0314 * backSize, 0.12 * backSize, 0.0314 * backSize, 0.12 * backSize);\n            ctx.bezierCurveTo(0.0314 * backSize, 0.1025 * backSize, 0.0189 * backSize, 0.0875 * backSize, 0.0013 * backSize, 0.0875 * backSize);\n            ctx.bezierCurveTo(-0.0163 * backSize, 0.0875 * backSize, -0.0289 * backSize, 0.1025 * backSize, -0.0289 * backSize, 0.12 * backSize);\n            ctx.bezierCurveTo(-0.0289 * backSize, 0.12 * backSize, -0.0289 * backSize, 0.7825 * backSize, -0.0289 * backSize, 0.7825 * backSize);\n            ctx.bezierCurveTo(-0.0415 * backSize, 0.79 * backSize, -0.0516 * backSize, 0.805 * backSize, -0.0516 * backSize, 0.825 * backSize);\n            ctx.closePath();\n            var grad = ctx.createLinearGradient(-0.0163 * backSize, 0, 0.0289 * backSize, 0);\n            grad.addColorStop(0, 'rgba(226, 226, 226, 0.5)');\n            grad.addColorStop(0.5, 'rgba(226, 226, 226, 0.2)');\n            grad.addColorStop(1, 'rgba(226, 226, 226, 0.5)');\n            ctx.fillStyle = grad;\n            ctx.fill();\n            ctx.lineWidth = 1;\n            ctx.strokeStyle = 'rgba(153, 153, 153, 0.5)';\n            ctx.stroke();\n            ctx.restore();\n        };\n\n        //************************************ Public methods **************************************\n        this.setValue = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = (newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue));\n            if (value !== targetValue) {\n                value = targetValue;\n\n                if (value > maxMeasuredValue) {\n                    maxMeasuredValue = value;\n                }\n                if (value < minMeasuredValue) {\n                    minMeasuredValue = value;\n                }\n\n                if ((value >= threshold && !ledBlinking && thresholdRising) ||\n                    (value <= threshold && !ledBlinking && !thresholdRising)) {\n                    ledBlinking = true;\n                    blink(ledBlinking);\n                    if (playAlarm) {\n                        audioElement.play();\n                    }\n                } else if ((value < threshold && ledBlinking && thresholdRising) ||\n                           (value > threshold && ledBlinking && !thresholdRising)) {\n                    ledBlinking = false;\n                    blink(ledBlinking);\n                    if (playAlarm) {\n                        audioElement.pause();\n                    }\n                }\n\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getValue = function () {\n            return value;\n        };\n\n        this.setValueAnimated = function (newValue, callback) {\n            var targetValue,\n                gauge = this,\n                time;\n            newValue = parseFloat(newValue);\n            targetValue = (newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue));\n            if (value !== targetValue) {\n                if (undefined !== tween && tween.isPlaying) {\n                    tween.stop();\n                }\n\n                time = fullScaleDeflectionTime * Math.abs(targetValue - value) / (maxValue - minValue);\n                time = Math.max(time, fullScaleDeflectionTime / 5);\n                tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, time);\n                //tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, 1);\n\n                tween.onMotionChanged = function (event) {\n                    value = event.target._pos;\n                    if (value > maxMeasuredValue) {\n                        maxMeasuredValue = value;\n                    }\n                    if (value < minMeasuredValue) {\n                        minMeasuredValue = value;\n                    }\n\n                    if ((value >= threshold && !ledBlinking && thresholdRising) ||\n                        (value <= threshold && !ledBlinking && !thresholdRising)) {\n                        ledBlinking = true;\n                        blink(ledBlinking);\n                        if (playAlarm) {\n                            audioElement.play();\n                        }\n                    } else if ((value < threshold && ledBlinking && thresholdRising) ||\n                               (value > threshold && ledBlinking && !thresholdRising)) {\n                        ledBlinking = false;\n                        blink(ledBlinking);\n                        if (playAlarm) {\n                            audioElement.pause();\n                        }\n                    }\n                    if (!repainting) {\n                        repainting = true;\n                        requestAnimFrame(gauge.repaint);\n                    }\n                };\n\n                // do we have a callback function to process?\n                if (callback && typeof(callback) === \"function\") {\n                    tween.onMotionFinished = callback;\n                }\n\n                tween.start();\n            }\n            return this;\n        };\n\n        this.resetMinMeasuredValue = function () {\n            minMeasuredValue = value;\n            this.repaint();\n            return this;\n        };\n\n        this.resetMaxMeasuredValue = function () {\n            maxMeasuredValue = value;\n            this.repaint();\n            return this;\n        };\n\n        this.setMinMeasuredValueVisible = function (visible) {\n            minMeasuredValueVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setMaxMeasuredValueVisible = function (visible) {\n            maxMeasuredValueVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setThreshold = function (threshVal) {\n            threshVal = parseFloat(threshVal);\n            var targetValue = (threshVal < minValue ? minValue : (threshVal > maxValue ? maxValue : threshVal));\n            threshold = targetValue;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setThresholdVisible = function (visible) {\n            thresholdVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setThresholdRising = function (rising) {\n            thresholdRising = !!rising;\n            // reset existing threshold alerts\n            ledBlinking = !ledBlinking;\n            blink(ledBlinking);\n            this.repaint();\n            return this;\n        };\n\n        this.setLcdDecimals = function (decimals) {\n            lcdDecimals = parseInt(decimals, 10);\n            this.repaint();\n            return this;\n        };\n\n        this.setFrameDesign = function (newFrameDesign) {\n            resetBuffers({frame: true});\n            frameDesign = newFrameDesign;\n            init({frame: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setBackgroundColor = function (newBackgroundColor) {\n            resetBuffers({background: true});\n            backgroundColor = newBackgroundColor;\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setValueColor = function (newValueColor) {\n            resetBuffers({foreground: true});\n            valueColor = newValueColor;\n            init({foreground: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLedColor = function (newLedColor) {\n            resetBuffers({led: true});\n            ledColor = newLedColor;\n            init({led: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLedVisible = function (visible) {\n            ledVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setLcdColor = function (newLcdColor) {\n            resetBuffers({background: true});\n            lcdColor = newLcdColor;\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setMaxMeasuredValue = function (newVal) {\n            newVal = parseFloat(newVal);\n            var targetValue = (newVal < minValue ? minValue : (newVal > maxValue ? maxValue : newVal));\n            maxMeasuredValue = targetValue;\n            this.repaint();\n            return this;\n        };\n\n        this.setMinMeasuredValue = function (newVal) {\n            newVal = parseFloat(newVal);\n            var targetValue = (newVal < minValue ? minValue : (newVal > maxValue ? maxValue : newVal));\n            minMeasuredValue = targetValue;\n            this.repaint();\n            return this;\n        };\n\n        this.setTitleString = function (title) {\n            titleString = title;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setUnitString = function (unit) {\n            unitString = unit;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setMinValue = function (newVal) {\n            resetBuffers({background: true});\n            minValue = parseFloat(newVal);\n            if (minMeasuredValue < minValue) {\n                minMeasuredValue = minValue;\n            }\n            if (value < minValue) {\n                value = minValue;\n            }\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.getMinValue = function () {\n            return minValue;\n        };\n\n        this.setMaxValue = function (newVal) {\n            resetBuffers({background: true});\n            maxValue = parseFloat(newVal);\n            if (maxMeasuredValue > maxValue) {\n                maxMeasuredValue = maxValue;\n            }\n            if (value > maxValue) {\n                value = maxValue;\n            }\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.getMaxValue = function () {\n            return maxValue;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init({frame: true,\n                      background: true,\n                      led: true,\n                      foreground: true});\n            }\n\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n\n            // Draw frame\n            if (frameVisible) {\n                mainCtx.drawImage(frameBuffer, 0, 0);\n            }\n\n            // Draw buffered image to visible canvas\n            mainCtx.drawImage(backgroundBuffer, 0, 0);\n\n            // Draw lcd display\n            if (lcdVisible) {\n                drawLcdText(mainCtx, value, vertical);\n            }\n\n            // Draw led\n            if (ledVisible) {\n                mainCtx.drawImage(ledBuffer, ledPosX, ledPosY);\n            }\n\n            var valuePos;\n            var yOffset;\n            var yRange;\n            var minMaxX, minMaxY;\n            // Draw min measured value indicator\n            if (minMeasuredValueVisible) {\n                if (vertical) {\n                    yOffset = (gaugeType.type === 'type1' ? 0.856796 : 0.7475);\n                    yRange = (yOffset - 0.128640);\n                    valuePos = imageHeight * yOffset - (imageHeight * yRange) * (minMeasuredValue - minValue) / (maxValue - minValue);\n                    minMaxX = imageWidth * 0.34 - minMeasuredValueBuffer.width;\n                    minMaxY = valuePos - minMeasuredValueBuffer.height / 2;\n                } else {\n                    yOffset = (gaugeType.type === 'type1' ? 0.871012 : 0.82);\n                    yRange = yOffset - (gaugeType.type === 'type1' ? 0.142857 : 0.19857);\n                    valuePos = (imageWidth * yRange) * (minMeasuredValue - minValue) / (maxValue - minValue);\n                    minMaxX = imageWidth * (gaugeType.type === 'type1' ? 0.142857 : 0.19857) - minMeasuredValueBuffer.height / 2 + valuePos;\n                    minMaxY = imageHeight * 0.65;\n                }\n                mainCtx.drawImage(minMeasuredValueBuffer, minMaxX, minMaxY);\n            }\n\n            // Draw max measured value indicator\n            if (maxMeasuredValueVisible) {\n                if (vertical) {\n                    valuePos = imageHeight * yOffset - (imageHeight * yRange) * (maxMeasuredValue - minValue) / (maxValue - minValue);\n                    minMaxX = imageWidth * 0.34 - maxMeasuredValueBuffer.width;\n                    minMaxY = valuePos - maxMeasuredValueBuffer.height / 2;\n                } else {\n                    yOffset = (gaugeType.type === 'type1' ? 0.871012 : 0.8);\n                    yRange = yOffset - (gaugeType.type === 'type1' ? 0.14857 : 0.19857);\n                    valuePos = (imageWidth * yRange) * (maxMeasuredValue - minValue) / (maxValue - minValue);\n                    minMaxX = imageWidth * (gaugeType.type === 'type1' ? 0.142857 : 0.19857) - maxMeasuredValueBuffer.height / 2 + valuePos;\n                    minMaxY = imageHeight * 0.65;\n                }\n                mainCtx.drawImage(maxMeasuredValueBuffer, minMaxX, minMaxY);\n            }\n\n            mainCtx.save();\n            drawValue(mainCtx, imageWidth, imageHeight);\n            mainCtx.restore();\n\n            // Draw foreground\n            if (foregroundVisible || gaugeType.type === 'type2') {\n                mainCtx.drawImage(foregroundBuffer, 0, 0);\n            }\n\n            repainting = false;\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var linearBargraph = function (canvas, parameters) {\n        parameters = parameters || {};\n        var width = (undefined === parameters.width ? 0 : parameters.width),\n            height = (undefined === parameters.height ? 0 : parameters.height),\n            minValue = (undefined === parameters.minValue ? 0 : parameters.minValue),\n            maxValue = (undefined === parameters.maxValue ? (minValue + 100) : parameters.maxValue),\n            section = (undefined === parameters.section ? null : parameters.section),\n            useSectionColors = (undefined === parameters.useSectionColors ? false : parameters.useSectionColors),\n            niceScale = (undefined === parameters.niceScale ? true : parameters.niceScale),\n            threshold = (undefined === parameters.threshold ? (maxValue - minValue) / 2 + minValue: parameters.threshold),\n            titleString = (undefined === parameters.titleString ? '' : parameters.titleString),\n            unitString = (undefined === parameters.unitString ? '' : parameters.unitString),\n            frameDesign = (undefined === parameters.frameDesign ? steelseries.FrameDesign.METAL : parameters.frameDesign),\n            frameVisible = (undefined === parameters.frameVisible ? true : parameters.frameVisible),\n            backgroundColor = (undefined === parameters.backgroundColor ? steelseries.BackgroundColor.DARK_GRAY : parameters.backgroundColor),\n            backgroundVisible = (undefined === parameters.backgroundVisible ? true : parameters.backgroundVisible),\n            valueColor = (undefined === parameters.valueColor ? steelseries.ColorDef.RED : parameters.valueColor),\n            lcdColor = (undefined === parameters.lcdColor ? steelseries.LcdColor.STANDARD : parameters.lcdColor),\n            lcdVisible = (undefined === parameters.lcdVisible ? true : parameters.lcdVisible),\n            lcdDecimals = (undefined === parameters.lcdDecimals ? 2 : parameters.lcdDecimals),\n            digitalFont = (undefined === parameters.digitalFont ? false : parameters.digitalFont),\n            ledColor = (undefined === parameters.ledColor ? steelseries.LedColor.RED_LED : parameters.ledColor),\n            ledVisible = (undefined === parameters.ledVisible ? true : parameters.ledVisible),\n            thresholdVisible = (undefined === parameters.thresholdVisible ? true : parameters.thresholdVisible),\n            thresholdRising = (undefined === parameters.thresholdRising ? true : parameters.thresholdRising),\n            minMeasuredValueVisible = (undefined === parameters.minMeasuredValueVisible ? false : parameters.minMeasuredValueVisible),\n            maxMeasuredValueVisible = (undefined === parameters.maxMeasuredValueVisible ? false : parameters.maxMeasuredValueVisible),\n            labelNumberFormat = (undefined === parameters.labelNumberFormat ? steelseries.LabelNumberFormat.STANDARD : parameters.labelNumberFormat),\n            foregroundVisible = (undefined === parameters.foregroundVisible ? true : parameters.foregroundVisible),\n            playAlarm = (undefined === parameters.playAlarm ? false : parameters.playAlarm),\n            alarmSound = (undefined === parameters.alarmSound ? false : parameters.alarmSound),\n            valueGradient = (undefined === parameters.valueGradient ? null : parameters.valueGradient),\n            useValueGradient = (undefined === parameters.useValueGradient ? false : parameters.useValueGradient),\n            fullScaleDeflectionTime = (undefined === parameters.fullScaleDeflectionTime ? 2.5 : parameters.fullScaleDeflectionTime);\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (width === 0) {\n            width = mainCtx.canvas.width;\n        }\n        if (height === 0) {\n            height = mainCtx.canvas.height;\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = width;\n        mainCtx.canvas.height = height;\n\n        var imageWidth = width;\n        var imageHeight = height;\n\n        // Create audio tag for alarm sound\n        if (playAlarm && alarmSound !== false) {\n            var audioElement = doc.createElement('audio');\n            audioElement.setAttribute('src', alarmSound);\n            audioElement.setAttribute('preload', 'auto');\n        }\n\n        var self = this;\n        var value = minValue;\n\n        // Properties\n        var minMeasuredValue = maxValue;\n        var maxMeasuredValue = minValue;\n\n        var tween;\n        var ledBlinking = false;\n        var repainting = false;\n        var isSectionsVisible = false;\n        var isGradientVisible = false;\n        var sectionPixels = [];\n        var ledTimerId = 0;\n\n        var vertical = width <= height;\n\n        // Constants\n        var ledPosX;\n        var ledPosY;\n        var ledSize = Math.round((vertical ? height : width) * 0.05);\n        var minMaxIndSize = Math.round((vertical ? width : height) * 0.05);\n        var stdFont;\n        var lcdFont;\n\n        if (vertical) {\n            ledPosX = imageWidth / 2 - ledSize / 2;\n            ledPosY = 0.053 * imageHeight;\n            stdFont = Math.floor(imageHeight / 22) + 'px ' + stdFontName;\n            lcdFont = Math.floor(imageHeight / 22) + 'px ' + lcdFontName;\n        } else {\n            ledPosX = 0.89 * imageWidth;\n            ledPosY = imageHeight / 1.95 - ledSize / 2;\n            stdFont = Math.floor(imageHeight / 10) + 'px ' + stdFontName;\n            lcdFont = Math.floor(imageHeight / 10) + 'px ' + lcdFontName;\n        }\n\n        var initialized = false;\n\n        // Tickmark specific private variables\n        var niceMinValue = minValue;\n        var niceMaxValue = maxValue;\n        var niceRange = maxValue - minValue;\n        var range = niceMaxValue - niceMinValue;\n        var minorTickSpacing = 0;\n        var majorTickSpacing = 0;\n        var maxNoOfMinorTicks = 10;\n        var maxNoOfMajorTicks = 10;\n\n        // Method to calculate nice values for min, max and range for the tickmarks\n        var calculate = function calculate() {\n            if (niceScale) {\n                niceRange = calcNiceNumber(maxValue - minValue, false);\n                majorTickSpacing = calcNiceNumber(niceRange / (maxNoOfMajorTicks - 1), true);\n                niceMinValue = Math.floor(minValue / majorTickSpacing) * majorTickSpacing;\n                niceMaxValue = Math.ceil(maxValue / majorTickSpacing) * majorTickSpacing;\n                minorTickSpacing = calcNiceNumber(majorTickSpacing / (maxNoOfMinorTicks - 1), true);\n                minValue = niceMinValue;\n                maxValue = niceMaxValue;\n                range = maxValue - minValue;\n            } else {\n                niceRange = (maxValue - minValue);\n                niceMinValue = minValue;\n                niceMaxValue = maxValue;\n                range = niceRange;\n                minorTickSpacing = 1;\n                majorTickSpacing = 10;\n            }\n        };\n\n        // **************   Buffer creation  ********************\n        // Buffer for the frame\n        var frameBuffer = createBuffer(width, height);\n        var frameContext = frameBuffer.getContext('2d');\n\n        // Buffer for the background\n        var backgroundBuffer = createBuffer(width, height);\n        var backgroundContext = backgroundBuffer.getContext('2d');\n\n        var lcdBuffer;\n\n        // Buffer for active bargraph led\n        var activeLedBuffer = doc.createElement('canvas');\n        if (vertical) {\n            activeLedBuffer.width = imageWidth * 0.121428;\n            activeLedBuffer.height = imageHeight * 0.012135;\n        } else {\n            activeLedBuffer.width = imageWidth * 0.012135;\n            activeLedBuffer.height = imageHeight * 0.121428;\n        }\n        var activeLedContext = activeLedBuffer.getContext('2d');\n\n        // Buffer for active bargraph led\n        var inActiveLedBuffer = doc.createElement('canvas');\n        if (vertical) {\n            inActiveLedBuffer.width = imageWidth * 0.121428;\n            inActiveLedBuffer.height = imageHeight * 0.012135;\n        } else {\n            inActiveLedBuffer.width = imageWidth * 0.012135;\n            inActiveLedBuffer.height = imageHeight * 0.121428;\n        }\n        var inActiveLedContext = inActiveLedBuffer.getContext('2d');\n\n        // Buffer for led on painting code\n        var ledBufferOn = createBuffer(ledSize, ledSize);\n        var ledContextOn = ledBufferOn.getContext('2d');\n\n        // Buffer for led off painting code\n        var ledBufferOff = createBuffer(ledSize, ledSize);\n        var ledContextOff = ledBufferOff.getContext('2d');\n\n        // Buffer for current led painting code\n        var ledBuffer = ledBufferOff;\n\n        // Buffer for the minMeasuredValue indicator\n        var minMeasuredValueBuffer = createBuffer(minMaxIndSize, minMaxIndSize);\n        var minMeasuredValueCtx = minMeasuredValueBuffer.getContext('2d');\n\n        // Buffer for the maxMeasuredValue indicator\n        var maxMeasuredValueBuffer = createBuffer(minMaxIndSize, minMaxIndSize);\n        var maxMeasuredValueCtx = maxMeasuredValueBuffer.getContext('2d');\n\n        // Buffer for static foreground painting code\n        var foregroundBuffer = createBuffer(width, height);\n        var foregroundContext = foregroundBuffer.getContext('2d');\n\n        // **************   Image creation  ********************\n        var drawLcdText = function (ctx, value, vertical) {\n            ctx.save();\n            ctx.textAlign = 'right';\n            ctx.textBaseline = 'middle';\n            ctx.strokeStyle = lcdColor.textColor;\n            ctx.fillStyle = lcdColor.textColor;\n\n            if (lcdColor === steelseries.LcdColor.STANDARD || lcdColor === steelseries.LcdColor.STANDARD_GREEN) {\n                ctx.shadowColor = 'gray';\n                if (vertical) {\n                    ctx.shadowOffsetX = imageWidth * 0.007;\n                    ctx.shadowOffsetY = imageWidth * 0.007;\n                    ctx.shadowBlur = imageWidth * 0.009;\n                } else {\n                    ctx.shadowOffsetX = imageHeight * 0.007;\n                    ctx.shadowOffsetY = imageHeight * 0.007;\n                    ctx.shadowBlur = imageHeight * 0.009;\n                }\n            }\n\n            var lcdTextX;\n            var lcdTextY;\n            var lcdTextWidth;\n\n            if (digitalFont) {\n                ctx.font = lcdFont;\n            } else {\n                ctx.font = stdFont;\n            }\n\n            if (vertical) {\n                lcdTextX = (imageWidth - (imageWidth * 0.571428)) / 2 + 1 + imageWidth * 0.571428 - 2;\n                lcdTextY = imageHeight * 0.88 + 1 + (imageHeight * 0.055 - 2) / 2;\n                lcdTextWidth = imageWidth * 0.7 - 2;\n            } else {\n                lcdTextX = (imageWidth * 0.695) + imageWidth * 0.18 - 2;\n                lcdTextY = (imageHeight * 0.22) + 1 + (imageHeight * 0.15 - 2) / 2;\n                lcdTextWidth = imageHeight * 0.22 - 2;\n            }\n\n            ctx.fillText(value.toFixed(lcdDecimals), lcdTextX, lcdTextY, lcdTextWidth);\n\n            ctx.restore();\n        };\n\n        var createThresholdImage = function (vertical) {\n            var thresholdBuffer = doc.createElement('canvas');\n            thresholdBuffer.height = thresholdBuffer.width = minMaxIndSize;\n            var thresholdCtx = thresholdBuffer.getContext('2d');\n\n            thresholdCtx.save();\n            var gradThreshold = thresholdCtx.createLinearGradient(0, 0.1, 0, thresholdBuffer.height * 0.9);\n            gradThreshold.addColorStop(0, '#520000');\n            gradThreshold.addColorStop(0.3, '#fc1d00');\n            gradThreshold.addColorStop(0.59, '#fc1d00');\n            gradThreshold.addColorStop(1, '#520000');\n            thresholdCtx.fillStyle = gradThreshold;\n\n            if (vertical) {\n                thresholdCtx.beginPath();\n                thresholdCtx.moveTo(0.1, thresholdBuffer.height * 0.5);\n                thresholdCtx.lineTo(thresholdBuffer.width * 0.9, 0.1);\n                thresholdCtx.lineTo(thresholdBuffer.width * 0.9, thresholdBuffer.height * 0.9);\n                thresholdCtx.closePath();\n            } else {\n                thresholdCtx.beginPath();\n                thresholdCtx.moveTo(0.1, 0.1);\n                thresholdCtx.lineTo(thresholdBuffer.width * 0.9, 0.1);\n                thresholdCtx.lineTo(thresholdBuffer.width * 0.5, thresholdBuffer.height * 0.9);\n                thresholdCtx.closePath();\n            }\n\n            thresholdCtx.fill();\n            thresholdCtx.strokeStyle = '#FFFFFF';\n            thresholdCtx.stroke();\n\n            thresholdCtx.restore();\n\n            return thresholdBuffer;\n        };\n\n        var drawTickmarksImage = function (ctx, labelNumberFormat, vertical) {\n            backgroundColor.labelColor.setAlpha(1);\n            ctx.save();\n            ctx.textBaseline = 'middle';\n            var TEXT_WIDTH = imageWidth * 0.1;\n            ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n\n            var valueCounter = minValue;\n            var majorTickCounter = maxNoOfMinorTicks - 1;\n            var tickCounter;\n            var currentPos;\n            var scaleBoundsX;\n            var scaleBoundsY;\n            var scaleBoundsW;\n            var scaleBoundsH;\n            var tickSpaceScaling = 1;\n\n            var minorTickStart;\n            var minorTickStop;\n            var mediumTickStart;\n            var mediumTickStop;\n            var majorTickStart;\n            var majorTickStop;\n            if (vertical) {\n                minorTickStart = (0.34 * imageWidth);\n                minorTickStop = (0.36 * imageWidth);\n                mediumTickStart = (0.33 * imageWidth);\n                mediumTickStop = (0.36 * imageWidth);\n                majorTickStart = (0.32 * imageWidth);\n                majorTickStop = (0.36 * imageWidth);\n                ctx.textAlign = 'right';\n                scaleBoundsX = 0;\n                scaleBoundsY = imageHeight * 0.128640;\n                scaleBoundsW = 0;\n                scaleBoundsH = (imageHeight * 0.856796 - imageHeight * 0.128640);\n                tickSpaceScaling = scaleBoundsH / (maxValue - minValue);\n            } else {\n                minorTickStart = (0.65 * imageHeight);\n                minorTickStop = (0.63 * imageHeight);\n                mediumTickStart = (0.66 * imageHeight);\n                mediumTickStop = (0.63 * imageHeight);\n                majorTickStart = (0.67 * imageHeight);\n                majorTickStop = (0.63 * imageHeight);\n                ctx.textAlign = 'center';\n                scaleBoundsX = imageWidth * 0.142857;\n                scaleBoundsY = 0;\n                scaleBoundsW = (imageWidth * 0.871012 - imageWidth * 0.142857);\n                scaleBoundsH = 0;\n                tickSpaceScaling = scaleBoundsW / (maxValue - minValue);\n            }\n\n            var labelCounter;\n            for (labelCounter = minValue, tickCounter = 0; labelCounter <= maxValue; labelCounter += minorTickSpacing, tickCounter += minorTickSpacing) {\n\n                // Calculate the bounds of the scaling\n                if (vertical) {\n                    currentPos = scaleBoundsY + scaleBoundsH - tickCounter * tickSpaceScaling;\n                } else {\n                    currentPos = scaleBoundsX + tickCounter * tickSpaceScaling;\n                }\n\n                majorTickCounter++;\n\n                // Draw tickmark every major tickmark spacing\n                if (majorTickCounter === maxNoOfMinorTicks) {\n\n                    // Draw the major tickmarks\n                    ctx.lineWidth = 1.5;\n                    drawLinearTicks(ctx, majorTickStart, majorTickStop, currentPos, vertical);\n\n                    // Draw the standard tickmark labels\n                    if (vertical) {\n                        // Vertical orientation\n                        switch (labelNumberFormat.format) {\n                        case 'fractional':\n                            ctx.fillText((valueCounter.toFixed(2)), imageWidth * 0.28, currentPos, TEXT_WIDTH);\n                            break;\n\n                        case 'scientific':\n                            ctx.fillText((valueCounter.toPrecision(2)), imageWidth * 0.28, currentPos, TEXT_WIDTH);\n                            break;\n\n                        case 'standard':\n                        /* falls through */\n                        default:\n                            ctx.fillText((valueCounter.toFixed(0)), imageWidth * 0.28, currentPos, TEXT_WIDTH);\n                            break;\n                        }\n                    } else {\n                        // Horizontal orientation\n                        switch (labelNumberFormat.format) {\n                        case 'fractional':\n                            ctx.fillText((valueCounter.toFixed(2)), currentPos, (imageHeight * 0.73), TEXT_WIDTH);\n                            break;\n\n                        case 'scientific':\n                            ctx.fillText((valueCounter.toPrecision(2)), currentPos, (imageHeight * 0.73), TEXT_WIDTH);\n                            break;\n\n                        case 'standard':\n                        /* falls through */\n                        default:\n                            ctx.fillText((valueCounter.toFixed(0)), currentPos, (imageHeight * 0.73), TEXT_WIDTH);\n                            break;\n                        }\n                    }\n\n                    valueCounter += majorTickSpacing;\n                    majorTickCounter = 0;\n                    continue;\n                }\n\n                // Draw tickmark every minor tickmark spacing\n                if (0 === maxNoOfMinorTicks % 2 && majorTickCounter === (maxNoOfMinorTicks / 2)) {\n                    ctx.lineWidth = 1;\n                    drawLinearTicks(ctx, mediumTickStart, mediumTickStop, currentPos, vertical);\n                } else {\n                    ctx.lineWidth = 0.5;\n                    drawLinearTicks(ctx, minorTickStart, minorTickStop, currentPos, vertical);\n                }\n            }\n\n            ctx.restore();\n        };\n\n        var drawLinearTicks = function (ctx, tickStart, tickStop, currentPos, vertical) {\n            if (vertical) {\n                // Vertical orientation\n                ctx.beginPath();\n                ctx.moveTo(tickStart, currentPos);\n                ctx.lineTo(tickStop, currentPos);\n                ctx.closePath();\n                ctx.stroke();\n            } else {\n                // Horizontal orientation\n                ctx.beginPath();\n                ctx.moveTo(currentPos, tickStart);\n                ctx.lineTo(currentPos, tickStop);\n                ctx.closePath();\n                ctx.stroke();\n            }\n        };\n\n        // **************   Initialization  ********************\n        var init = function (parameters) {\n            parameters = parameters || {};\n            var drawFrame = (undefined === parameters.frame ? false : parameters.frame);\n            var drawBackground = (undefined === parameters.background ? false : parameters.background);\n            var drawLed = (undefined === parameters.led ? false : parameters.led);\n            var drawForeground = (undefined === parameters.foreground ? false : parameters.foreground);\n            var drawBargraphLed = (undefined === parameters.bargraphled ? false : parameters.bargraphled);\n\n            initialized = true;\n\n            // Calculate the current min and max values and the range\n            calculate();\n\n            // Create frame in frame buffer (backgroundBuffer)\n            if (drawFrame && frameVisible) {\n                drawLinearFrameImage(frameContext, frameDesign, imageWidth, imageHeight, vertical);\n            }\n\n            // Create background in background buffer (backgroundBuffer)\n            if (drawBackground && backgroundVisible) {\n                drawLinearBackgroundImage(backgroundContext, backgroundColor, imageWidth, imageHeight, vertical);\n            }\n\n            if (drawLed) {\n                if (vertical) {\n                    // Draw LED ON in ledBuffer_ON\n                    ledContextOn.drawImage(createLedImage(ledSize, 1, ledColor), 0, 0);\n\n                    // Draw LED ON in ledBuffer_OFF\n                    ledContextOff.drawImage(createLedImage(ledSize, 0, ledColor), 0, 0);\n                } else {\n                    // Draw LED ON in ledBuffer_ON\n                    ledContextOn.drawImage(createLedImage(ledSize, 1, ledColor), 0, 0);\n\n                    // Draw LED ON in ledBuffer_OFF\n                    ledContextOff.drawImage(createLedImage(ledSize, 0, ledColor), 0, 0);\n                }\n            }\n\n            // Draw min measured value indicator in minMeasuredValueBuffer\n            if (minMeasuredValueVisible) {\n                if (vertical) {\n                    minMeasuredValueCtx.drawImage(createMeasuredValueImage(minMaxIndSize, steelseries.ColorDef.BLUE.dark.getRgbaColor(), false, vertical), 0, 0);\n                } else {\n                    minMeasuredValueCtx.drawImage(createMeasuredValueImage(minMaxIndSize, steelseries.ColorDef.BLUE.dark.getRgbaColor(), false, vertical), 0, 0);\n                }\n            }\n\n            // Draw max measured value indicator in maxMeasuredValueBuffer\n            if (maxMeasuredValueVisible) {\n                if (vertical) {\n                    maxMeasuredValueCtx.drawImage(createMeasuredValueImage(minMaxIndSize, steelseries.ColorDef.RED.medium.getRgbaColor(), false, vertical), 0, 0);\n                } else {\n                    maxMeasuredValueCtx.drawImage(createMeasuredValueImage(minMaxIndSize, steelseries.ColorDef.RED.medium.getRgbaColor(), false, vertical), 0, 0);\n                }\n            }\n\n            // Create alignment posts in background buffer (backgroundBuffer)\n            if (drawBackground && backgroundVisible) {\n                var valuePos;\n                // Create tickmarks in background buffer (backgroundBuffer)\n                drawTickmarksImage(backgroundContext, labelNumberFormat, vertical);\n\n                // Draw threshold image to background context\n                if (thresholdVisible) {\n                    backgroundContext.save();\n                    if (vertical) {\n                        // Vertical orientation\n                        valuePos = imageHeight * 0.856796 - (imageHeight * 0.728155) * (threshold - minValue) / (maxValue - minValue);\n                        backgroundContext.translate(imageWidth * 0.365, valuePos - minMaxIndSize / 2);\n                    } else {\n                        // Horizontal orientation\n                        valuePos = (imageWidth * 0.856796 - imageWidth * 0.128640) * (threshold - minValue) / (maxValue - minValue);\n                        backgroundContext.translate(imageWidth * 0.142857 - minMaxIndSize / 2 + valuePos, imageHeight * 0.58);\n                    }\n                    backgroundContext.drawImage(createThresholdImage(vertical), 0, 0);\n                    backgroundContext.restore();\n                }\n\n                // Create title in background buffer (backgroundBuffer)\n                if (vertical) {\n                    drawTitleImage(backgroundContext, imageWidth, imageHeight, titleString, unitString, backgroundColor, vertical, null, lcdVisible);\n                } else {\n                    drawTitleImage(backgroundContext, imageWidth, imageHeight, titleString, unitString, backgroundColor, vertical, null, lcdVisible);\n                }\n            }\n\n            // Create lcd background if selected in background buffer (backgroundBuffer)\n            if (drawBackground && lcdVisible) {\n                if (vertical) {\n                    lcdBuffer = createLcdBackgroundImage(imageWidth * 0.571428, imageHeight * 0.055, lcdColor);\n                    backgroundContext.drawImage(lcdBuffer, ((imageWidth - (imageWidth * 0.571428)) / 2), imageHeight * 0.88);\n                } else {\n                    lcdBuffer = createLcdBackgroundImage(imageWidth * 0.18, imageHeight * 0.15, lcdColor);\n                    backgroundContext.drawImage(lcdBuffer, imageWidth * 0.695, imageHeight * 0.22);\n                }\n            }\n\n            // Draw leds of bargraph\n            if (drawBargraphLed) {\n                drawInActiveLed(inActiveLedContext);\n                drawActiveLed(activeLedContext, valueColor);\n            }\n\n            // Convert Section values into pixels\n            isSectionsVisible = false;\n            if (null !== section && 0 < section.length) {\n                isSectionsVisible = true;\n                var sectionIndex = section.length;\n                var top, bottom, fullSize, ledWidth2;\n\n                if (vertical) {\n                    // Vertical orientation\n                    top =  imageHeight * 0.128640; // position of max value\n                    bottom = imageHeight * 0.856796; // position of min value\n                    fullSize = bottom - top;\n                    ledWidth2 = 0;\n                } else {\n                    // Horizontal orientation\n                    top = imageWidth * 0.856796; // position of max value\n                    bottom = imageWidth * 0.128640;\n                    fullSize = top - bottom;\n                    ledWidth2 = imageWidth * 0.012135 / 2;\n                }\n                sectionPixels = [];\n                do {\n                    sectionIndex--;\n                    sectionPixels.push({start: (((section[sectionIndex].start + Math.abs(minValue)) / (maxValue - minValue)) * fullSize - ledWidth2),\n                                         stop: (((section[sectionIndex].stop + Math.abs(minValue)) / (maxValue - minValue)) * fullSize - ledWidth2),\n                                        color: customColorDef(section[sectionIndex].color)});\n                } while (0 < sectionIndex);\n            }\n\n            // Use a gradient for the valueColor?\n            isGradientVisible = false;\n            if (useValueGradient && valueGradient !== null) {\n                // force section colors off!\n                isSectionsVisible = false;\n                isGradientVisible = true;\n            }\n\n            // Create foreground in foreground buffer (foregroundBuffer)\n            if (drawForeground && foregroundVisible) {\n                drawLinearForegroundImage(foregroundContext, imageWidth, imageHeight, vertical, false);\n            }\n        };\n\n        var resetBuffers = function (buffers) {\n            buffers = buffers || {};\n            var resetFrame = (undefined === buffers.frame ? false : buffers.frame);\n            var resetBackground = (undefined === buffers.background ? false : buffers.background);\n            var resetLed = (undefined === buffers.led ? false : buffers.led);\n            var resetBargraphLed = (undefined === buffers.bargraphled ? false : buffers.bargraphled);\n            var resetForeground = (undefined === buffers.foreground ? false : buffers.foreground);\n\n            if (resetFrame) {\n                frameBuffer.width = width;\n                frameBuffer.height = height;\n                frameContext = frameBuffer.getContext('2d');\n            }\n\n            if (resetBackground) {\n                backgroundBuffer.width = width;\n                backgroundBuffer.height = height;\n                backgroundContext = backgroundBuffer.getContext('2d');\n            }\n\n            if (resetBargraphLed) {\n                if (vertical) {\n                    activeLedBuffer.width = width * 0.121428;\n                    activeLedBuffer.height = height * 0.012135;\n                } else {\n                    activeLedBuffer.width = width * 0.012135;\n                    activeLedBuffer.height = height * 0.121428;\n                }\n                activeLedContext = activeLedBuffer.getContext('2d');\n\n                // Buffer for active bargraph led\n                if (vertical) {\n                    inActiveLedBuffer.width = width * 0.121428;\n                    inActiveLedBuffer.height = height * 0.012135;\n                } else {\n                    inActiveLedBuffer.width = width * 0.012135;\n                    inActiveLedBuffer.height = height * 0.121428;\n                }\n                inActiveLedContext = inActiveLedBuffer.getContext('2d');\n            }\n\n            if (resetLed) {\n                ledBufferOn.width = Math.ceil(width * 0.093457);\n                ledBufferOn.height = Math.ceil(height * 0.093457);\n                ledContextOn = ledBufferOn.getContext('2d');\n\n                ledBufferOff.width = Math.ceil(width * 0.093457);\n                ledBufferOff.height = Math.ceil(height * 0.093457);\n                ledContextOff = ledBufferOff.getContext('2d');\n\n                // Buffer for current led painting code\n                ledBuffer = ledBufferOff;\n            }\n\n            if (resetForeground) {\n                foregroundBuffer.width = width;\n                foregroundBuffer.height = height;\n                foregroundContext = foregroundBuffer.getContext('2d');\n            }\n        };\n\n        var blink = function (blinking) {\n            if (blinking) {\n                ledTimerId = setInterval(toggleAndRepaintLed, 1000);\n            } else {\n                clearInterval(ledTimerId);\n                ledBuffer = ledBufferOff;\n            }\n        };\n\n        var toggleAndRepaintLed = function () {\n            if (ledVisible) {\n                if (ledBuffer === ledBufferOn) {\n                    ledBuffer = ledBufferOff;\n                } else {\n                    ledBuffer = ledBufferOn;\n                }\n                if (!repainting) {\n                    repainting = true;\n                    requestAnimFrame(self.repaint);\n                }\n            }\n        };\n\n        var drawValue = function (ctx, imageWidth, imageHeight) {\n            var top; // position of max value\n            var bottom; // position of min value\n            var labelColor = backgroundColor.labelColor;\n            var fullSize;\n            var valueSize;\n            var valueTop;\n            var valueBackgroundStartX;\n            var valueBackgroundStartY;\n            var valueBackgroundStopX;\n            var valueBackgroundStopY;\n            var valueBorderStartX;\n            var valueBorderStartY;\n            var valueBorderStopX;\n            var valueBorderStopY;\n            var currentValue;\n            var gradRange;\n            var fraction;\n\n            // Orientation dependend definitions\n            if (vertical) {\n                // Vertical orientation\n                top =  imageHeight * 0.128640; // position of max value\n                bottom = imageHeight * 0.856796; // position of min value\n                fullSize = bottom - top;\n                valueSize = fullSize * (value - minValue) / (maxValue - minValue);\n                valueTop = top + fullSize - valueSize;\n                valueBackgroundStartX = 0;\n                valueBackgroundStartY = top;\n                valueBackgroundStopX = 0;\n                valueBackgroundStopY = top + fullSize * 1.014;\n            } else {\n                // Horizontal orientation\n                top = imageWidth * 0.856796; // position of max value\n                bottom = imageWidth * 0.128640;\n                fullSize = top - bottom;\n                valueSize = fullSize * (value - minValue) / (maxValue - minValue);\n                valueTop = bottom;\n                valueBackgroundStartX = imageWidth * 0.13;\n                valueBackgroundStartY = imageHeight * 0.435714;\n                valueBackgroundStopX = valueBackgroundStartX + fullSize * 1.035;\n                valueBackgroundStopY = valueBackgroundStartY;\n            }\n\n            var darker = (backgroundColor === steelseries.BackgroundColor.CARBON ||\n                          backgroundColor === steelseries.BackgroundColor.PUNCHED_SHEET ||\n                          backgroundColor === steelseries.BackgroundColor.STAINLESS ||\n                          backgroundColor === steelseries.BackgroundColor.BRUSHED_STAINLESS ||\n                          backgroundColor === steelseries.BackgroundColor.TURNED) ? 0.3 : 0;\n\n            var valueBackgroundTrackGradient = ctx.createLinearGradient(valueBackgroundStartX, valueBackgroundStartY, valueBackgroundStopX, valueBackgroundStopY);\n            labelColor.setAlpha(0.047058 + darker);\n            valueBackgroundTrackGradient.addColorStop(0, labelColor.getRgbaColor());\n            labelColor.setAlpha(0.145098 + darker);\n            valueBackgroundTrackGradient.addColorStop(0.48, labelColor.getRgbaColor());\n            labelColor.setAlpha(0.149019 + darker);\n            valueBackgroundTrackGradient.addColorStop(0.49, labelColor.getRgbaColor());\n            labelColor.setAlpha(0.047058 + darker);\n            valueBackgroundTrackGradient.addColorStop(1, labelColor.getRgbaColor());\n            ctx.fillStyle = valueBackgroundTrackGradient;\n\n            if (vertical) {\n                ctx.fillRect(imageWidth * 0.435714, top, imageWidth * 0.15, fullSize * 1.014);\n            } else {\n                ctx.fillRect(valueBackgroundStartX, valueBackgroundStartY, fullSize * 1.035, imageHeight * 0.152857);\n            }\n\n            if (vertical) {\n                // Vertical orientation\n                valueBorderStartX = 0;\n                valueBorderStartY = top;\n                valueBorderStopX = 0;\n                valueBorderStopY = top + fullSize * 1.014;\n            } else {\n                // Horizontal orientation                ;\n                valueBorderStartX = valueBackgroundStartX;\n                valueBorderStartY = 0;\n                valueBorderStopX = valueBackgroundStopX;\n                valueBorderStopY = 0;\n            }\n\n            var valueBorderGradient = ctx.createLinearGradient(valueBorderStartX, valueBorderStartY, valueBorderStopX, valueBorderStopY);\n            labelColor.setAlpha(0.298039 + darker);\n            valueBorderGradient.addColorStop(0, labelColor.getRgbaColor());\n            labelColor.setAlpha(0.686274 + darker);\n            valueBorderGradient.addColorStop(0.48, labelColor.getRgbaColor());\n            labelColor.setAlpha(0.698039 + darker);\n            valueBorderGradient.addColorStop(0.49, labelColor.getRgbaColor());\n            labelColor.setAlpha(0.4 + darker);\n            valueBorderGradient.addColorStop(1, labelColor.getRgbaColor());\n            ctx.fillStyle = valueBorderGradient;\n            if (vertical) {\n                ctx.fillRect(imageWidth * 0.435714, top, imageWidth * 0.007142, fullSize * 1.014);\n                ctx.fillRect(imageWidth * 0.571428, top, imageWidth * 0.007142, fullSize * 1.014);\n            } else {\n                ctx.fillRect(imageWidth * 0.13, imageHeight * 0.435714, fullSize * 1.035, imageHeight * 0.007142);\n                ctx.fillRect(imageWidth * 0.13, imageHeight * 0.571428, fullSize * 1.035, imageHeight * 0.007142);\n            }\n\n            // Prepare led specific variables\n            var ledX;\n            var ledY;\n            var ledW;\n            var ledH;\n            var ledCenterX;\n            var ledCenterY;\n            var activeLeds;\n            var inactiveLeds;\n            if (vertical) {\n                // VERTICAL\n                ledX = imageWidth * 0.45;\n                ledY = imageHeight * 0.851941;\n                ledW = imageWidth * 0.121428;\n                ledH = imageHeight * 0.012135;\n                ledCenterX = (ledX + ledW) / 2;\n                ledCenterY = (ledY + ledH) / 2;\n            } else {\n                // HORIZONTAL\n                ledX = imageWidth * 0.142857;\n                ledY = imageHeight * 0.45;\n                ledW = imageWidth * 0.012135;\n                ledH = imageHeight * 0.121428;\n                ledCenterX = (ledX + ledW) / 2;\n                ledCenterY = (ledY + ledH) / 2;\n            }\n\n            var translateX, translateY;\n            var activeLedColor;\n            var lastActiveLedColor = valueColor;\n            var i;\n            // Draw the value\n            if (vertical) {\n                // Draw the inactive leds\n                inactiveLeds = fullSize;\n                for (translateY = 0 ; translateY <= inactiveLeds ; translateY += ledH + 1) {\n                    ctx.translate(0, -translateY);\n                    ctx.drawImage(inActiveLedBuffer, ledX, ledY);\n                    ctx.translate(0, translateY);\n                }\n                // Draw the active leds in dependence on the current value\n                activeLeds = ((value - minValue) / (maxValue - minValue)) * fullSize;\n                for (translateY = 0 ; translateY <= activeLeds ; translateY += ledH + 1) {\n                    //check for LED color\n                    activeLedColor = valueColor;\n                    // Use a gradient for value colors?\n                    if (isGradientVisible) {\n                        // Convert pixel back to value\n                        currentValue = minValue + (translateY / fullSize) * (maxValue - minValue);\n                        gradRange = valueGradient.getEnd() - valueGradient.getStart();\n                        fraction = currentValue / gradRange;\n                        fraction = Math.max(Math.min(fraction, 1), 0);\n                        activeLedColor = customColorDef(valueGradient.getColorAt(fraction).getRgbaColor());\n                    } else if (isSectionsVisible) {\n                        for (i = 0; i < sectionPixels.length; i++) {\n                            if (translateY >= sectionPixels[i].start && translateY < sectionPixels[i].stop) {\n                                activeLedColor = sectionPixels[i].color;\n                                break;\n                            }\n                        }\n                    }\n                    // Has LED color changed? If so redraw the buffer\n                    if (lastActiveLedColor.medium.getHexColor() !== activeLedColor.medium.getHexColor()) {\n                        drawActiveLed(activeLedContext, activeLedColor);\n                        lastActiveLedColor = activeLedColor;\n                    }\n                    // Draw LED\n                    ctx.translate(0, -translateY);\n                    ctx.drawImage(activeLedBuffer, ledX, ledY);\n                    ctx.translate(0, translateY);\n                }\n            } else {\n                // Draw the inactive leds\n                inactiveLeds = fullSize;\n                for (translateX = -(ledW / 2) ; translateX <= inactiveLeds ; translateX += ledW + 1) {\n                    ctx.translate(translateX, 0);\n                    ctx.drawImage(inActiveLedBuffer, ledX, ledY);\n                    ctx.translate(-translateX, 0);\n                }\n                // Draw the active leds in dependence on the current value\n                activeLeds = ((value - minValue) / (maxValue - minValue)) * fullSize;\n                for (translateX = -(ledW / 2) ; translateX <= activeLeds ; translateX += ledW + 1) {\n                    //check for LED color\n                    activeLedColor = valueColor;\n                    if (isGradientVisible) {\n                        // Convert pixel back to value\n                        currentValue = minValue + (translateX / fullSize) * (maxValue - minValue);\n                        gradRange = valueGradient.getEnd() - valueGradient.getStart();\n                        fraction = currentValue / gradRange;\n                        fraction = Math.max(Math.min(fraction, 1), 0);\n                        activeLedColor = customColorDef(valueGradient.getColorAt(fraction).getRgbaColor());\n                    } else if (isSectionsVisible) {\n                        for (i = 0; i < sectionPixels.length; i++) {\n                            if (translateX >= sectionPixels[i].start && translateX < sectionPixels[i].stop) {\n                                activeLedColor = sectionPixels[i].color;\n                                break;\n                            }\n                        }\n                    }\n                    // Has LED color changed? If so redraw the buffer\n                    if (lastActiveLedColor.medium.getHexColor() !== activeLedColor.medium.getHexColor()) {\n                        drawActiveLed(activeLedContext, activeLedColor);\n                        lastActiveLedColor = activeLedColor;\n                    }\n                    ctx.translate(translateX, 0);\n                    ctx.drawImage(activeLedBuffer, ledX, ledY);\n                    ctx.translate(-translateX, 0);\n                }\n            }\n        };\n\n        var drawInActiveLed = function (ctx) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            ctx.closePath();\n            var ledCenterX = (ctx.canvas.width / 2);\n            var ledCenterY = (ctx.canvas.height / 2);\n            var ledGradient = mainCtx.createRadialGradient(ledCenterX, ledCenterY, 0, ledCenterX, ledCenterY, ctx.canvas.width / 2);\n            ledGradient.addColorStop(0, '#3c3c3c');\n            ledGradient.addColorStop(1, '#323232');\n            ctx.fillStyle = ledGradient;\n            ctx.fill();\n            ctx.restore();\n        };\n\n        var drawActiveLed = function (ctx, color) {\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            ctx.closePath();\n            var ledCenterX = (ctx.canvas.width / 2);\n            var ledCenterY = (ctx.canvas.height / 2);\n            var outerRadius;\n            if (vertical) {\n                outerRadius = ctx.canvas.width / 2;\n            } else {\n                outerRadius = ctx.canvas.height / 2;\n            }\n            var ledGradient = mainCtx.createRadialGradient(ledCenterX, ledCenterY, 0, ledCenterX, ledCenterY, outerRadius);\n            ledGradient.addColorStop(0, color.light.getRgbaColor());\n            ledGradient.addColorStop(1, color.dark.getRgbaColor());\n            ctx.fillStyle = ledGradient;\n            ctx.fill();\n            ctx.restore();\n        };\n\n        //************************************ Public methods **************************************\n        this.setValue = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = (newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue));\n            if (value !== targetValue) {\n                value = targetValue;\n\n                if (value > maxMeasuredValue) {\n                    maxMeasuredValue = value;\n                }\n                if (value < minMeasuredValue) {\n                    minMeasuredValue = value;\n                }\n\n                if ((value >= threshold && !ledBlinking && thresholdRising) ||\n                    (value <= threshold && !ledBlinking && !thresholdRising)) {\n                    ledBlinking = true;\n                    blink(ledBlinking);\n                    if (playAlarm) {\n                        audioElement.play();\n                    }\n                } else if ((value < threshold && ledBlinking && thresholdRising) ||\n                           (value > threshold && ledBlinking && !thresholdRising)) {\n                    ledBlinking = false;\n                    blink(ledBlinking);\n                    if (playAlarm) {\n                        audioElement.pause();\n                    }\n                }\n\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getValue = function () {\n            return value;\n        };\n\n        this.setValueAnimated = function (newValue, callback) {\n            var targetValue,\n                gauge = this,\n                time;\n            newValue = parseFloat(newValue);\n            targetValue = (newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue));\n\n            if (value !== targetValue) {\n                if (undefined !== tween && tween.isPlaying) {\n                    tween.stop();\n                }\n\n                time = fullScaleDeflectionTime * Math.abs(targetValue - value) / (maxValue - minValue);\n                time = Math.max(time, fullScaleDeflectionTime / 5);\n                tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, time);\n                //tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, 1);\n                //tween = new Tween(new Object(), '', Tween.strongEaseInOut, value, targetValue, 1);\n                tween.onMotionChanged = function (event) {\n                    value = event.target._pos;\n\n                    if ((value >= threshold && !ledBlinking && thresholdRising) ||\n                        (value <= threshold && !ledBlinking && !thresholdRising)) {\n                        ledBlinking = true;\n                        blink(ledBlinking);\n                        if (playAlarm) {\n                            audioElement.play();\n                        }\n                    } else if ((value < threshold && ledBlinking && thresholdRising) ||\n                               (value > threshold && ledBlinking && !thresholdRising)) {\n                        ledBlinking = false;\n                        blink(ledBlinking);\n                        if (playAlarm) {\n                            audioElement.pause();\n                        }\n                    }\n\n                    if (value > maxMeasuredValue) {\n                        maxMeasuredValue = value;\n                    }\n                    if (value < minMeasuredValue) {\n                        minMeasuredValue = value;\n                    }\n\n                    if (!repainting) {\n                        repainting = true;\n                        requestAnimFrame(gauge.repaint);\n                    }\n                };\n\n                // do we have a callback function to process?\n                if (callback && typeof(callback) === \"function\") {\n                    tween.onMotionFinished = callback;\n                }\n\n                tween.start();\n            }\n            return this;\n        };\n\n        this.resetMinMeasuredValue = function () {\n            minMeasuredValue = value;\n            this.repaint();\n            return this;\n        };\n\n        this.resetMaxMeasuredValue = function () {\n            maxMeasuredValue = value;\n            this.repaint();\n            return this;\n        };\n\n        this.setMinMeasuredValueVisible = function (visible) {\n            minMeasuredValueVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setMaxMeasuredValueVisible = function (visible) {\n            maxMeasuredValueVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setThresholdVisible = function (visible) {\n            thresholdVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setThresholdRising = function (rising) {\n            thresholdRising = !!rising;\n            // reset existing threshold alerts\n            ledBlinking = !ledBlinking;\n            blink(ledBlinking);\n            this.repaint();\n            return this;\n        };\n\n        this.setLcdDecimals = function (decimals) {\n            lcdDecimals = parseInt(decimals, 10);\n            this.repaint();\n            return this;\n        };\n\n        this.setFrameDesign = function (newFrameDesign) {\n            resetBuffers({frame: true});\n            frameDesign = newFrameDesign;\n            init({frame: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setBackgroundColor = function (newBackgroundColor) {\n            resetBuffers({background: true});\n            backgroundColor = newBackgroundColor;\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setValueColor = function (newValueColor) {\n            resetBuffers({bargraphled: true});\n            valueColor = newValueColor;\n            init({bargraphled: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLedColor = function (newLedColor) {\n            resetBuffers({led: true});\n            ledColor = newLedColor;\n            init({led: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLedVisible = function (visible) {\n            ledVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.setLcdColor = function (newLcdColor) {\n            lcdColor = newLcdColor;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setSection = function (areaSec) {\n            section = areaSec;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setSectionActive = function (value) {\n            useSectionColors = value;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setGradient = function (grad) {\n            valueGradient = grad;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setGradientActive = function (value) {\n            useValueGradient = value;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setMaxMeasuredValue = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = (newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue));\n            if (maxMeasuredValue !== targetValue) {\n                maxMeasuredValue = targetValue;\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.setMinMeasuredValue = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = (newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue));\n            if (minMeasuredValue !== targetValue) {\n                minMeasuredValue = targetValue;\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.setTitleString = function (title) {\n            titleString = title;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setUnitString = function (unit) {\n            unitString = unit;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setMinValue = function (value) {\n            minValue = parseFloat(value);\n            resetBuffers({background: true,\n                          foreground: true,\n                          pointer: true});\n            init({background: true,\n                foreground: true,\n                pointer: true});\n            this.repaint();\n            return this;\n        };\n\n        this.getMinValue = function () {\n            return minValue;\n        };\n\n        this.setMaxValue = function (value) {\n            maxValue = parseFloat(value);\n            resetBuffers({background: true,\n                          foreground: true,\n                          pointer: true});\n            init({background: true,\n                  foreground: true,\n                  pointer: true});\n            this.repaint();\n            return this;\n        };\n\n        this.getMaxValue = function () {\n            return maxValue;\n        };\n\n        this.setThreshold = function (newValue) {\n            newValue = parseFloat(newValue);\n            var targetValue = (newValue < minValue ? minValue : (newValue > maxValue ? maxValue : newValue));\n            if (threshold !== targetValue) {\n                threshold = targetValue;\n                resetBuffers({background: true});\n                init({background: true});\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.setThresholdVisible = function (visible) {\n            thresholdVisible = !!visible;\n            this.repaint();\n            return this;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init({frame: true,\n                      background: true,\n                      led: true,\n                      pointer: true,\n                      foreground: true,\n                      bargraphled: true});\n            }\n\n            //mainCtx.save();\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n\n            // Draw frame\n            if (frameVisible) {\n                mainCtx.drawImage(frameBuffer, 0, 0);\n            }\n\n            // Draw buffered image to visible canvas\n            if (backgroundVisible) {\n                mainCtx.drawImage(backgroundBuffer, 0, 0);\n            }\n\n            // Draw lcd display\n            if (lcdVisible) {\n                drawLcdText(mainCtx, value, vertical);\n            }\n\n            // Draw led\n            if (ledVisible) {\n                mainCtx.drawImage(ledBuffer, ledPosX, ledPosY);\n            }\n            var valuePos;\n            var minMaxX, minMaxY;\n           // Draw min measured value indicator\n            if (minMeasuredValueVisible) {\n                if (vertical) {\n                    valuePos = imageHeight * 0.856796 - (imageHeight * 0.728155) * (minMeasuredValue - minValue) / (maxValue - minValue);\n                    minMaxX = imageWidth * 0.34 - minMeasuredValueBuffer.width;\n                    minMaxY = valuePos - minMeasuredValueBuffer.height / 2;\n                } else {\n                    valuePos = ((imageWidth * 0.856796) - (imageWidth * 0.128640)) * (minMeasuredValue - minValue) / (maxValue - minValue);\n                    minMaxX = imageWidth * 0.142857 - minMeasuredValueBuffer.height / 2 + valuePos;\n                    minMaxY = imageHeight * 0.65;\n                }\n                mainCtx.drawImage(minMeasuredValueBuffer, minMaxX, minMaxY);\n            }\n\n            // Draw max measured value indicator\n            if (maxMeasuredValueVisible) {\n                if (vertical) {\n                    valuePos = imageHeight * 0.856796 - (imageHeight * 0.728155) * (maxMeasuredValue - minValue) / (maxValue - minValue);\n                    minMaxX = imageWidth * 0.34 - maxMeasuredValueBuffer.width;\n                    minMaxY = valuePos - maxMeasuredValueBuffer.height / 2;\n                } else {\n                    valuePos = ((imageWidth * 0.856796) - (imageWidth * 0.128640)) * (maxMeasuredValue - minValue) / (maxValue - minValue);\n                    minMaxX = imageWidth * 0.142857 - maxMeasuredValueBuffer.height / 2 + valuePos;\n                    minMaxY = imageHeight * 0.65;\n                }\n                mainCtx.drawImage(maxMeasuredValueBuffer, minMaxX, minMaxY);\n            }\n\n            mainCtx.save();\n            drawValue(mainCtx, imageWidth, imageHeight);\n            mainCtx.restore();\n\n            // Draw foreground\n            if (foregroundVisible) {\n                mainCtx.drawImage(foregroundBuffer, 0, 0);\n            }\n\n            repainting = false;\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var displaySingle = function (canvas, parameters) {\n        parameters = parameters || {};\n        var width = (undefined === parameters.width ? 0 : parameters.width),\n            height = (undefined === parameters.height ? 0 : parameters.height),\n            lcdColor = (undefined === parameters.lcdColor ? steelseries.LcdColor.STANDARD : parameters.lcdColor),\n            lcdDecimals = (undefined === parameters.lcdDecimals ? 2 : parameters.lcdDecimals),\n            unitString = (undefined === parameters.unitString ? '' : parameters.unitString),\n            unitStringVisible = (undefined === parameters.unitStringVisible ? false : parameters.unitStringVisible),\n            headerString = (undefined === parameters.headerString ? '' : parameters.headerString),\n            headerStringVisible = (undefined === parameters.headerStringVisible ? false : parameters.headerStringVisible),\n            digitalFont = (undefined === parameters.digitalFont ? false : parameters.digitalFont),\n            valuesNumeric = (undefined === parameters.valuesNumeric ? true : parameters.valuesNumeric),\n            value = (undefined === parameters.value ? 0 : parameters.value),\n            alwaysScroll = (undefined === parameters.alwaysScroll ? false : parameters.alwaysScroll),\n            autoScroll = (undefined === parameters.autoScroll ? false : parameters.autoScroll),\n            section = (undefined === parameters.section ? null : parameters.section);\n\n        var scrolling = false;\n        var scrollX = 0;\n        var scrollTimer;\n        var repainting = false;\n\n        var self = this;\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (width === 0) {\n            width = mainCtx.canvas.width;\n        }\n        if (height === 0) {\n            height = mainCtx.canvas.height;\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = width;\n        mainCtx.canvas.height = height;\n\n        var imageWidth = width;\n        var imageHeight = height;\n        var textWidth = 0;\n\n        var fontHeight = Math.floor(imageHeight / 1.5);\n        var stdFont = fontHeight + 'px ' + stdFontName;\n        var lcdFont = fontHeight + 'px ' + lcdFontName;\n\n        var initialized = false;\n\n        // **************   Buffer creation  ********************\n        // Buffer for the lcd\n        var lcdBuffer;\n        var sectionBuffer = [];\n        var sectionForegroundColor = [];\n\n        // **************   Image creation  ********************\n        var drawLcdText = function (value, color) {\n            mainCtx.save();\n            mainCtx.textAlign = 'right';\n            //mainCtx.textBaseline = 'top';\n            mainCtx.strokeStyle = color;\n            mainCtx.fillStyle = color;\n\n            mainCtx.beginPath();\n            mainCtx.rect(2, 0, imageWidth - 4, imageHeight);\n            mainCtx.closePath();\n            mainCtx.clip();\n\n            if ((lcdColor === steelseries.LcdColor.STANDARD || lcdColor === steelseries.LcdColor.STANDARD_GREEN) &&\n                 section === null) {\n                mainCtx.shadowColor = 'gray';\n                mainCtx.shadowOffsetX = imageHeight * 0.035;\n                mainCtx.shadowOffsetY = imageHeight * 0.035;\n                mainCtx.shadowBlur = imageHeight * 0.055;\n            }\n\n            mainCtx.font = digitalFont ? lcdFont : stdFont;\n\n            if (valuesNumeric) {\n                // Numeric value\n                var unitWidth = 0;\n                textWidth = 0;\n                if (unitStringVisible) {\n                    mainCtx.font = Math.floor(imageHeight / 2.5) + 'px ' + stdFontName;\n                    unitWidth = mainCtx.measureText(unitString).width;\n                }\n                mainCtx.font = digitalFont ? lcdFont : stdFont;\n                var lcdText = value.toFixed(lcdDecimals);\n                textWidth = mainCtx.measureText(lcdText).width;\n                var vPos = 0.38;\n                if (headerStringVisible) {\n                    vPos = 0.52;\n                }\n\n                mainCtx.fillText(lcdText, imageWidth - unitWidth - 4 - scrollX, imageHeight * 0.5 + fontHeight * vPos);\n\n                if (unitStringVisible) {\n                    mainCtx.font = Math.floor(imageHeight / 2.5) + 'px ' + stdFontName;\n                    mainCtx.fillText(unitString, imageWidth - 2 - scrollX, imageHeight * 0.5 + fontHeight * vPos);\n                }\n                if (headerStringVisible) {\n                    mainCtx.textAlign = 'center';\n                    mainCtx.font = Math.floor(imageHeight / 3.5) + 'px ' + stdFontName;\n                    mainCtx.fillText(headerString, imageWidth / 2, imageHeight * 0.3);\n                }\n            } else {\n                // Text value\n                textWidth = mainCtx.measureText(value).width;\n                if (alwaysScroll || (autoScroll && textWidth > imageWidth - 4)) {\n                    if (!scrolling) {\n                        if (textWidth > imageWidth * 0.8) {\n                            scrollX = imageWidth - textWidth - imageWidth * 0.2; // leave 20% blank leading space to give time to read start of message\n                        } else {\n                            scrollX = 0;\n                        }\n                        scrolling = true;\n                        clearTimeout(scrollTimer);  // kill any pending animate\n                        scrollTimer = setTimeout(animate, 200);\n                    }\n                } else if (autoScroll && textWidth <= imageWidth - 4) {\n                    scrollX = 0;\n                    scrolling = false;\n                }\n                mainCtx.fillText(value, imageWidth - 2 - scrollX, imageHeight * 0.5 + fontHeight * 0.38);\n            }\n            mainCtx.restore();\n        };\n\n        var createLcdSectionImage = function (width, height, color, lcdColor) {\n            var lcdSectionBuffer = createBuffer(width, height);\n            var lcdCtx = lcdSectionBuffer.getContext('2d');\n\n            lcdCtx.save();\n            var xB = 0;\n            var yB = 0;\n            var wB = width;\n            var hB = height;\n            var rB = Math.min(width, height) * 0.095;\n\n            var lcdBackground = lcdCtx.createLinearGradient(0, yB, 0, yB + hB);\n\n            lcdBackground.addColorStop(0, '#4c4c4c');\n            lcdBackground.addColorStop(0.08, '#666666');\n            lcdBackground.addColorStop(0.92, '#666666');\n            lcdBackground.addColorStop(1, '#e6e6e6');\n            lcdCtx.fillStyle = lcdBackground;\n\n            roundedRectangle(lcdCtx, xB, yB, wB, hB, rB);\n\n            lcdCtx.fill();\n            lcdCtx.restore();\n\n            lcdCtx.save();\n\n            var rgb = getColorValues(color);\n            var hsb = rgbToHsb(rgb[0], rgb[1], rgb[2]);\n\n            var rgbStart = getColorValues(lcdColor.gradientStartColor);\n            var hsbStart = rgbToHsb(rgbStart[0], rgbStart[1], rgbStart[2]);\n            var rgbFraction1 = getColorValues(lcdColor.gradientFraction1Color);\n            var hsbFraction1 = rgbToHsb(rgbFraction1[0], rgbFraction1[1], rgbFraction1[2]);\n            var rgbFraction2 = getColorValues(lcdColor.gradientFraction2Color);\n            var hsbFraction2 = rgbToHsb(rgbFraction2[0], rgbFraction2[1], rgbFraction2[2]);\n            var rgbFraction3 = getColorValues(lcdColor.gradientFraction3Color);\n            var hsbFraction3 = rgbToHsb(rgbFraction3[0], rgbFraction3[1], rgbFraction3[2]);\n            var rgbStop = getColorValues(lcdColor.gradientStopColor);\n            var hsbStop = rgbToHsb(rgbStop[0], rgbStop[1], rgbStop[2]);\n\n            var startColor = hsbToRgb(hsb[0], hsb[1], hsbStart[2] - 0.31);\n            var fraction1Color = hsbToRgb(hsb[0], hsb[1], hsbFraction1[2] - 0.31);\n            var fraction2Color = hsbToRgb(hsb[0], hsb[1], hsbFraction2[2] - 0.31);\n            var fraction3Color = hsbToRgb(hsb[0], hsb[1], hsbFraction3[2] - 0.31);\n            var stopColor = hsbToRgb(hsb[0], hsb[1], hsbStop[2] - 0.31);\n\n            var xF = 1;\n            var yF = 1;\n            var wF = width - 2;\n            var hF = height - 2;\n            var rF = rB - 1;\n            var lcdForeground = lcdCtx.createLinearGradient(0, yF, 0, yF + hF);\n            lcdForeground.addColorStop(0, 'rgb(' + startColor[0] + ', ' + startColor[1] + ', ' + startColor[2] + ')');\n            lcdForeground.addColorStop(0.03, 'rgb(' + fraction1Color[0] + ',' + fraction1Color[1] + ',' + fraction1Color[2] + ')');\n            lcdForeground.addColorStop(0.49, 'rgb(' + fraction2Color[0] + ',' + fraction2Color[1] + ',' + fraction2Color[2] + ')');\n            lcdForeground.addColorStop(0.5, 'rgb(' + fraction3Color[0] + ',' + fraction3Color[1] + ',' + fraction3Color[2] + ')');\n            lcdForeground.addColorStop(1, 'rgb(' + stopColor[0] + ',' + stopColor[1] + ',' + stopColor[2] + ')');\n            lcdCtx.fillStyle = lcdForeground;\n\n            roundedRectangle(lcdCtx, xF, yF, wF, hF, rF);\n\n            lcdCtx.fill();\n            lcdCtx.restore();\n\n            return lcdSectionBuffer;\n        };\n\n        var createSectionForegroundColor = function (sectionColor) {\n            var rgbSection = getColorValues(sectionColor);\n            var hsbSection = rgbToHsb(rgbSection[0], rgbSection[1], rgbSection[2]);\n            var sectionForegroundRgb = hsbToRgb(hsbSection[0], 0.57, 0.83);\n            return 'rgb(' + sectionForegroundRgb[0] + ', ' + sectionForegroundRgb[1] + ', ' + sectionForegroundRgb[2] + ')';\n        };\n\n        var animate = function () {\n            if (scrolling) {\n                if (scrollX > imageWidth) {\n                    scrollX = -textWidth;\n                }\n                scrollX += 2;\n                scrollTimer = setTimeout(animate, 50);\n            } else {\n                scrollX = 0;\n            }\n            if (!repainting) {\n                repainting = true;\n                requestAnimFrame(self.repaint);\n            }\n        };\n\n        // **************   Initialization  ********************\n        var init = function () {\n            var sectionIndex;\n            initialized = true;\n\n            // Create lcd background if selected in background buffer (backgroundBuffer)\n            lcdBuffer = createLcdBackgroundImage(width, height, lcdColor);\n\n            if (null !== section && 0 < section.length) {\n                for (sectionIndex = 0 ; sectionIndex < section.length ; sectionIndex++) {\n                    sectionBuffer[sectionIndex] = createLcdSectionImage(width, height, section[sectionIndex].color, lcdColor);\n                    sectionForegroundColor[sectionIndex] = createSectionForegroundColor(section[sectionIndex].color);\n                }\n            }\n\n        };\n\n        // **************   Public methods  ********************\n        this.setValue = function (newValue) {\n            if (value !== newValue) {\n                value = newValue;\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.setLcdColor = function (newLcdColor) {\n            lcdColor = newLcdColor;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setSection = function (newSection) {\n            section = newSection;\n            init({background: true, foreground: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setScrolling = function (scroll) {\n            if (scroll) {\n                if (scrolling) {\n                    return;\n                } else {\n                    scrolling = scroll;\n                    animate();\n                }\n            } else { //disable scrolling\n                scrolling = scroll;\n            }\n            return this;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init();\n            }\n\n            //mainCtx.save();\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n\n            var lcdBackgroundBuffer = lcdBuffer;\n            var lcdTextColor = lcdColor.textColor;\n            var sectionIndex;\n            // Draw sections\n            if (null !== section && 0 < section.length) {\n                for (sectionIndex = 0 ; sectionIndex < section.length ; sectionIndex++) {\n                    if (value >= section[sectionIndex].start && value <= section[sectionIndex].stop) {\n                        lcdBackgroundBuffer = sectionBuffer[sectionIndex];\n                        lcdTextColor = sectionForegroundColor[sectionIndex];\n                        break;\n                    }\n                }\n            }\n\n            // Draw lcd background\n            mainCtx.drawImage(lcdBackgroundBuffer, 0, 0);\n\n            // Draw lcd text\n            drawLcdText(value, lcdTextColor);\n\n            repainting = false;\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var displayMulti = function (canvas, parameters) {\n        parameters = parameters || {};\n        var width = (undefined === parameters.width ? 0 : parameters.width),\n            height = (undefined === parameters.height ? 0 : parameters.height),\n            lcdColor = (undefined === parameters.lcdColor ? steelseries.LcdColor.STANDARD : parameters.lcdColor),\n            lcdDecimals = (undefined === parameters.lcdDecimals ? 2 : parameters.lcdDecimals),\n            headerString = (undefined === parameters.headerString ? '' : parameters.headerString),\n            headerStringVisible = (undefined === parameters.headerStringVisible ? false : parameters.headerStringVisible),\n            detailString = (undefined === parameters.detailString ? '' : parameters.detailString),\n            detailStringVisible = (undefined === parameters.detailStringVisible ? false : parameters.detailStringVisible),\n            linkAltValue = (undefined === parameters.linkAltValue ? true : parameters.linkAltValue),\n            unitString = (undefined === parameters.unitString ? '' : parameters.unitString),\n            unitStringVisible = (undefined === parameters.unitStringVisible ? false : parameters.unitStringVisible),\n            digitalFont = (undefined === parameters.digitalFont ? false : parameters.digitalFont),\n            valuesNumeric = (undefined === parameters.valuesNumeric ? true : parameters.valuesNumeric),\n            value = (undefined === parameters.value ? 0 : parameters.value),\n            altValue = (undefined === parameters.altValue ? 0 : parameters.altValue);\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (width === 0) {\n            width = mainCtx.canvas.width;\n        }\n        if (height === 0) {\n            height = mainCtx.canvas.height;\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = width;\n        mainCtx.canvas.height = height;\n\n        var imageWidth = width;\n        var imageHeight = height;\n\n        var stdFont = Math.floor(imageHeight / 1.875) + 'px ' + stdFontName;\n        var lcdFont = Math.floor(imageHeight / 1.875) + 'px ' + lcdFontName;\n        var stdAltFont = Math.floor(imageHeight / 3.5) + 'px ' + stdFontName;\n        var lcdAltFont = Math.floor(imageHeight / 3.5) + 'px ' + lcdFontName;\n\n        var initialized = false;\n\n        // **************   Buffer creation  ********************\n        // Buffer for the lcd\n        var lcdBuffer;\n\n        // **************   Image creation  ********************\n        var drawLcdText = function (value) {\n            mainCtx.save();\n            mainCtx.textAlign = 'right';\n            mainCtx.textBaseline = 'middle';\n            mainCtx.strokeStyle = lcdColor.textColor;\n            mainCtx.fillStyle = lcdColor.textColor;\n\n            if (lcdColor === steelseries.LcdColor.STANDARD || lcdColor === steelseries.LcdColor.STANDARD_GREEN) {\n                mainCtx.shadowColor = 'gray';\n                mainCtx.shadowOffsetX = imageHeight * 0.025;\n                mainCtx.shadowOffsetY = imageHeight * 0.025;\n                mainCtx.shadowBlur = imageHeight * 0.05;\n            }\n\n            if (valuesNumeric) {\n                // Numeric value\n                if (headerStringVisible) {\n                    mainCtx.font = Math.floor(imageHeight / 3) + 'px ' + stdFontName;\n                } else {\n                    mainCtx.font = Math.floor(imageHeight / 2.5) + 'px ' + stdFontName;\n                }\n                var unitWidth = 0;\n                if (unitStringVisible) {\n                    if (headerStringVisible) {\n                        mainCtx.font = Math.floor(imageHeight / 3) + 'px ' + stdFontName;\n                        unitWidth = mainCtx.measureText(unitString).width;\n                    } else {\n                        mainCtx.font = Math.floor(imageHeight / 2.5) + 'px ' + stdFontName;\n                        unitWidth = mainCtx.measureText(unitString).width;\n                    }\n                }\n                mainCtx.font = digitalFont ? lcdFont : stdFont;\n                var valueText = value.toFixed(lcdDecimals);\n                if (headerStringVisible) {\n                    mainCtx.fillText(valueText, imageWidth - unitWidth - 4, imageHeight * 0.5);\n                } else {\n                    mainCtx.fillText(valueText, imageWidth - unitWidth - 4, imageHeight * 0.38);\n                }\n\n                if (unitStringVisible) {\n                    mainCtx.font = Math.floor(imageHeight / 3) + 'px ' + stdFontName;\n                    mainCtx.fillText(unitString, imageWidth - 2, imageHeight * 0.55);\n                }\n\n                var altValueText = altValue.toFixed(lcdDecimals);\n                if (detailStringVisible) {\n                    altValueText = detailString + altValueText;\n                }\n                if (digitalFont) {\n                    mainCtx.font = lcdAltFont;\n                } else {\n                    if (headerStringVisible) {\n                        mainCtx.font = Math.floor(imageHeight / 5) + 'px ' + stdFontName;\n                    } else {\n                        mainCtx.font = stdAltFont;\n                    }\n                }\n                mainCtx.textAlign = 'center';\n                if (headerStringVisible) {\n                    mainCtx.fillText(altValueText, imageWidth / 2, imageHeight * 0.83);\n                    mainCtx.fillText(headerString, imageWidth / 2, imageHeight * 0.16);\n                } else {\n                    mainCtx.fillText(altValueText, imageWidth / 2, imageHeight * 0.8);\n                }\n            } else {\n                if (headerStringVisible) {\n                    // Text value\n                    mainCtx.font = Math.floor(imageHeight / 3.5) + 'px ' + stdFontName;\n                    mainCtx.fillText(value, imageWidth - 2, imageHeight * 0.48);\n\n                    //mainCtx.font = stdAltFont;\n                    mainCtx.font = Math.floor(imageHeight / 5) + 'px ' + stdFontName;\n                    mainCtx.textAlign = 'center';\n                    mainCtx.fillText(altValue, imageWidth / 2, imageHeight * 0.83);\n                    mainCtx.fillText(headerString, imageWidth / 2, imageHeight * 0.17);\n                } else {\n                    // Text value\n                    mainCtx.font = Math.floor(imageHeight / 2.5) + 'px ' + stdFontName;\n                    mainCtx.fillText(value, imageWidth - 2, imageHeight * 0.38);\n\n                    mainCtx.font = stdAltFont;\n                    mainCtx.textAlign = 'center';\n                    mainCtx.fillText(altValue, imageWidth / 2, imageHeight * 0.8);\n                }\n            }\n            mainCtx.restore();\n        };\n\n        // **************   Initialization  ********************\n        var init = function () {\n            initialized = true;\n\n            // Create lcd background if selected in background buffer (backgroundBuffer)\n            lcdBuffer = createLcdBackgroundImage(width, height, lcdColor);\n        };\n\n        // **************   Public methods  ********************\n        this.setValue = function (newValue) {\n            if (value !== newValue || altValue !== newValue) {\n                if (linkAltValue) {\n                    altValue = value;\n                }\n                value = newValue;\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.setAltValue = function (altValue) {\n            if (altValue !== altValue) {\n                altValue = altValue;\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.setLcdColor = function (newLcdColor) {\n            lcdColor = newLcdColor;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init();\n            }\n\n            //mainCtx.save();\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n\n            // Draw lcd background\n            mainCtx.drawImage(lcdBuffer, 0, 0);\n\n            // Draw lcd text\n            drawLcdText(value);\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var level = function (canvas, parameters) {\n        parameters = parameters || {};\n        var size = (undefined === parameters.size ? 0 : parameters.size),\n            decimalsVisible = (undefined === parameters.decimalsVisible ? false : parameters.decimalsVisible),\n            textOrientationFixed = (undefined === parameters.textOrientationFixed ? false : parameters.textOrientationFixed),\n            frameDesign = (undefined === parameters.frameDesign ? steelseries.FrameDesign.METAL : parameters.frameDesign),\n            frameVisible = (undefined === parameters.frameVisible ? true : parameters.frameVisible),\n            backgroundColor = (undefined === parameters.backgroundColor ? steelseries.BackgroundColor.DARK_GRAY : parameters.backgroundColor),\n            backgroundVisible = (undefined === parameters.backgroundVisible ? true : parameters.backgroundVisible),\n            pointerColor = (undefined === parameters.pointerColor ? steelseries.ColorDef.RED : parameters.pointerColor),\n            foregroundType = (undefined === parameters.foregroundType ? steelseries.ForegroundType.TYPE1 : parameters.foregroundType),\n            foregroundVisible = (undefined === parameters.foregroundVisible ? true : parameters.foregroundVisible),\n            rotateFace = (undefined === parameters.rotateFace ? false : parameters.rotateFace);\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (size === 0) {\n            size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height);\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = size;\n        mainCtx.canvas.height = size;\n\n        var tween;\n        var repainting = false;\n\n        var value = 0;\n        var stepValue = 0;\n        var visibleValue = 0;\n        var angleStep = TWO_PI / 360;\n        var angle = this.value;\n        var decimals = decimalsVisible ? 1 : 0;\n\n        var imageWidth = size;\n        var imageHeight = size;\n\n        var centerX = imageWidth / 2;\n        var centerY = imageHeight / 2;\n\n        var initialized = false;\n\n        // **************   Buffer creation  ********************\n        // Buffer for all static background painting code\n        var backgroundBuffer = createBuffer(size, size);\n        var backgroundContext = backgroundBuffer.getContext('2d');\n\n        // Buffer for pointer image painting code\n        var pointerBuffer = createBuffer(size, size);\n        var pointerContext = pointerBuffer.getContext('2d');\n\n        // Buffer for step pointer image painting code\n        var stepPointerBuffer = createBuffer(size, size);\n        var stepPointerContext = stepPointerBuffer.getContext('2d');\n\n        // Buffer for static foreground painting code\n        var foregroundBuffer = createBuffer(size, size);\n        var foregroundContext = foregroundBuffer.getContext('2d');\n\n        // **************   Image creation  ********************\n        var drawTickmarksImage = function (ctx) {\n            var stdFont, smlFont, i;\n\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.save();\n            ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.translate(centerX, centerY);\n\n            for (i = 0; 360 > i; i++) {\n                ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n                ctx.lineWidth = 0.5;\n                ctx.beginPath();\n                ctx.moveTo(imageWidth * 0.38, 0);\n                ctx.lineTo(imageWidth * 0.37, 0);\n                ctx.closePath();\n                ctx.stroke();\n\n                if (0 === i % 5) {\n                    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n                    ctx.lineWidth = 1;\n                    ctx.beginPath();\n                    ctx.moveTo(imageWidth * 0.38, 0);\n                    ctx.lineTo(imageWidth * 0.36, 0);\n                    ctx.closePath();\n                    ctx.stroke();\n                }\n\n                if (0 === i % 45) {\n                    ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n                    ctx.lineWidth = 1;\n                    ctx.beginPath();\n                    ctx.moveTo(imageWidth * 0.38, 0);\n                    ctx.lineTo(imageWidth * 0.34, 0);\n                    ctx.closePath();\n                    ctx.stroke();\n                }\n\n                // Draw the labels\n                if (300 < imageWidth) {\n                    stdFont = '14px ' + stdFont;\n                    smlFont = '12px '  + stdFont;\n                }\n                if (300 >= imageWidth) {\n                    stdFont = '12px '  + stdFont;\n                    smlFont = '10px '  + stdFont;\n                }\n                if (200 >= imageWidth) {\n                    stdFont = '10px '  + stdFont;\n                    smlFont = '8px '  + stdFont;\n                }\n                if (100 >= imageWidth) {\n                    stdFont = '8px '  + stdFont;\n                    smlFont = '6px '  + stdFont;\n                }\n                ctx.save();\n                switch (i) {\n                case 0:\n                    ctx.translate(imageWidth * 0.31, 0);\n                    ctx.rotate((i * RAD_FACTOR) + HALF_PI);\n                    ctx.font = stdFont;\n                    ctx.fillText('0\\u00B0', 0, 0, imageWidth);\n                    ctx.rotate(-(i * RAD_FACTOR) + HALF_PI);\n                    ctx.translate(-imageWidth * 0.31, 0);\n\n                    ctx.translate(imageWidth * 0.41, 0);\n                    ctx.rotate((i * RAD_FACTOR) - HALF_PI);\n                    ctx.font = smlFont;\n                    ctx.fillText('0%', 0, 0, imageWidth);\n                    break;\n                case 45:\n                    ctx.translate(imageWidth * 0.31, 0);\n                    ctx.rotate((i * RAD_FACTOR) + 0.25 * PI);\n                    ctx.font = stdFont;\n                    ctx.fillText('45\\u00B0', 0, 0, imageWidth);\n                    ctx.rotate(-(i * RAD_FACTOR) + 0.25 * PI);\n                    ctx.translate(-imageWidth * 0.31, 0);\n\n                    ctx.translate(imageWidth * 0.31, imageWidth * 0.085);\n                    ctx.rotate((i * RAD_FACTOR) - 0.25 * PI);\n                    ctx.font = smlFont;\n                    ctx.fillText('100%', 0, 0, imageWidth);\n                    break;\n                case 90:\n                    ctx.translate(imageWidth * 0.31, 0);\n                    ctx.rotate((i * RAD_FACTOR));\n                    ctx.font = stdFont;\n                    ctx.fillText('90\\u00B0', 0, 0, imageWidth);\n                    ctx.rotate(-(i * RAD_FACTOR));\n                    ctx.translate(-imageWidth * 0.31, 0);\n\n                    ctx.translate(imageWidth * 0.21, 0);\n                    ctx.rotate((i * RAD_FACTOR));\n                    ctx.font = smlFont;\n                    ctx.fillText('\\u221E', 0, 0, imageWidth);\n                    break;\n                case 135:\n                    ctx.translate(imageWidth * 0.31, 0);\n                    ctx.rotate((i * RAD_FACTOR) - 0.25 * PI);\n                    ctx.font = stdFont;\n                    ctx.fillText('45\\u00B0', 0, 0, imageWidth);\n                    ctx.rotate(-(i * RAD_FACTOR) - 0.25 * PI);\n                    ctx.translate(-imageWidth * 0.31, 0);\n\n                    ctx.translate(imageWidth * 0.31, -imageWidth * 0.085);\n                    ctx.rotate((i * RAD_FACTOR) + 0.25 * PI);\n                    ctx.font = smlFont;\n                    ctx.fillText('100%', 0, 0, imageWidth);\n                    break;\n                case 180:\n                    ctx.translate(imageWidth * 0.31, 0);\n                    ctx.rotate((i * RAD_FACTOR) - HALF_PI);\n                    ctx.font = stdFont;\n                    ctx.fillText('0\\u00B0', 0, 0, imageWidth);\n                    ctx.rotate(-(i * RAD_FACTOR) - HALF_PI);\n                    ctx.translate(-imageWidth * 0.31, 0);\n\n                    ctx.translate(imageWidth * 0.41, 0);\n                    ctx.rotate((i * RAD_FACTOR) + HALF_PI);\n                    ctx.font = smlFont;\n                    ctx.fillText('0%', 0, 0, imageWidth);\n                    ctx.translate(-imageWidth * 0.41, 0);\n                    break;\n                case 225:\n                    ctx.translate(imageWidth * 0.31, 0);\n                    ctx.rotate((i * RAD_FACTOR) - 0.75 * PI);\n                    ctx.font = stdFont;\n                    ctx.fillText('45\\u00B0', 0, 0, imageWidth);\n                    ctx.rotate(-(i * RAD_FACTOR) - 0.75 * PI);\n                    ctx.translate(-imageWidth * 0.31, 0);\n\n                    ctx.translate(imageWidth * 0.31, imageWidth * 0.085);\n                    ctx.rotate((i * RAD_FACTOR) + 0.75 * PI);\n                    ctx.font = smlFont;\n                    ctx.fillText('100%', 0, 0, imageWidth);\n                    break;\n                case 270:\n                    ctx.translate(imageWidth * 0.31, 0);\n                    ctx.rotate((i * RAD_FACTOR) - PI);\n                    ctx.font = stdFont;\n                    ctx.fillText('90\\u00B0', 0, 0, imageWidth);\n                    ctx.rotate(-(i * RAD_FACTOR) - PI);\n                    ctx.translate(-imageWidth * 0.31, 0);\n\n                    ctx.translate(imageWidth * 0.21, 0);\n                    ctx.rotate((i * RAD_FACTOR) - PI);\n                    ctx.font = smlFont;\n                    ctx.fillText('\\u221E', 0, 0, imageWidth);\n                    break;\n                case 315:\n                    ctx.translate(imageWidth * 0.31, 0);\n                    ctx.rotate((i * RAD_FACTOR) - 1.25 * PI);\n                    ctx.font = stdFont;\n                    ctx.fillText('45\\u00B0', 0, 0, imageWidth);\n                    ctx.rotate(-(i * RAD_FACTOR) - 1.25 * PI);\n                    ctx.translate(-imageWidth * 0.31, 0);\n\n                    ctx.translate(imageWidth * 0.31, -imageWidth * 0.085);\n                    ctx.rotate((i * RAD_FACTOR) + 1.25 * PI);\n                    ctx.font = smlFont;\n                    ctx.fillText('100%', 0, 0, imageWidth);\n                    break;\n                }\n                ctx.restore();\n\n                ctx.rotate(angleStep);\n            }\n            ctx.translate(-centerX, -centerY);\n            ctx.restore();\n        };\n\n        var drawMarkerImage = function (ctx) {\n            ctx.save();\n\n            ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n\n            // FRAMELEFT\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.200934, imageHeight * 0.434579);\n            ctx.lineTo(imageWidth * 0.163551, imageHeight * 0.434579);\n            ctx.lineTo(imageWidth * 0.163551, imageHeight * 0.560747);\n            ctx.lineTo(imageWidth * 0.200934, imageHeight * 0.560747);\n            ctx.lineWidth = 1;\n            ctx.lineCap = 'square';\n            ctx.lineJoin = 'miter';\n            ctx.stroke();\n\n            // TRIANGLELEFT\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.163551, imageHeight * 0.471962);\n            ctx.lineTo(imageWidth * 0.205607, imageHeight * 0.5);\n            ctx.lineTo(imageWidth * 0.163551, imageHeight * 0.523364);\n            ctx.lineTo(imageWidth * 0.163551, imageHeight * 0.471962);\n            ctx.closePath();\n            ctx.fill();\n\n            // FRAMERIGHT\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.799065, imageHeight * 0.434579);\n            ctx.lineTo(imageWidth * 0.836448, imageHeight * 0.434579);\n            ctx.lineTo(imageWidth * 0.836448, imageHeight * 0.560747);\n            ctx.lineTo(imageWidth * 0.799065, imageHeight * 0.560747);\n            ctx.lineWidth = 1;\n            ctx.lineCap = 'square';\n            ctx.lineJoin = 'miter';\n            ctx.stroke();\n\n            // TRIANGLERIGHT\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.836448, imageHeight * 0.471962);\n            ctx.lineTo(imageWidth * 0.794392, imageHeight * 0.5);\n            ctx.lineTo(imageWidth * 0.836448, imageHeight * 0.523364);\n            ctx.lineTo(imageWidth * 0.836448, imageHeight * 0.471962);\n            ctx.closePath();\n            ctx.fill();\n\n            ctx.restore();\n        };\n\n        var drawPointerImage = function (ctx) {\n            ctx.save();\n\n            // POINTER_LEVEL\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.523364, imageHeight * 0.350467);\n            ctx.lineTo(imageWidth * 0.5, imageHeight * 0.130841);\n            ctx.lineTo(imageWidth * 0.476635, imageHeight * 0.350467);\n            ctx.bezierCurveTo(imageWidth * 0.476635, imageHeight * 0.350467, imageWidth * 0.490654, imageHeight * 0.345794, imageWidth * 0.5, imageHeight * 0.345794);\n            ctx.bezierCurveTo(imageWidth * 0.509345, imageHeight * 0.345794, imageWidth * 0.523364, imageHeight * 0.350467, imageWidth * 0.523364, imageHeight * 0.350467);\n            ctx.closePath();\n            var POINTER_LEVEL_GRADIENT = ctx.createLinearGradient(0, 0.154205 * imageHeight, 0, 0.350466 * imageHeight);\n            var tmpDarkColor = pointerColor.dark;\n            var tmpLightColor = pointerColor.light;\n            tmpDarkColor.setAlpha(0.70588);\n            tmpLightColor.setAlpha(0.70588);\n            POINTER_LEVEL_GRADIENT.addColorStop(0, tmpDarkColor.getRgbaColor());\n            POINTER_LEVEL_GRADIENT.addColorStop(0.3, tmpLightColor.getRgbaColor());\n            POINTER_LEVEL_GRADIENT.addColorStop(0.59, tmpLightColor.getRgbaColor());\n            POINTER_LEVEL_GRADIENT.addColorStop(1, tmpDarkColor.getRgbaColor());\n            ctx.fillStyle = POINTER_LEVEL_GRADIENT;\n            var strokeColor_POINTER_LEVEL = pointerColor.light.getRgbaColor();\n            ctx.lineWidth = 1;\n            ctx.lineCap = 'square';\n            ctx.lineJoin = 'miter';\n            ctx.strokeStyle = strokeColor_POINTER_LEVEL;\n            ctx.fill();\n            ctx.stroke();\n\n            tmpDarkColor.setAlpha(1);\n            tmpLightColor.setAlpha(1);\n\n            ctx.restore();\n        };\n\n        var drawStepPointerImage = function (ctx) {\n            ctx.save();\n\n            var tmpDarkColor = pointerColor.dark;\n            var tmpLightColor = pointerColor.light;\n            tmpDarkColor.setAlpha(0.70588);\n            tmpLightColor.setAlpha(0.70588);\n\n            // POINTER_LEVEL_LEFT\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.285046, imageHeight * 0.514018);\n            ctx.lineTo(imageWidth * 0.210280, imageHeight * 0.5);\n            ctx.lineTo(imageWidth * 0.285046, imageHeight * 0.481308);\n            ctx.bezierCurveTo(imageWidth * 0.285046, imageHeight * 0.481308, imageWidth * 0.280373, imageHeight * 0.490654, imageWidth * 0.280373, imageHeight * 0.495327);\n            ctx.bezierCurveTo(imageWidth * 0.280373, imageHeight * 0.504672, imageWidth * 0.285046, imageHeight * 0.514018, imageWidth * 0.285046, imageHeight * 0.514018);\n            ctx.closePath();\n            var POINTER_LEVEL_LEFT_GRADIENT = ctx.createLinearGradient(0.224299 * imageWidth, 0, 0.289719 * imageWidth, 0);\n            POINTER_LEVEL_LEFT_GRADIENT.addColorStop(0, tmpDarkColor.getRgbaColor());\n            POINTER_LEVEL_LEFT_GRADIENT.addColorStop(0.3, tmpLightColor.getRgbaColor());\n            POINTER_LEVEL_LEFT_GRADIENT.addColorStop(0.59, tmpLightColor.getRgbaColor());\n            POINTER_LEVEL_LEFT_GRADIENT.addColorStop(1, tmpDarkColor.getRgbaColor());\n            ctx.fillStyle = POINTER_LEVEL_LEFT_GRADIENT;\n            var strokeColor_POINTER_LEVEL_LEFT = pointerColor.light.getRgbaColor();\n            ctx.lineWidth = 1;\n            ctx.lineCap = 'square';\n            ctx.lineJoin = 'miter';\n            ctx.strokeStyle = strokeColor_POINTER_LEVEL_LEFT;\n            ctx.fill();\n            ctx.stroke();\n\n            // POINTER_LEVEL_RIGHT\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.714953, imageHeight * 0.514018);\n            ctx.lineTo(imageWidth * 0.789719, imageHeight * 0.5);\n            ctx.lineTo(imageWidth * 0.714953, imageHeight * 0.481308);\n            ctx.bezierCurveTo(imageWidth * 0.714953, imageHeight * 0.481308, imageWidth * 0.719626, imageHeight * 0.490654, imageWidth * 0.719626, imageHeight * 0.495327);\n            ctx.bezierCurveTo(imageWidth * 0.719626, imageHeight * 0.504672, imageWidth * 0.714953, imageHeight * 0.514018, imageWidth * 0.714953, imageHeight * 0.514018);\n            ctx.closePath();\n            var POINTER_LEVEL_RIGHT_GRADIENT = ctx.createLinearGradient(0.775700 * imageWidth, 0, 0.71028 * imageWidth, 0);\n            POINTER_LEVEL_RIGHT_GRADIENT.addColorStop(0, tmpDarkColor.getRgbaColor());\n            POINTER_LEVEL_RIGHT_GRADIENT.addColorStop(0.3, tmpLightColor.getRgbaColor());\n            POINTER_LEVEL_RIGHT_GRADIENT.addColorStop(0.59, tmpLightColor.getRgbaColor());\n            POINTER_LEVEL_RIGHT_GRADIENT.addColorStop(1, tmpDarkColor.getRgbaColor());\n            ctx.fillStyle = POINTER_LEVEL_RIGHT_GRADIENT;\n            var strokeColor_POINTER_LEVEL_RIGHT = pointerColor.light.getRgbaColor();\n            ctx.lineWidth = 1;\n            ctx.lineCap = 'square';\n            ctx.lineJoin = 'miter';\n            ctx.strokeStyle = strokeColor_POINTER_LEVEL_RIGHT;\n            ctx.fill();\n            ctx.stroke();\n\n            tmpDarkColor.setAlpha(1);\n            tmpLightColor.setAlpha(1);\n\n            ctx.restore();\n        };\n\n        // **************   Initialization  ********************\n        // Draw all static painting code to background\n        var init = function () {\n            initialized = true;\n\n            if (frameVisible) {\n                drawRadialFrameImage(backgroundContext, frameDesign, centerX, centerY, imageWidth, imageHeight);\n            }\n\n            if (backgroundVisible) {\n                drawRadialBackgroundImage(backgroundContext, backgroundColor, centerX, centerY, imageWidth, imageHeight);\n                drawTickmarksImage(backgroundContext);\n            }\n\n            drawMarkerImage(pointerContext);\n\n            drawPointerImage(pointerContext);\n\n            drawStepPointerImage(stepPointerContext);\n\n            if (foregroundVisible) {\n                drawRadialForegroundImage(foregroundContext, foregroundType, imageWidth, imageHeight, false);\n            }\n        };\n\n        var resetBuffers = function () {\n            backgroundBuffer.width = size;\n            backgroundBuffer.height = size;\n            backgroundContext = backgroundBuffer.getContext('2d');\n\n            // Buffer for pointer image painting code\n            pointerBuffer.width = size;\n            pointerBuffer.height = size;\n            pointerContext = pointerBuffer.getContext('2d');\n\n            // Buffer for step pointer image painting code\n            stepPointerBuffer.width = size;\n            stepPointerBuffer.height = size;\n            stepPointerContext = stepPointerBuffer.getContext('2d');\n\n            // Buffer for static foreground painting code\n            foregroundBuffer.width = size;\n            foregroundBuffer.height = size;\n            foregroundContext = foregroundBuffer.getContext('2d');\n        };\n\n        //************************************ Public methods **************************************\n        this.setValue = function (newValue) {\n            var targetValue;\n            newValue = parseFloat(newValue);\n            targetValue = 0 > newValue ? (360 + newValue) : newValue;\n            targetValue = 359.9 < newValue ? (newValue - 360) : newValue;\n\n            if (value !== targetValue) {\n                value = targetValue;\n                stepValue = 2 * ((Math.abs(value) * 10) % 10);\n                if (10 < stepValue) {\n                    stepValue -= 20;\n                }\n\n                if (0 === value) {\n                    visibleValue = 90;\n                }\n\n                if (0 < value && 90 >= value) {\n                    visibleValue = (90 - value);\n                }\n\n                if (90 < value && 180 >= value) {\n                    visibleValue = (value - 90);\n                }\n\n                if (180 < value && 270 >= value) {\n                    visibleValue = (270 - value);\n                }\n\n                if (270 < value && 360 >= value) {\n                    visibleValue = (value - 270);\n                }\n\n                if (0 > value && value >= -90) {\n                    visibleValue = (90 - Math.abs(value));\n                }\n\n                if (value < -90 && value >= -180) {\n                    visibleValue = Math.abs(value) - 90;\n                }\n\n                if (value < -180 && value >= -270) {\n                    visibleValue = 270 - Math.abs(value);\n                }\n\n                if (value < -270 && value >= -360) {\n                    visibleValue = Math.abs(value) - 270;\n                }\n\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getValue = function () {\n            return value;\n        };\n\n        this.setValueAnimated = function (newValue, callback) {\n            newValue = parseFloat(newValue);\n            if (360 - newValue + value < newValue - value) {\n                newValue = 360 - newValue;\n            }\n            if (value !== newValue) {\n                if (undefined !== tween && tween.isPlaying) {\n                    tween.stop();\n                }\n\n                //tween = new Tween(new Object(),'',Tween.elasticEaseOut,this.value,targetValue, 1);\n                tween = new Tween({}, '', Tween.regularEaseInOut, value, newValue, 1);\n                //tween = new Tween(new Object(), '', Tween.strongEaseInOut, this.value, targetValue, 1);\n\n                var gauge = this;\n\n                tween.onMotionChanged = function (event) {\n                    value = event.target._pos;\n                    stepValue = 2 * ((Math.abs(value) * 10) % 10);\n                    if (10 < stepValue) {\n                        stepValue -= 20;\n                    }\n\n                    if (0 === value) {\n                        visibleValue = 90;\n                    }\n\n                    if (0 < value && 90 >= value) {\n                        visibleValue = (90 - value);\n                    }\n\n                    if (90 < value && 180 >= value) {\n                        visibleValue = (value - 90);\n                    }\n\n                    if (180 < value && 270 >= value) {\n                        visibleValue = (270 - value);\n                    }\n\n                    if (270 < value && 360 >= value) {\n                        visibleValue = (value - 270);\n                    }\n\n                    if (0 > value && value >= -90) {\n                        visibleValue = (90 - Math.abs(value));\n                    }\n\n                    if (value < -90 && value >= -180) {\n                        visibleValue = Math.abs(value) - 90;\n                    }\n\n                    if (value < -180 && value >= -270) {\n                        visibleValue = 270 - Math.abs(value);\n                    }\n\n                    if (value < -270 && value >= -360) {\n                        visibleValue = Math.abs(value) - 270;\n                    }\n\n                    if (!repainting) {\n                        repainting = true;\n                        requestAnimFrame(gauge.repaint);\n                    }\n                };\n\n                // do we have a callback function to process?\n                if (callback && typeof(callback) === \"function\") {\n                    tween.onMotionFinished = callback;\n                }\n\n                tween.start();\n            }\n            return this;\n        };\n\n        this.setFrameDesign = function (newFrameDesign) {\n            resetBuffers();\n            frameDesign = newFrameDesign;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setBackgroundColor = function (newBackgroundColor) {\n            resetBuffers();\n            backgroundColor = newBackgroundColor;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setForegroundType = function (newForegroundType) {\n            resetBuffers();\n            foregroundType = newForegroundType;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerColor = function (newPointerColor) {\n            resetBuffers();\n            pointerColor = newPointerColor;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init();\n            }\n\n            mainCtx.save();\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n\n            angle = HALF_PI + value * angleStep - HALF_PI;\n            if (rotateFace) {\n                mainCtx.translate(centerX, centerY);\n                mainCtx.rotate(-angle);\n                mainCtx.translate(-centerX, -centerY);\n            }\n            // Draw buffered image to visible canvas\n            if (frameVisible || backgroundVisible) {\n                mainCtx.drawImage(backgroundBuffer, 0, 0);\n            }\n\n            mainCtx.save();\n            // Define rotation center\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate(angle);\n\n            // Draw pointer\n            mainCtx.translate(-centerX, -centerY);\n            mainCtx.drawImage(pointerBuffer, 0, 0);\n\n            mainCtx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n            mainCtx.textAlign = 'center';\n            mainCtx.textBaseline = 'middle';\n\n            if (textOrientationFixed) {\n                mainCtx.restore();\n                if (decimalsVisible) {\n                    mainCtx.font = imageWidth * 0.1 + 'px ' + stdFontName;\n                } else {\n                    mainCtx.font = imageWidth * 0.15 + 'px ' + stdFontName;\n                }\n                mainCtx.fillText(visibleValue.toFixed(decimals) + '\\u00B0', centerX, centerY, imageWidth * 0.35);\n            } else {\n                if (decimalsVisible) {\n                    mainCtx.font = imageWidth * 0.15 + 'px ' + stdFontName;\n                } else {\n                    mainCtx.font = imageWidth * 0.2 + 'px ' + stdFontName;\n                }\n                mainCtx.fillText(visibleValue.toFixed(decimals) + '\\u00B0', centerX, centerY, imageWidth * 0.35);\n                mainCtx.restore();\n            }\n\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate(angle + stepValue * RAD_FACTOR);\n            mainCtx.translate(-centerX, -centerY);\n            mainCtx.drawImage(stepPointerBuffer, 0, 0);\n            mainCtx.restore();\n\n            // Draw foreground\n            if (foregroundVisible) {\n                mainCtx.drawImage(foregroundBuffer, 0, 0);\n            }\n\n            mainCtx.restore();\n\n            repainting = false;\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var compass = function (canvas, parameters) {\n        parameters = parameters || {};\n        var size = (undefined === parameters.size ? 0 : parameters.size),\n            frameDesign = (undefined === parameters.frameDesign ? steelseries.FrameDesign.METAL : parameters.frameDesign),\n            frameVisible = (undefined === parameters.frameVisible ? true : parameters.frameVisible),\n            backgroundColor = (undefined === parameters.backgroundColor ? steelseries.BackgroundColor.DARK_GRAY : parameters.backgroundColor),\n            backgroundVisible = (undefined === parameters.backgroundVisible ? true : parameters.backgroundVisible),\n            pointerType = (undefined === parameters.pointerType ? steelseries.PointerType.TYPE2 : parameters.pointerType),\n            pointerColor = (undefined === parameters.pointerColor ? steelseries.ColorDef.RED : parameters.pointerColor),\n            knobType = (undefined === parameters.knobType ? steelseries.KnobType.STANDARD_KNOB : parameters.knobType),\n            knobStyle = (undefined === parameters.knobStyle ? steelseries.KnobStyle.SILVER : parameters.knobStyle),\n            foregroundType = (undefined === parameters.foregroundType ? steelseries.ForegroundType.TYPE1 : parameters.foregroundType),\n            foregroundVisible = (undefined === parameters.foregroundVisible ? true : parameters.foregroundVisible),\n            pointSymbols = (undefined === parameters.pointSymbols ? ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'] : parameters.pointSymbols),\n            pointSymbolsVisible = (undefined === parameters.pointSymbolsVisible ? true : parameters.pointSymbolsVisible),\n            customLayer = (undefined === parameters.customLayer ? null : parameters.customLayer),\n            degreeScale = (undefined === parameters.degreeScale ? false : parameters.degreeScale),\n            roseVisible = (undefined === parameters.roseVisible ? true : parameters.roseVisible),\n            rotateFace = (undefined === parameters.rotateFace ? false : parameters.rotateFace);\n\n        var tween;\n        var repainting = false;\n        var value = 0;\n        var angleStep = RAD_FACTOR;\n        var angle = this.value;\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (size === 0) {\n            size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height);\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = size;\n        mainCtx.canvas.height = size;\n\n        var imageWidth = size;\n        var imageHeight = size;\n\n        var centerX = imageWidth / 2;\n        var centerY = imageHeight / 2;\n\n        var shadowOffset = imageWidth * 0.006;\n\n        var initialized = false;\n\n        // **************   Buffer creation  ********************\n        // Buffer for all static background painting code\n        var backgroundBuffer = createBuffer(size, size);\n        var backgroundContext = backgroundBuffer.getContext('2d');\n\n        // Buffer for symbol/rose painting code\n        var roseBuffer = createBuffer(size, size);\n        var roseContext = roseBuffer.getContext('2d');\n\n        // Buffer for pointer image painting code\n        var pointerBuffer = createBuffer(size, size);\n        var pointerContext = pointerBuffer.getContext('2d');\n\n        // Buffer for static foreground painting code\n        var foregroundBuffer = createBuffer(size, size);\n        var foregroundContext = foregroundBuffer.getContext('2d');\n\n        // **************   Image creation  ********************\n        var drawTickmarksImage = function (ctx) {\n            var val;\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n\n            var stdFont, smlFont, i;\n\n            ctx.save();\n            ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.translate(centerX, centerY);\n\n            if (!degreeScale) {\n\n                stdFont = 0.12 * imageWidth + 'px serif';\n                smlFont = 0.06 * imageWidth + 'px serif';\n\n                for (i = 0; 360 > i; i += 2.5) {\n\n                    if (0 === i % 5) {\n                        ctx.lineWidth = 1;\n                        ctx.beginPath();\n                        ctx.moveTo(imageWidth * 0.38, 0);\n                        ctx.lineTo(imageWidth * 0.36, 0);\n                        ctx.closePath();\n                        ctx.stroke();\n                    }\n\n                    // Draw the labels\n                    ctx.save();\n                    switch (i) {\n                    case 0:\n                        ctx.translate(imageWidth * 0.35, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = stdFont;\n                        ctx.fillText(pointSymbols[2], 0, 0, imageWidth);\n                        ctx.translate(-imageWidth * 0.35, 0);\n                        break;\n                    case 45:\n                        ctx.translate(imageWidth * 0.29, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = smlFont;\n                        ctx.fillText(pointSymbols[3], 0, 0, imageWidth);\n                        ctx.translate(-imageWidth * 0.29, 0);\n                        break;\n                    case 90:\n                        ctx.translate(imageWidth * 0.35, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = stdFont;\n                        ctx.fillText(pointSymbols[4], 0, 0, imageWidth);\n                        ctx.translate(-imageWidth * 0.35, 0);\n                        break;\n                    case 135:\n                        ctx.translate(imageWidth * 0.29, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = smlFont;\n                        ctx.fillText(pointSymbols[5], 0, 0, imageWidth);\n                        ctx.translate(-imageWidth * 0.29, 0);\n                        break;\n                    case 180:\n                        ctx.translate(imageWidth * 0.35, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = stdFont;\n                        ctx.fillText(pointSymbols[6], 0, 0, imageWidth);\n                        ctx.translate(-imageWidth * 0.35, 0);\n                        break;\n                    case 225:\n                        ctx.translate(imageWidth * 0.29, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = smlFont;\n                        ctx.fillText(pointSymbols[7], 0, 0, imageWidth);\n                        ctx.translate(-imageWidth * 0.29, 0);\n                        break;\n                    case 270:\n                        ctx.translate(imageWidth * 0.35, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = stdFont;\n                        ctx.fillText(pointSymbols[0], 0, 0, imageWidth);\n                        ctx.translate(-imageWidth * 0.35, 0);\n                        break;\n                    case 315:\n                        ctx.translate(imageWidth * 0.29, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = smlFont;\n                        ctx.fillText(pointSymbols[1], 0, 0, imageWidth);\n                        ctx.translate(-imageWidth * 0.29, 0);\n                        break;\n                    }\n                    ctx.restore();\n\n                    if (roseVisible && (0 === i || 22.5 === i || 45 === i || 67.5 === i || 90 === i || 112.5 === i || 135 === i || 157.5 === i || 180 === i || 202.5 === i || 225 === i || 247.5 === i || 270 === i || 292.5 === i || 315 === i || 337.5 === i || 360 === i)) {\n                        // ROSE_LINE\n                        ctx.save();\n                        ctx.beginPath();\n                        // indent the 16 half quadrant lines a bit for visual effect\n                        if (i % 45) {\n                            ctx.moveTo(imageWidth * 0.29, 0);\n                        } else {\n                            ctx.moveTo(imageWidth * 0.38, 0);\n                        }\n                        ctx.lineTo(imageWidth * 0.1, 0);\n                        ctx.closePath();\n                        ctx.restore();\n                        ctx.lineWidth = 1;\n                        ctx.strokeStyle = backgroundColor.symbolColor.getRgbaColor();\n                        ctx.stroke();\n                    }\n                    ctx.rotate(angleStep * 2.5);\n                }\n            } else {\n                stdFont = 0.08 * imageWidth + 'px serif';\n                smlFont = imageWidth * 0.033 + 'px serif';\n\n                ctx.rotate(angleStep * 10);\n\n                for (i = 10; 360 >= i; i += 10) {\n                    // Draw the labels\n                    ctx.save();\n                    if (pointSymbolsVisible) {\n                        switch (i) {\n                        case 360:\n                            ctx.translate(imageWidth * 0.35, 0);\n                            ctx.rotate(HALF_PI);\n                            ctx.font = stdFont;\n                            ctx.fillText(pointSymbols[2], 0, 0, imageWidth);\n                            ctx.translate(-imageWidth * 0.35, 0);\n                            break;\n                        case 90:\n                            ctx.translate(imageWidth * 0.35, 0);\n                            ctx.rotate(HALF_PI);\n                            ctx.font = stdFont;\n                            ctx.fillText(pointSymbols[4], 0, 0, imageWidth);\n                            ctx.translate(-imageWidth * 0.35, 0);\n                            break;\n                        case 180:\n                            ctx.translate(imageWidth * 0.35, 0);\n                            ctx.rotate(HALF_PI);\n                            ctx.font = stdFont;\n                            ctx.fillText(pointSymbols[6], 0, 0, imageWidth);\n                            ctx.translate(-imageWidth * 0.35, 0);\n                            break;\n                        case 270:\n                            ctx.translate(imageWidth * 0.35, 0);\n                            ctx.rotate(HALF_PI);\n                            ctx.font = stdFont;\n                            ctx.fillText(pointSymbols[0], 0, 0, imageWidth);\n                            ctx.translate(-imageWidth * 0.35, 0);\n                            break;\n                        default:\n                            val = (i + 90) % 360;\n                            ctx.translate(imageWidth * 0.37, 0);\n                            ctx.rotate(HALF_PI);\n                            ctx.font = smlFont;\n                            ctx.fillText(('0'.substring(val >= 100) + val), 0, 0, imageWidth);\n                            ctx.translate(-imageWidth * 0.37, 0);\n                        }\n                    } else {\n                        val = (i + 90) % 360;\n                        ctx.translate(imageWidth * 0.37, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = smlFont;\n                        ctx.fillText(('0'.substring(val >= 100) + val), 0, 0, imageWidth);\n                        ctx.translate(-imageWidth * 0.37, 0);\n                    }\n                    ctx.restore();\n                    ctx.rotate(angleStep * 10);\n                }\n\n            }\n            ctx.translate(-centerX, -centerY);\n            ctx.restore();\n        };\n\n        var drawPointerImage = function (ctx) {\n            ctx.save();\n\n            switch (pointerType.type) {\n            case 'type2':\n                // NORTHPOINTER\n                ctx.beginPath();\n                ctx.moveTo(imageWidth * 0.532710, imageHeight * 0.453271);\n                ctx.bezierCurveTo(imageWidth * 0.532710, imageHeight * 0.453271, imageWidth * 0.5, imageHeight * 0.149532, imageWidth * 0.5, imageHeight * 0.149532);\n                ctx.bezierCurveTo(imageWidth * 0.5, imageHeight * 0.149532, imageWidth * 0.467289, imageHeight * 0.453271, imageWidth * 0.467289, imageHeight * 0.453271);\n                ctx.bezierCurveTo(imageWidth * 0.453271, imageHeight * 0.462616, imageWidth * 0.443925, imageHeight * 0.481308, imageWidth * 0.443925, imageHeight * 0.5);\n                ctx.bezierCurveTo(imageWidth * 0.443925, imageHeight * 0.5, imageWidth * 0.556074, imageHeight * 0.5, imageWidth * 0.556074, imageHeight * 0.5);\n                ctx.bezierCurveTo(imageWidth * 0.556074, imageHeight * 0.481308, imageWidth * 0.546728, imageHeight * 0.462616, imageWidth * 0.532710, imageHeight * 0.453271);\n                ctx.closePath();\n                var NORTHPOINTER2_GRADIENT = ctx.createLinearGradient(0.471962 * imageWidth, 0, 0.528036 * imageWidth, 0);\n                NORTHPOINTER2_GRADIENT.addColorStop(0, pointerColor.light.getRgbaColor());\n                NORTHPOINTER2_GRADIENT.addColorStop(0.46, pointerColor.light.getRgbaColor());\n                NORTHPOINTER2_GRADIENT.addColorStop(0.47, pointerColor.medium.getRgbaColor());\n                NORTHPOINTER2_GRADIENT.addColorStop(1, pointerColor.medium.getRgbaColor());\n                ctx.fillStyle = NORTHPOINTER2_GRADIENT;\n                ctx.strokeStyle = pointerColor.dark.getRgbaColor();\n                ctx.lineWidth = 1;\n                ctx.lineCap = 'square';\n                ctx.lineJoin = 'miter';\n                ctx.fill();\n                ctx.stroke();\n\n                // SOUTHPOINTER\n                ctx.beginPath();\n                ctx.moveTo(imageWidth * 0.467289, imageHeight * 0.546728);\n                ctx.bezierCurveTo(imageWidth * 0.467289, imageHeight * 0.546728, imageWidth * 0.5, imageHeight * 0.850467, imageWidth * 0.5, imageHeight * 0.850467);\n                ctx.bezierCurveTo(imageWidth * 0.5, imageHeight * 0.850467, imageWidth * 0.532710, imageHeight * 0.546728, imageWidth * 0.532710, imageHeight * 0.546728);\n                ctx.bezierCurveTo(imageWidth * 0.546728, imageHeight * 0.537383, imageWidth * 0.556074, imageHeight * 0.518691, imageWidth * 0.556074, imageHeight * 0.5);\n                ctx.bezierCurveTo(imageWidth * 0.556074, imageHeight * 0.5, imageWidth * 0.443925, imageHeight * 0.5, imageWidth * 0.443925, imageHeight * 0.5);\n                ctx.bezierCurveTo(imageWidth * 0.443925, imageHeight * 0.518691, imageWidth * 0.453271, imageHeight * 0.537383, imageWidth * 0.467289, imageHeight * 0.546728);\n                ctx.closePath();\n                var SOUTHPOINTER2_GRADIENT = ctx.createLinearGradient(0.471962 * imageWidth, 0, 0.528036 * imageWidth, 0);\n                SOUTHPOINTER2_GRADIENT.addColorStop(0, '#e3e5e8');\n                SOUTHPOINTER2_GRADIENT.addColorStop(0.48, '#e3e5e8');\n                SOUTHPOINTER2_GRADIENT.addColorStop(0.48, '#abb1b8');\n                SOUTHPOINTER2_GRADIENT.addColorStop(1, '#abb1b8');\n                ctx.fillStyle = SOUTHPOINTER2_GRADIENT;\n                var strokeColor_SOUTHPOINTER2 = '#abb1b8';\n                ctx.strokeStyle = strokeColor_SOUTHPOINTER2;\n                ctx.lineWidth = 1;\n                ctx.lineCap = 'square';\n                ctx.lineJoin = 'miter';\n                ctx.fill();\n                ctx.stroke();\n                break;\n\n            case 'type3':\n                // NORTHPOINTER\n                ctx.beginPath();\n                ctx.moveTo(imageWidth * 0.5, imageHeight * 0.149532);\n                ctx.bezierCurveTo(imageWidth * 0.5, imageHeight * 0.149532, imageWidth * 0.443925, imageHeight * 0.490654, imageWidth * 0.443925, imageHeight * 0.5);\n                ctx.bezierCurveTo(imageWidth * 0.443925, imageHeight * 0.532710, imageWidth * 0.467289, imageHeight * 0.556074, imageWidth * 0.5, imageHeight * 0.556074);\n                ctx.bezierCurveTo(imageWidth * 0.532710, imageHeight * 0.556074, imageWidth * 0.556074, imageHeight * 0.532710, imageWidth * 0.556074, imageHeight * 0.5);\n                ctx.bezierCurveTo(imageWidth * 0.556074, imageHeight * 0.490654, imageWidth * 0.5, imageHeight * 0.149532, imageWidth * 0.5, imageHeight * 0.149532);\n                ctx.closePath();\n                var NORTHPOINTER3_GRADIENT = ctx.createLinearGradient(0.471962 * imageWidth, 0, 0.528036 * imageWidth, 0);\n                NORTHPOINTER3_GRADIENT.addColorStop(0, pointerColor.light.getRgbaColor());\n                NORTHPOINTER3_GRADIENT.addColorStop(0.46, pointerColor.light.getRgbaColor());\n                NORTHPOINTER3_GRADIENT.addColorStop(0.47, pointerColor.medium.getRgbaColor());\n                NORTHPOINTER3_GRADIENT.addColorStop(1, pointerColor.medium.getRgbaColor());\n                ctx.fillStyle = NORTHPOINTER3_GRADIENT;\n                ctx.strokeStyle = pointerColor.dark.getRgbaColor();\n                ctx.lineWidth = 1;\n                ctx.lineCap = 'square';\n                ctx.lineJoin = 'miter';\n                ctx.fill();\n                ctx.stroke();\n                break;\n\n            case 'type1:':\n            /* falls through */\n            default:\n                // NORTHPOINTER\n                ctx.beginPath();\n                ctx.moveTo(imageWidth * 0.5, imageHeight * 0.495327);\n                ctx.lineTo(imageWidth * 0.528037, imageHeight * 0.495327);\n                ctx.lineTo(imageWidth * 0.5, imageHeight * 0.149532);\n                ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.495327);\n                ctx.lineTo(imageWidth * 0.5, imageHeight * 0.495327);\n                ctx.closePath();\n                var NORTHPOINTER1_GRADIENT = ctx.createLinearGradient(0.471962 * imageWidth, 0, 0.528036 * imageWidth, 0);\n                NORTHPOINTER1_GRADIENT.addColorStop(0, pointerColor.light.getRgbaColor());\n                NORTHPOINTER1_GRADIENT.addColorStop(0.46, pointerColor.light.getRgbaColor());\n                NORTHPOINTER1_GRADIENT.addColorStop(0.47, pointerColor.medium.getRgbaColor());\n                NORTHPOINTER1_GRADIENT.addColorStop(1, pointerColor.medium.getRgbaColor());\n                ctx.fillStyle = NORTHPOINTER1_GRADIENT;\n                ctx.strokeStyle = pointerColor.dark.getRgbaColor();\n                ctx.lineWidth = 1;\n                ctx.lineCap = 'square';\n                ctx.lineJoin = 'miter';\n                ctx.fill();\n                ctx.stroke();\n\n                // SOUTHPOINTER\n                ctx.beginPath();\n                ctx.moveTo(imageWidth * 0.5, imageHeight * 0.504672);\n                ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.504672);\n                ctx.lineTo(imageWidth * 0.5, imageHeight * 0.850467);\n                ctx.lineTo(imageWidth * 0.528037, imageHeight * 0.504672);\n                ctx.lineTo(imageWidth * 0.5, imageHeight * 0.504672);\n                ctx.closePath();\n                var SOUTHPOINTER1_GRADIENT = ctx.createLinearGradient(0.471962 * imageWidth, 0, 0.528036 * imageWidth, 0);\n                SOUTHPOINTER1_GRADIENT.addColorStop(0, '#e3e5e8');\n                SOUTHPOINTER1_GRADIENT.addColorStop(0.48, '#e3e5e8');\n                SOUTHPOINTER1_GRADIENT.addColorStop(0.480099, '#abb1b8');\n                SOUTHPOINTER1_GRADIENT.addColorStop(1, '#abb1b8');\n                ctx.fillStyle = SOUTHPOINTER1_GRADIENT;\n                var strokeColor_SOUTHPOINTER = '#abb1b8';\n                ctx.strokeStyle = strokeColor_SOUTHPOINTER;\n                ctx.lineWidth = 1;\n                ctx.lineCap = 'square';\n                ctx.lineJoin = 'miter';\n                ctx.fill();\n                ctx.stroke();\n                break;\n            }\n            ctx.restore();\n        };\n\n        // **************   Initialization  ********************\n        // Draw all static painting code to background\n        var init = function () {\n            initialized = true;\n\n            if (frameVisible) {\n                drawRadialFrameImage(backgroundContext, frameDesign, centerX, centerY, imageWidth, imageHeight);\n            }\n\n            if (backgroundVisible) {\n                drawRadialBackgroundImage(backgroundContext, backgroundColor, centerX, centerY, imageWidth, imageHeight);\n                drawRadialCustomImage(backgroundContext, customLayer, centerX, centerY, imageWidth, imageHeight);\n\n                if (roseVisible) {\n                    drawRoseImage(roseContext, centerX, centerY, imageWidth, imageHeight, backgroundColor);\n                }\n\n                drawTickmarksImage(roseContext);\n            }\n\n            drawPointerImage(pointerContext, false);\n\n            if (foregroundVisible) {\n                drawRadialForegroundImage(foregroundContext, foregroundType, imageWidth, imageHeight, true, knobType, knobStyle);\n            }\n        };\n\n        var resetBuffers = function () {\n            // Buffer for all static background painting code\n            backgroundBuffer.width = size;\n            backgroundBuffer.height = size;\n            backgroundContext = backgroundBuffer.getContext('2d');\n\n            // Buffer for symbols/rose painting code\n            roseBuffer.width = size;\n            roseBuffer.height = size;\n            roseContext = roseBuffer.getContext('2d');\n\n            // Buffer for pointer image painting code\n            pointerBuffer.width = size;\n            pointerBuffer.height = size;\n            pointerContext = pointerBuffer.getContext('2d');\n\n            // Buffer for static foreground painting code\n            foregroundBuffer.width = size;\n            foregroundBuffer.height = size;\n            foregroundContext = foregroundBuffer.getContext('2d');\n        };\n\n        //************************************ Public methods **************************************\n        this.setValue = function (newValue) {\n            newValue = parseFloat(newValue) % 360;\n            if (value !== newValue) {\n                value = newValue;\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getValue = function () {\n            return value;\n        };\n\n        this.setValueAnimated = function (newValue, callback) {\n            var targetValue = newValue % 360;\n            var gauge = this;\n            var diff;\n            if (value !== targetValue) {\n                if (undefined !==  tween && tween.isPlaying) {\n                    tween.stop();\n                }\n\n                diff = getShortestAngle(value, targetValue);\n                if (rotateFace) {\n                    tween = new Tween({}, '', Tween.regularEaseInOut, value, value + diff, 2);\n                } else {\n                    tween = new Tween({}, '', Tween.elasticEaseOut, value, value + diff, 2);\n                }\n                tween.onMotionChanged = function (event) {\n                    value = event.target._pos % 360;\n                    if (!repainting) {\n                        repainting = true;\n                        requestAnimFrame(gauge.repaint);\n                    }\n                };\n\n                // do we have a callback function to process?\n                if (callback && typeof(callback) === \"function\") {\n                    tween.onMotionFinished = callback;\n                }\n\n                tween.start();\n            }\n            return this;\n        };\n\n        this.setFrameDesign = function (newFrameDesign) {\n            resetBuffers();\n            frameDesign = newFrameDesign;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setBackgroundColor = function (newBackgroundColor) {\n            resetBuffers();\n            backgroundColor = newBackgroundColor;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setForegroundType = function (newForegroundType) {\n            resetBuffers();\n            foregroundType = newForegroundType;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerColor = function (newPointerColor) {\n            resetBuffers();\n            pointerColor = newPointerColor;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerType = function (newPointerType) {\n            resetBuffers();\n            pointerType = newPointerType;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setPointSymbols = function (newPointSymbols) {\n            resetBuffers();\n            pointSymbols = newPointSymbols;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init();\n            }\n\n            mainCtx.save();\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n            // Define rotation center\n            angle = HALF_PI + value * angleStep - HALF_PI;\n\n            if (backgroundVisible || frameVisible) {\n                mainCtx.drawImage(backgroundBuffer, 0, 0);\n            }\n\n            if (rotateFace) {\n                mainCtx.save();\n                mainCtx.translate(centerX, centerY);\n                mainCtx.rotate(-angle);\n                mainCtx.translate(-centerX, -centerY);\n                if (backgroundVisible) {\n                    mainCtx.drawImage(roseBuffer, 0, 0);\n                }\n                mainCtx.restore();\n            } else {\n                if (backgroundVisible) {\n                    mainCtx.drawImage(roseBuffer, 0, 0);\n                }\n                mainCtx.translate(centerX, centerY);\n                mainCtx.rotate(angle);\n                mainCtx.translate(-centerX, -centerY);\n            }\n            // Set the pointer shadow params\n            mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n            mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset;\n            mainCtx.shadowBlur = shadowOffset * 2;\n            // Draw the pointer\n            mainCtx.drawImage(pointerBuffer, 0, 0);\n            // Undo the translations & shadow settings\n            mainCtx.restore();\n\n            if (foregroundVisible) {\n                mainCtx.drawImage(foregroundBuffer, 0, 0);\n            }\n\n            repainting = false;\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var windDirection = function (canvas, parameters) {\n        parameters = parameters || {};\n        var size = (undefined === parameters.size ? 0 : parameters.size),\n            frameDesign = (undefined === parameters.frameDesign ? steelseries.FrameDesign.METAL : parameters.frameDesign),\n            frameVisible = (undefined === parameters.frameVisible ? true : parameters.frameVisible),\n            backgroundColor = (undefined === parameters.backgroundColor ? steelseries.BackgroundColor.DARK_GRAY : parameters.backgroundColor),\n            backgroundVisible = (undefined === parameters.backgroundVisible ? true : parameters.backgroundVisible),\n            pointerTypeLatest = (undefined === parameters.pointerTypeLatest ? steelseries.PointerType.TYPE1 : parameters.pointerTypeLatest),\n            pointerTypeAverage = (undefined === parameters.pointerTypeAverage ? steelseries.PointerType.TYPE8 : parameters.pointerTypeAverage),\n            pointerColor = (undefined === parameters.pointerColor ? steelseries.ColorDef.RED : parameters.pointerColor),\n            pointerColorAverage = (undefined === parameters.pointerColorAverage ? steelseries.ColorDef.BLUE : parameters.pointerColorAverage),\n            knobType = (undefined === parameters.knobType ? steelseries.KnobType.STANDARD_KNOB : parameters.knobType),\n            knobStyle = (undefined === parameters.knobStyle ? steelseries.KnobStyle.SILVER : parameters.knobStyle),\n            foregroundType = (undefined === parameters.foregroundType ? steelseries.ForegroundType.TYPE1 : parameters.foregroundType),\n            foregroundVisible = (undefined === parameters.foregroundVisible ? true : parameters.foregroundVisible),\n            pointSymbols = (undefined === parameters.pointSymbols ? ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'] : parameters.pointSymbols),\n            pointSymbolsVisible = (undefined === parameters.pointSymbolsVisible ? true : parameters.pointSymbolsVisible),\n            customLayer = (undefined === parameters.customLayer ? null : parameters.customLayer),\n            degreeScale = (undefined === parameters.degreeScale ? true : parameters.degreeScale),\n            degreeScaleHalf = (undefined === parameters.degreeScaleHalf ? false : parameters.degreeScaleHalf),\n            roseVisible = (undefined === parameters.roseVisible ? false : parameters.roseVisible),\n            lcdColor = (undefined === parameters.lcdColor ? steelseries.LcdColor.STANDARD : parameters.lcdColor),\n            lcdVisible = (undefined === parameters.lcdVisible ? true : parameters.lcdVisible),\n            digitalFont = (undefined === parameters.digitalFont ? false : parameters.digitalFont),\n            section = (undefined === parameters.section ? null : parameters.section),\n            area = (undefined === parameters.area ? null : parameters.area),\n            lcdTitleStrings = (undefined === parameters.lcdTitleStrings ? ['Latest', 'Average'] : parameters.lcdTitleStrings),\n            titleString = (undefined === parameters.titleString ? '' : parameters.titleString),\n            useColorLabels = (undefined === parameters.useColorLabels ? false : parameters.useColorLabels),\n            fullScaleDeflectionTime = (undefined === parameters.fullScaleDeflectionTime ? 2.5 : parameters.fullScaleDeflectionTime);\n\n        var tweenLatest;\n        var tweenAverage;\n        var valueLatest = 0;\n        var valueAverage = 0;\n        var angleStep = RAD_FACTOR;\n        var angleLatest = this.valueLatest;\n        var angleAverage = this.valueAverage;\n        var rotationOffset = -HALF_PI;\n        var angleRange = TWO_PI;\n        var range = 360;\n        var repainting = false;\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (size === 0) {\n            size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height);\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = size;\n        mainCtx.canvas.height = size;\n\n        var imageWidth = size;\n        var imageHeight = size;\n\n        var centerX = imageWidth / 2;\n        var centerY = imageHeight / 2;\n\n        var lcdFontHeight = Math.floor(imageWidth / 10);\n        var stdFont = lcdFontHeight + 'px ' + stdFontName;\n        var lcdFont = lcdFontHeight + 'px ' + lcdFontName;\n        var lcdWidth = imageWidth * 0.3;\n        var lcdHeight = imageHeight * 0.12;\n        var lcdPosX = (imageWidth - lcdWidth) / 2;\n        var lcdPosY1 = imageHeight * 0.32;\n        var lcdPosY2 = imageHeight * 0.565;\n\n        var initialized = false;\n\n        // **************   Buffer creation  ********************\n        // Buffer for all static background painting code\n        var backgroundBuffer = createBuffer(size, size);\n        var backgroundContext = backgroundBuffer.getContext('2d');\n\n        // Buffer for LCD displays\n        var lcdBuffer;\n\n        // Buffer for latest pointer images painting code\n        var pointerBufferLatest = createBuffer(size, size);\n        var pointerContextLatest = pointerBufferLatest.getContext('2d');\n\n        // Buffer for average pointer image\n        var pointerBufferAverage = createBuffer(size, size);\n        var pointerContextAverage = pointerBufferAverage.getContext('2d');\n\n        // Buffer for static foreground painting code\n        var foregroundBuffer = createBuffer(size, size);\n        var foregroundContext = foregroundBuffer.getContext('2d');\n\n        // **************   Image creation  ********************\n        var drawLcdText = function (value, bLatest) {\n            mainCtx.save();\n            mainCtx.textAlign = 'center';\n            mainCtx.strokeStyle = lcdColor.textColor;\n            mainCtx.fillStyle = lcdColor.textColor;\n\n            //convert value from -180,180 range into 0-360 range\n            while (value < -180) {\n                value += 360;\n            }\n            if (!degreeScaleHalf && value < 0) {\n                value += 360;\n            }\n\n            if (degreeScaleHalf && value > 180) {\n                value = -(360 - value);\n            }\n\n            if (value >= 0) {\n                value = '00' + Math.round(value);\n                value = value.substring(value.length, value.length - 3);\n            } else {\n                value = '00' + Math.abs(Math.round(value));\n                value = '-' + value.substring(value.length, value.length - 3);\n            }\n\n            if (lcdColor === steelseries.LcdColor.STANDARD || lcdColor === steelseries.LcdColor.STANDARD_GREEN) {\n                mainCtx.shadowColor = 'gray';\n                mainCtx.shadowOffsetX = imageWidth * 0.007;\n                mainCtx.shadowOffsetY = imageWidth * 0.007;\n                mainCtx.shadowBlur = imageWidth * 0.007;\n            }\n            mainCtx.font = (digitalFont ? lcdFont : stdFont);\n            mainCtx.fillText(value + '\\u00B0', imageWidth / 2 + lcdWidth * 0.05, (bLatest ? lcdPosY1 : lcdPosY2) + lcdHeight * 0.5 + lcdFontHeight * 0.38, lcdWidth * 0.9);\n\n            mainCtx.restore();\n        };\n\n        var drawAreaSectionImage = function (ctx, start, stop, color, filled) {\n\n            ctx.save();\n            ctx.strokeStyle = color;\n            ctx.fillStyle = color;\n            ctx.lineWidth = imageWidth * 0.035;\n            var startAngle = (angleRange / range * start);\n            var stopAngle = startAngle + (stop - start) / (range / angleRange);\n            ctx.translate(centerX, centerY);\n            ctx.rotate(rotationOffset);\n            ctx.beginPath();\n            if (filled) {\n                ctx.moveTo(0, 0);\n                ctx.arc(0, 0, imageWidth * 0.365 - ctx.lineWidth / 2, startAngle, stopAngle, false);\n            } else {\n                ctx.arc(0, 0, imageWidth * 0.365, startAngle, stopAngle, false);\n            }\n            if (filled) {\n                ctx.moveTo(0, 0);\n                ctx.fill();\n            } else {\n                ctx.stroke();\n            }\n\n            ctx.translate(-centerX, -centerY);\n            ctx.restore();\n        };\n\n        var drawTickmarksImage = function (ctx) {\n            var OUTER_POINT = imageWidth * 0.38,\n                MAJOR_INNER_POINT = imageWidth * 0.35,\n                //MED_INNER_POINT = imageWidth * 0.355,\n                MINOR_INNER_POINT = imageWidth * 0.36,\n                TEXT_WIDTH = imageWidth * 0.1,\n                TEXT_TRANSLATE_X = imageWidth * 0.31,\n                CARDINAL_TRANSLATE_X = imageWidth * 0.36,\n                stdFont, smlFont,\n                i, val, to;\n\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n\n            ctx.save();\n            ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.translate(centerX, centerY);\n\n            if (!degreeScale) {\n\n                stdFont = 0.12 * imageWidth + 'px serif';\n                smlFont = 0.06 * imageWidth + 'px serif';\n\n                //var angleStep = RAD_FACTOR;\n                ctx.lineWidth = 1;\n                ctx.strokeStyle = backgroundColor.symbolColor.getRgbaColor();\n\n                for (i = 0; 360 > i; i += 2.5) {\n\n                    if (0 === i % 5) {\n                        ctx.beginPath();\n                        ctx.moveTo(imageWidth * 0.38, 0);\n                        ctx.lineTo(imageWidth * 0.36, 0);\n                        ctx.closePath();\n                        ctx.stroke();\n                    }\n\n                    // Draw the labels\n                    ctx.save();\n                    switch (i) {\n                    case 0: //E\n                        ctx.translate(imageWidth * 0.35, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = stdFont;\n                        ctx.fillText(pointSymbols[2], 0, 0);\n                        ctx.translate(-imageWidth * 0.35, 0);\n                        break;\n                    case 45: //SE\n                        ctx.translate(imageWidth * 0.29, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = smlFont;\n                        ctx.fillText(pointSymbols[3], 0, 0);\n                        ctx.translate(-imageWidth * 0.29, 0);\n                        break;\n                    case 90: //S\n                        ctx.translate(imageWidth * 0.35, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = stdFont;\n                        ctx.fillText(pointSymbols[4], 0, 0);\n                        ctx.translate(-imageWidth * 0.35, 0);\n                        break;\n                    case 135: //SW\n                        ctx.translate(imageWidth * 0.29, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = smlFont;\n                        ctx.fillText(pointSymbols[5], 0, 0);\n                        ctx.translate(-imageWidth * 0.29, 0);\n                        break;\n                    case 180: //W\n                        ctx.translate(imageWidth * 0.35, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = stdFont;\n                        ctx.fillText(pointSymbols[6], 0, 0);\n                        ctx.translate(-imageWidth * 0.35, 0);\n                        break;\n                    case 225: //NW\n                        ctx.translate(imageWidth * 0.29, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = smlFont;\n                        ctx.fillText(pointSymbols[7], 0, 0);\n                        ctx.translate(-imageWidth * 0.29, 0);\n                        break;\n                    case 270: //N\n                        ctx.translate(imageWidth * 0.35, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = stdFont;\n                        ctx.fillText(pointSymbols[0], 0, 0);\n                        ctx.translate(-imageWidth * 0.35, 0);\n                        break;\n                    case 315: //NE\n                        ctx.translate(imageWidth * 0.29, 0);\n                        ctx.rotate(HALF_PI);\n                        ctx.font = smlFont;\n                        ctx.fillText(pointSymbols[1], 0, 0);\n                        ctx.translate(-imageWidth * 0.29, 0);\n                        break;\n                    }\n                    ctx.restore();\n\n                    if (roseVisible && (0 === i || 22.5 === i || 45 === i || 67.5 === i || 90 === i || 112.5 === i || 135 === i || 157.5 === i || 180 === i || 202.5 === i || 225 === i || 247.5 === i || 270 === i || 292.5 === i || 315 === i || 337.5 === i || 360 === i)) {\n                        // ROSE_LINE\n                        ctx.save();\n                        ctx.beginPath();\n                        // indent the 16 half quadrant lines a bit for visual effect\n                        if (i % 45) {\n                            ctx.moveTo(imageWidth * 0.29, 0);\n                        } else {\n                            ctx.moveTo(imageWidth * 0.38, 0);\n                        }\n                        ctx.lineTo(imageWidth * 0.1, 0);\n                        ctx.closePath();\n                        ctx.restore();\n                        ctx.stroke();\n                    }\n                    ctx.rotate(angleStep * 2.5);\n                }\n            } else {\n                stdFont = Math.floor(0.1 * imageWidth) + 'px serif bold';\n                smlFont = Math.floor(imageWidth * 0.04) + 'px ' + stdFontName;\n\n                ctx.rotate(angleStep * 5);\n                for (i = 5; 360 >= i; i += 5) {\n                    // Draw the labels\n                    ctx.save();\n                    if (pointSymbolsVisible) {\n\n                        switch (i) {\n                        case 360:\n                            ctx.translate(CARDINAL_TRANSLATE_X, 0);\n                            ctx.rotate(HALF_PI);\n                            ctx.font = stdFont;\n                            ctx.fillText(pointSymbols[2], 0, 0, TEXT_WIDTH);\n                            ctx.translate(-CARDINAL_TRANSLATE_X, 0);\n                            break;\n                        case 90:\n                            ctx.translate(CARDINAL_TRANSLATE_X, 0);\n                            ctx.rotate(HALF_PI);\n                            ctx.font = stdFont;\n                            ctx.fillText(pointSymbols[4], 0, 0, TEXT_WIDTH);\n                            ctx.translate(-CARDINAL_TRANSLATE_X, 0);\n                            break;\n                        case 180:\n                            ctx.translate(CARDINAL_TRANSLATE_X, 0);\n                            ctx.rotate(HALF_PI);\n                            ctx.font = stdFont;\n                            ctx.fillText(pointSymbols[6], 0, 0, TEXT_WIDTH);\n                            ctx.translate(-CARDINAL_TRANSLATE_X, 0);\n                            break;\n                        case 270:\n                            ctx.translate(CARDINAL_TRANSLATE_X, 0);\n                            ctx.rotate(HALF_PI);\n                            ctx.font = stdFont;\n                            ctx.fillText(pointSymbols[0], 0, 0, TEXT_WIDTH);\n                            ctx.translate(-CARDINAL_TRANSLATE_X, 0);\n                            break;\n\n                        case 5:\n                        case 85:\n                        case 95:\n                        case 175:\n                        case 185:\n                        case 265:\n                        case 275:\n                        case 355:\n                            //leave room for ordinal labels\n                            break;\n\n                        default:\n                            if ((i + 90) % 20) {\n                                ctx.lineWidth = ((i + 90) % 5) ? 1.5 : 1;\n                                ctx.beginPath();\n                                ctx.moveTo(OUTER_POINT, 0);\n                                to = (i + 90) % 10 ? MINOR_INNER_POINT : MAJOR_INNER_POINT;\n                                ctx.lineTo(to, 0);\n                                ctx.closePath();\n                                ctx.stroke();\n                            } else {\n                                ctx.lineWidth = 1.5;\n                                ctx.beginPath();\n                                ctx.moveTo(OUTER_POINT, 0);\n                                ctx.lineTo(MAJOR_INNER_POINT, 0);\n                                ctx.closePath();\n                                ctx.stroke();\n                                val = (i + 90) % 360;\n                                ctx.translate(TEXT_TRANSLATE_X, 0);\n                                ctx.rotate(HALF_PI);\n                                ctx.font = smlFont;\n                                ctx.fillText(('0'.substring(val >= 100) + val), 0, 0, TEXT_WIDTH);\n                                ctx.translate(-TEXT_TRANSLATE_X, 0);\n                            }\n                        }\n                    } else {\n\n                        if ((i + 90) % 20) {\n                            ctx.lineWidth = ((i + 90) % 5) ? 1.5 : 1;\n                            ctx.beginPath();\n                            ctx.moveTo(OUTER_POINT, 0);\n                            to = (i + 90) % 10 ? MINOR_INNER_POINT : MAJOR_INNER_POINT;\n                            ctx.lineTo(to, 0);\n                            ctx.closePath();\n                            ctx.stroke();\n                        } else {\n                            ctx.lineWidth = 1.5;\n                            ctx.beginPath();\n                            ctx.moveTo(OUTER_POINT, 0);\n                            ctx.lineTo(MAJOR_INNER_POINT, 0);\n                            ctx.closePath();\n                            ctx.stroke();\n                            val = (i + 90) % 360;\n                            if (degreeScaleHalf) {\n                                //invert 180-360\n                                if (val > 180) {\n                                    val = -(360 - val);\n                                }\n                            }\n                            ctx.translate(TEXT_TRANSLATE_X, 0);\n                            ctx.rotate(HALF_PI);\n                            ctx.font = smlFont;\n                            ctx.fillText(val, 0, 0, TEXT_WIDTH);\n                            ctx.translate(-TEXT_TRANSLATE_X, 0);\n                        }\n                    }\n                    ctx.restore();\n                    ctx.rotate(angleStep * 5);\n                }\n\n            }\n            ctx.translate(-centerX, -centerY);\n            ctx.restore();\n        };\n\n        var drawLcdTitles = function (ctx) {\n            if (lcdTitleStrings.length > 0) {\n                ctx.save();\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillStyle = (useColorLabels ? pointerColor.medium.getRgbaColor() : backgroundColor.labelColor.getRgbaColor());\n                ctx.font = 0.040 * imageWidth + 'px ' + stdFontName;\n                ctx.fillText(lcdTitleStrings[0], imageWidth / 2, imageHeight * 0.29, imageWidth * 0.3);\n                ctx.fillStyle = (useColorLabels ? pointerColorAverage.medium.getRgbaColor() : backgroundColor.labelColor.getRgbaColor());\n                ctx.fillText(lcdTitleStrings[1], imageWidth / 2, imageHeight * 0.71, imageWidth * 0.3);\n                if (titleString.length > 0) {\n                    ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n                    ctx.font = 0.0467 * imageWidth + 'px ' + stdFontName;\n                    ctx.fillText(titleString, imageWidth / 2, imageHeight * 0.5, imageWidth * 0.3);\n                }\n            }\n        };\n\n        // **************   Initialization  ********************\n        // Draw all static painting code to background\n\n        var init = function (parameters) {\n            parameters = parameters || {};\n            var drawBackground = (undefined === parameters.background ? false : parameters.background);\n            var drawPointer = (undefined === parameters.pointer ? false : parameters.pointer);\n            var drawForeground = (undefined === parameters.foreground ? false : parameters.foreground);\n\n            initialized = true;\n\n            if (drawBackground && frameVisible) {\n                drawRadialFrameImage(backgroundContext, frameDesign, centerX, centerY, imageWidth, imageHeight);\n            }\n\n            if (drawBackground && backgroundVisible) {\n                // Create background in background buffer (backgroundBuffer)\n                drawRadialBackgroundImage(backgroundContext, backgroundColor, centerX, centerY, imageWidth, imageHeight);\n\n                // Create custom layer in background buffer (backgroundBuffer)\n                drawRadialCustomImage(backgroundContext, customLayer, centerX, centerY, imageWidth, imageHeight);\n\n                // Create section in background buffer (backgroundBuffer)\n                if (null !== section && 0 < section.length) {\n                    var sectionIndex = section.length;\n                    do {\n                        sectionIndex--;\n                        drawAreaSectionImage(backgroundContext, section[sectionIndex].start, section[sectionIndex].stop, section[sectionIndex].color, false);\n                    }\n                    while (0 < sectionIndex);\n                }\n\n                // Create area in background buffer (backgroundBuffer)\n                if (null !== area && 0 < area.length) {\n                    var areaIndex = area.length;\n                    do {\n                        areaIndex--;\n                        drawAreaSectionImage(backgroundContext, area[areaIndex].start, area[areaIndex].stop, area[areaIndex].color, true);\n                    }\n                    while (0 < areaIndex);\n                }\n\n                drawTickmarksImage(backgroundContext);\n            }\n\n            if (drawBackground && roseVisible) {\n                drawRoseImage(backgroundContext, centerX, centerY, imageWidth, imageHeight, backgroundColor);\n            }\n\n            // Create lcd background if selected in background buffer (backgroundBuffer)\n            if (drawBackground && lcdVisible) {\n                lcdBuffer = createLcdBackgroundImage(lcdWidth, lcdHeight, lcdColor);\n                backgroundContext.drawImage(lcdBuffer, lcdPosX, lcdPosY1);\n                backgroundContext.drawImage(lcdBuffer, lcdPosX, lcdPosY2);\n                // Create title in background buffer (backgroundBuffer)\n                drawLcdTitles(backgroundContext);\n            }\n\n            if (drawPointer) {\n                drawPointerImage(pointerContextAverage, imageWidth, pointerTypeAverage, pointerColorAverage, backgroundColor.labelColor);\n                drawPointerImage(pointerContextLatest, imageWidth, pointerTypeLatest, pointerColor, backgroundColor.labelColor);\n            }\n\n            if (drawForeground && foregroundVisible) {\n                var knobVisible = (pointerTypeLatest.type === 'type15' || pointerTypeLatest.type === 'type16' ? false : true);\n                drawRadialForegroundImage(foregroundContext, foregroundType, imageWidth, imageHeight, knobVisible, knobType, knobStyle);\n            }\n        };\n\n        var resetBuffers = function (buffers) {\n            buffers = buffers || {};\n            var resetBackground = (undefined === buffers.background ? false : buffers.background);\n            var resetPointer = (undefined === buffers.pointer ? false : buffers.pointer);\n            var resetForeground = (undefined === buffers.foreground ? false : buffers.foreground);\n\n            // Buffer for all static background painting code\n            if (resetBackground) {\n                backgroundBuffer.width = size;\n                backgroundBuffer.height = size;\n                backgroundContext = backgroundBuffer.getContext('2d');\n            }\n            // Buffers for pointer image painting code\n            if (resetPointer) {\n                pointerBufferLatest.width = size;\n                pointerBufferLatest.height = size;\n                pointerContextLatest = pointerBufferLatest.getContext('2d');\n\n                pointerBufferAverage.width = size;\n                pointerBufferAverage.height = size;\n                pointerContextAverage = pointerBufferAverage.getContext('2d');\n            }\n            // Buffer for static foreground painting code\n            if (resetForeground) {\n                foregroundBuffer.width = size;\n                foregroundBuffer.height = size;\n                foregroundContext = foregroundBuffer.getContext('2d');\n            }\n        };\n\n        //************************************ Public methods **************************************\n        this.setValueLatest = function (newValue) {\n            // Actually need to handle 0-360 rather than 0-359\n            // 1-360 are used for directions\n            // 0 is used as a special case to indicate 'calm'\n            newValue = parseFloat(newValue);\n            newValue = newValue === 360 ? 360 : newValue % 360;\n            if (valueLatest !== newValue) {\n                valueLatest = newValue;\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getValueLatest = function () {\n            return valueLatest;\n        };\n\n        this.setValueAverage = function (newValue) {\n            // Actually need to handle 0-360 rather than 0-359\n            // 1-360 are used for directions\n            // 0 is used as a special case to indicate 'calm'\n            newValue = parseFloat(newValue);\n            newValue = newValue === 360 ? 360 : newValue % 360;\n            if (valueAverage !== newValue) {\n                valueAverage = newValue;\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getValueAverage = function () {\n            return valueAverage;\n        };\n\n        this.setValueAnimatedLatest = function (newValue, callback) {\n            var targetValue,\n                gauge = this,\n                diff,\n                time;\n            // Actually need to handle 0-360 rather than 0-359\n            // 1-360 are used for directions\n            // 0 is used as a special case to indicate 'calm'\n            newValue = parseFloat(newValue);\n            targetValue = (newValue === 360 ? 360 : newValue % 360);\n\n            if (valueLatest !== targetValue) {\n                if (undefined !== tweenLatest && tweenLatest.isPlaying) {\n                    tweenLatest.stop();\n                }\n\n                diff = getShortestAngle(valueLatest, targetValue);\n\n                if (diff !== 0) { // 360 - 0 is a diff of zero\n                    time = fullScaleDeflectionTime * Math.abs(diff) / 180;\n                    time = Math.max(time, fullScaleDeflectionTime / 5);\n                    tweenLatest = new Tween({}, '', Tween.regularEaseInOut, valueLatest, valueLatest + diff, time);\n                    tweenLatest.onMotionChanged = function (event) {\n                        valueLatest = event.target._pos === 360 ? 360 : event.target._pos % 360;\n                        if (!repainting) {\n                            repainting = true;\n                            requestAnimFrame(gauge.repaint);\n                        }\n                    };\n\n                    tweenLatest.onMotionFinished = function (event) {\n                        valueLatest = event.target._pos === 360 ? 360 : event.target._pos % 360;\n                        if (!repainting) {\n                            repainting = true;\n                            requestAnimFrame(gauge.repaint);\n                        }\n                        // do we have a callback function to process?\n                        if (callback && typeof(callback) === \"function\") {\n                            callback();\n                        }\n                    };\n\n                    tweenLatest.start();\n                } else {\n                    // target different from current, but diff is zero (0 -> 360 for instance), so just repaint\n                    valueLatest = targetValue;\n                    if (!repainting) {\n                        repainting = true;\n                        requestAnimFrame(gauge.repaint);\n                    }\n                }\n            }\n            return this;\n        };\n\n        this.setValueAnimatedAverage = function (newValue, callback) {\n            var targetValue,\n                gauge = this,\n                diff, time;\n            // Actually need to handle 0-360 rather than 0-359\n            // 1-360 are used for directions\n            // 0 is used as a special case to indicate 'calm'\n            newValue = parseFloat(newValue);\n            targetValue = (newValue === 360 ? 360 : newValue % 360);\n            if (valueAverage !== newValue) {\n                if (undefined !== tweenAverage && tweenAverage.isPlaying) {\n                    tweenAverage.stop();\n                }\n\n                diff = getShortestAngle(valueAverage, targetValue);\n                if (diff !== 0) { // 360 - 0 is a diff of zero\n                    time = fullScaleDeflectionTime * Math.abs(diff) / 180;\n                    time = Math.max(time, fullScaleDeflectionTime / 5);\n                    tweenAverage = new Tween({}, '', Tween.regularEaseInOut, valueAverage, valueAverage + diff, time);\n                    tweenAverage.onMotionChanged = function (event) {\n                        valueAverage = event.target._pos === 360 ? 360 : event.target._pos % 360;\n                        if (!repainting) {\n                            repainting = true;\n                            requestAnimFrame(gauge.repaint);\n                        }\n                    };\n\n                    tweenAverage.onMotionFinished = function (event) {\n                        valueLatest = event.target._pos === 360 ? 360 : event.target._pos % 360;\n                        if (!repainting) {\n                            repainting = true;\n                            requestAnimFrame(gauge.repaint);\n                        }\n                        // do we have a callback function to process?\n                        if (callback && typeof(callback) === \"function\") {\n                            callback();\n                        }\n                    };\n                    \n                    tweenAverage.start();\n                } else {\n                    // target different from current, but diff is zero (0 -> 360 for instance), so just repaint\n                    valueAverage = targetValue;\n                    if (!repainting) {\n                        repainting = true;\n                        requestAnimFrame(gauge.repaint);\n                    }\n                }\n            }\n            return this;\n        };\n\n        this.setArea = function (areaVal) {\n            area = areaVal;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setSection = function (areaSec) {\n            section = areaSec;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setFrameDesign = function (newFrameDesign) {\n            frameDesign = newFrameDesign;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setBackgroundColor = function (newBackgroundColor) {\n            backgroundColor = newBackgroundColor;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setForegroundType = function (newForegroundType) {\n            resetBuffers({foreground: true});\n            foregroundType = newForegroundType;\n            init({foreground: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerColor = function (newPointerColor) {\n            resetBuffers({pointer: true});\n            pointerColor = newPointerColor;\n            init({pointer: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerColorAverage = function (newPointerColor) {\n            resetBuffers({pointer: true});\n            pointerColorAverage = newPointerColor;\n            init({pointer: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerType = function (newPointerType) {\n            pointerTypeLatest = newPointerType;\n            resetBuffers({pointer: true,\n                          foreground: true\n                         });\n            init({pointer: true,\n                  foreground: true\n                  });\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerTypeAverage = function (newPointerType) {\n            pointerTypeAverage = newPointerType;\n            resetBuffers({pointer: true,\n                          foreground: true\n                         });\n            init({pointer: true,\n                  foreground: true\n                  });\n            this.repaint();\n            return this;\n        };\n\n        this.setPointSymbols = function (newPointSymbols) {\n            pointSymbols = newPointSymbols;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLcdColor = function (newLcdColor) {\n            lcdColor = newLcdColor;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLcdTitleStrings = function (titles) {\n            lcdTitleStrings = titles;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init({frame: true,\n                      background: true,\n                      led: true,\n                      pointer: true,\n                      foreground: true});\n            }\n\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n\n            if (frameVisible || backgroundVisible) {\n                mainCtx.drawImage(backgroundBuffer, 0, 0);\n            }\n\n            // Draw lcd display\n            if (lcdVisible) {\n                drawLcdText(valueLatest, true);\n                drawLcdText(valueAverage, false);\n            }\n\n            // Define rotation angle\n            angleAverage = valueAverage * angleStep;\n\n            // we have to draw to a rotated temporary image area so we can translate in\n            // absolute x, y values when drawing to main context\n            var shadowOffset = imageWidth * 0.006;\n\n            // Define rotation center\n            mainCtx.save();\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate(angleAverage);\n            mainCtx.translate(-centerX, -centerY);\n            // Set the pointer shadow params\n            mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n            mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset;\n            mainCtx.shadowBlur = shadowOffset * 2;\n            // Draw the pointer\n            mainCtx.drawImage(pointerBufferAverage, 0, 0);\n            // Define rotation angle difference for average pointer\n            angleLatest = valueLatest * angleStep  - angleAverage;\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate(angleLatest);\n            mainCtx.translate(-centerX, -centerY);\n            mainCtx.drawImage(pointerBufferLatest, 0, 0);\n            mainCtx.restore();\n\n            if (foregroundVisible) {\n                mainCtx.drawImage(foregroundBuffer, 0, 0);\n            }\n\n            repainting = false;\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var horizon = function (canvas, parameters) {\n        parameters = parameters || {};\n        var size = (undefined === parameters.size ? 0 : parameters.size),\n            frameDesign = (undefined === parameters.frameDesign ? steelseries.FrameDesign.METAL : parameters.frameDesign),\n            frameVisible = (undefined === parameters.frameVisible ? true : parameters.frameVisible),\n            foregroundType = (undefined === parameters.foregroundType ? steelseries.ForegroundType.TYPE1 : parameters.foregroundType),\n            foregroundVisible = (undefined === parameters.foregroundVisible ? true : parameters.foregroundVisible),\n            pointerColor = (undefined === parameters.pointerColor ? steelseries.ColorDef.WHITE : parameters.pointerColor);\n\n        var tweenRoll;\n        var tweenPitch;\n        var repainting = false;\n        var roll = 0;\n        var pitch = 0;\n        var pitchPixel = (PI * size) / 360;\n        var pitchOffset = 0;\n        var upsidedown = false;\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (size === 0) {\n            size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height);\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = size;\n        mainCtx.canvas.height = size;\n\n        var imageWidth = size;\n        var imageHeight = size;\n\n        var centerX = imageWidth / 2;\n        var centerY = imageHeight / 2;\n\n        var initialized = false;\n\n        // **************   Buffer creation  ********************\n        // Buffer for all static background painting code\n        var backgroundBuffer = createBuffer(size, size);\n        var backgroundContext = backgroundBuffer.getContext('2d');\n\n        // Buffer for pointer image painting code\n        var valueBuffer = createBuffer(size, size * PI);\n        var valueContext = valueBuffer.getContext('2d');\n\n        // Buffer for indicator painting code\n        var indicatorBuffer = createBuffer(size * 0.037383, size * 0.056074);\n        var indicatorContext = indicatorBuffer.getContext('2d');\n\n        // Buffer for static foreground painting code\n        var foregroundBuffer = createBuffer(size, size);\n        var foregroundContext = foregroundBuffer.getContext('2d');\n\n        // **************   Image creation  ********************\n        var drawHorizonBackgroundImage = function (ctx) {\n            ctx.save();\n\n            var imgWidth = size;\n            var imgHeight = size * PI;\n            var y;\n\n            // HORIZON\n            ctx.beginPath();\n            ctx.rect(0, 0, imgWidth, imgHeight);\n            ctx.closePath();\n            var HORIZON_GRADIENT = ctx.createLinearGradient(0, 0, 0, imgHeight);\n            HORIZON_GRADIENT.addColorStop(0, '#7fd5f0');\n            HORIZON_GRADIENT.addColorStop(0.5, '#7fd5f0');\n            HORIZON_GRADIENT.addColorStop(0.5, '#3c4439');\n            HORIZON_GRADIENT.addColorStop(1, '#3c4439');\n            ctx.fillStyle = HORIZON_GRADIENT;\n            ctx.fill();\n\n            ctx.lineWidth = 1;\n            var stepSizeY = imgHeight / 360 * 5;\n            var stepTen = false;\n            var step = 10;\n\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            var fontSize = imgWidth * 0.04;\n            ctx.font = fontSize + 'px ' + stdFontName;\n            ctx.fillStyle = '#37596e';\n            for (y = imgHeight / 2 - stepSizeY; y > 0; y -= stepSizeY) {\n                if (step <= 90) {\n                    if (stepTen) {\n                        ctx.fillText(step, (imgWidth - (imgWidth * 0.2)) / 2 - 8, y, imgWidth * 0.375);\n                        ctx.fillText(step, imgWidth - (imgWidth - (imgWidth * 0.2)) / 2 + 8, y, imgWidth * 0.375);\n                        ctx.beginPath();\n                        ctx.moveTo((imgWidth - (imgWidth * 0.2)) / 2, y);\n                        ctx.lineTo(imgWidth - (imgWidth - (imgWidth * 0.2)) / 2, y);\n                        ctx.closePath();\n                        step += 10;\n                    } else {\n                        ctx.beginPath();\n                        ctx.moveTo((imgWidth - (imgWidth * 0.1)) / 2, y);\n                        ctx.lineTo(imgWidth - (imgWidth - (imgWidth * 0.1)) / 2, y);\n                        ctx.closePath();\n                    }\n                    ctx.stroke();\n                }\n                stepTen ^= true;\n            }\n            stepTen = false;\n            step = 10;\n            ctx.strokeStyle = '#FFFFFF';\n            ctx.lineWidth = 1.5;\n            ctx.beginPath();\n            ctx.moveTo(0, imgHeight / 2);\n            ctx.lineTo(imgWidth, imgHeight / 2);\n            ctx.closePath();\n            ctx.stroke();\n            ctx.fillStyle = '#FFFFFF';\n            ctx.lineWidth = 1;\n            for (y = imgHeight / 2 + stepSizeY; y <= imgHeight; y += stepSizeY) {\n                if (step <= 90) {\n                    if (stepTen) {\n                        ctx.fillText(-step, (imgWidth - (imgWidth * 0.2)) / 2 - 8, y, imgWidth * 0.375);\n                        ctx.fillText(-step, imgWidth - (imgWidth - (imgWidth * 0.2)) / 2 + 8, y, imgWidth * 0.375);\n                        ctx.beginPath();\n                        ctx.moveTo((imgWidth - (imgWidth * 0.2)) / 2, y);\n                        ctx.lineTo(imgWidth - (imgWidth - (imgWidth * 0.2)) / 2, y);\n                        ctx.closePath();\n                        step += 10;\n                    } else {\n                        ctx.beginPath();\n                        ctx.moveTo((imgWidth - (imgWidth * 0.1)) / 2, y);\n                        ctx.lineTo(imgWidth - (imgWidth - (imgWidth * 0.1)) / 2, y);\n                        ctx.closePath();\n                    }\n                    ctx.stroke();\n                }\n                stepTen ^= true;\n            }\n\n            ctx.restore();\n        };\n\n        var drawHorizonForegroundImage = function (ctx) {\n            ctx.save();\n\n            ctx.fillStyle = pointerColor.light.getRgbaColor();\n\n            // CENTERINDICATOR\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.476635, imageHeight * 0.5);\n            ctx.bezierCurveTo(imageWidth * 0.476635, imageHeight * 0.514018, imageWidth * 0.485981, imageHeight * 0.523364, imageWidth * 0.5, imageHeight * 0.523364);\n            ctx.bezierCurveTo(imageWidth * 0.514018, imageHeight * 0.523364, imageWidth * 0.523364, imageHeight * 0.514018, imageWidth * 0.523364, imageHeight * 0.5);\n            ctx.bezierCurveTo(imageWidth * 0.523364, imageHeight * 0.485981, imageWidth * 0.514018, imageHeight * 0.476635, imageWidth * 0.5, imageHeight * 0.476635);\n            ctx.bezierCurveTo(imageWidth * 0.485981, imageHeight * 0.476635, imageWidth * 0.476635, imageHeight * 0.485981, imageWidth * 0.476635, imageHeight * 0.5);\n            ctx.closePath();\n            ctx.moveTo(imageWidth * 0.415887, imageHeight * 0.504672);\n            ctx.lineTo(imageWidth * 0.415887, imageHeight * 0.495327);\n            ctx.bezierCurveTo(imageWidth * 0.415887, imageHeight * 0.495327, imageWidth * 0.467289, imageHeight * 0.495327, imageWidth * 0.467289, imageHeight * 0.495327);\n            ctx.bezierCurveTo(imageWidth * 0.471962, imageHeight * 0.481308, imageWidth * 0.481308, imageHeight * 0.471962, imageWidth * 0.495327, imageHeight * 0.467289);\n            ctx.bezierCurveTo(imageWidth * 0.495327, imageHeight * 0.467289, imageWidth * 0.495327, imageHeight * 0.415887, imageWidth * 0.495327, imageHeight * 0.415887);\n            ctx.lineTo(imageWidth * 0.504672, imageHeight * 0.415887);\n            ctx.bezierCurveTo(imageWidth * 0.504672, imageHeight * 0.415887, imageWidth * 0.504672, imageHeight * 0.467289, imageWidth * 0.504672, imageHeight * 0.467289);\n            ctx.bezierCurveTo(imageWidth * 0.518691, imageHeight * 0.471962, imageWidth * 0.528037, imageHeight * 0.481308, imageWidth * 0.532710, imageHeight * 0.495327);\n            ctx.bezierCurveTo(imageWidth * 0.532710, imageHeight * 0.495327, imageWidth * 0.584112, imageHeight * 0.495327, imageWidth * 0.584112, imageHeight * 0.495327);\n            ctx.lineTo(imageWidth * 0.584112, imageHeight * 0.504672);\n            ctx.bezierCurveTo(imageWidth * 0.584112, imageHeight * 0.504672, imageWidth * 0.532710, imageHeight * 0.504672, imageWidth * 0.532710, imageHeight * 0.504672);\n            ctx.bezierCurveTo(imageWidth * 0.528037, imageHeight * 0.518691, imageWidth * 0.518691, imageHeight * 0.532710, imageWidth * 0.5, imageHeight * 0.532710);\n            ctx.bezierCurveTo(imageWidth * 0.481308, imageHeight * 0.532710, imageWidth * 0.471962, imageHeight * 0.518691, imageWidth * 0.467289, imageHeight * 0.504672);\n            ctx.bezierCurveTo(imageWidth * 0.467289, imageHeight * 0.504672, imageWidth * 0.415887, imageHeight * 0.504672, imageWidth * 0.415887, imageHeight * 0.504672);\n            ctx.closePath();\n            ctx.fill();\n\n            // Tickmarks\n            var step = 5;\n            var stepRad = 5 * RAD_FACTOR;\n            ctx.translate(centerX, centerY);\n            ctx.rotate(-HALF_PI);\n            ctx.translate(-centerX, -centerY);\n            var angle;\n            for (angle = -90; angle <= 90; angle += step) {\n                if (angle % 45 === 0 || angle === 0) {\n                    ctx.strokeStyle = pointerColor.medium.getRgbaColor();\n                    ctx.lineWidth = 2;\n                    ctx.beginPath();\n                    ctx.moveTo(imageWidth * 0.5, imageHeight * 0.088785);\n                    ctx.lineTo(imageWidth * 0.5, imageHeight * 0.113);\n                    ctx.closePath();\n                    ctx.stroke();\n                } else if (angle % 15 === 0) {\n                    ctx.strokeStyle = '#FFFFFF';\n                    ctx.lineWidth = 1;\n                    ctx.beginPath();\n                    ctx.moveTo(imageWidth * 0.5, imageHeight * 0.088785);\n                    ctx.lineTo(imageWidth * 0.5, imageHeight * 0.103785);\n                    ctx.closePath();\n                    ctx.stroke();\n                } else {\n                    ctx.strokeStyle = '#FFFFFF';\n                    ctx.lineWidth = 0.5;\n                    ctx.beginPath();\n                    ctx.moveTo(imageWidth * 0.5, imageHeight * 0.088785);\n                    ctx.lineTo(imageWidth * 0.5, imageHeight * 0.093785);\n                    ctx.closePath();\n                    ctx.stroke();\n                }\n                ctx.translate(centerX, centerY);\n                ctx.rotate(stepRad, centerX, centerY);\n                ctx.translate(-centerX, -centerY);\n            }\n\n            ctx.restore();\n        };\n\n        var drawIndicatorImage = function (ctx) {\n            ctx.save();\n\n            var imgWidth = imageWidth * 0.037383;\n            var imgHeight = imageHeight * 0.056074;\n\n            ctx.beginPath();\n            ctx.moveTo(imgWidth * 0.5, 0);\n            ctx.lineTo(0, imgHeight);\n            ctx.lineTo(imgWidth, imgHeight);\n            ctx.closePath();\n\n            ctx.fillStyle = pointerColor.light.getRgbaColor();\n            ctx.fill();\n            ctx.strokeStyle = pointerColor.medium.getRgbaColor();\n            ctx.stroke();\n\n            ctx.restore();\n        };\n\n        // **************   Initialization  ********************\n        // Draw all static painting code to background\n        var init = function () {\n            initialized = true;\n\n            if (frameVisible) {\n                drawRadialFrameImage(backgroundContext, frameDesign, centerX, centerY, imageWidth, imageHeight);\n            }\n\n            drawHorizonBackgroundImage(valueContext);\n\n            drawIndicatorImage(indicatorContext);\n\n            drawHorizonForegroundImage(foregroundContext);\n\n            if (foregroundVisible) {\n                drawRadialForegroundImage(foregroundContext, foregroundType, imageWidth, imageHeight, true, knobType, knobStyle, gaugeType);\n            }\n        };\n\n        var resetBuffers = function () {\n            // Buffer for all static background painting code\n            backgroundBuffer.width = size;\n            backgroundBuffer.height = size;\n            backgroundContext = backgroundBuffer.getContext('2d');\n\n            // Buffer for pointer image painting code\n            valueBuffer.width = size;\n            valueBuffer.height = size * PI;\n            valueContext = valueBuffer.getContext('2d');\n\n            // Buffer for the indicator\n            indicatorBuffer.width = size * 0.037383;\n            indicatorBuffer.height = size * 0.056074;\n            indicatorContext = indicatorBuffer.getContext('2d');\n\n            // Buffer for static foreground painting code\n            foregroundBuffer.width = size;\n            foregroundBuffer.height = size;\n            foregroundContext = foregroundBuffer.getContext('2d');\n        };\n\n        //************************************ Public methods **************************************\n        this.setRoll = function (newRoll) {\n            newRoll = parseFloat(newRoll) % 360;\n            if (roll !== newRoll) {\n                roll = newRoll;\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getRoll = function () {\n            return roll;\n        };\n\n        this.setRollAnimated = function (newRoll, callback) {\n            var gauge = this;\n            newRoll = parseFloat(newRoll) % 360;\n            if (roll !== newRoll) {\n\n                if (undefined !== tweenRoll && tweenRoll.isPlaying) {\n                    tweenRoll.stop();\n                }\n\n                tweenRoll = new Tween({}, '', Tween.regularEaseInOut, roll, newRoll, 1);\n\n                tweenRoll.onMotionChanged = function (event) {\n                    roll = event.target._pos;\n                    if (!repainting) {\n                        repainting = true;\n                        requestAnimFrame(gauge.repaint);\n                    }\n                };\n\n                // do we have a callback function to process?\n                if (callback && typeof(callback) === \"function\") {\n                    tweenRoll.onMotionFinished = callback;\n                }\n\n                tweenRoll.start();\n            }\n            return this;\n        };\n\n        this.setPitch = function (newPitch) {\n            // constrain to range -180..180\n            // normal range -90..90 and -180..-90/90..180 indicate inverted\n            newPitch = ((parseFloat(newPitch) + 180 - pitchOffset) % 360) - 180;\n            //pitch = -(newPitch + pitchOffset) % 180;\n            if (pitch !== newPitch) {\n                pitch = newPitch;\n                if (pitch > 90) {\n                    pitch = 90 - (pitch - 90);\n                    if (!upsidedown) {\n                        this.setRoll(roll - 180);\n                    }\n                    upsidedown = true;\n                } else if (pitch < -90) {\n                    pitch = -90 + (-90 - pitch);\n                    if (!upsidedown) {\n                        this.setRoll(roll + 180);\n                    }\n                    upsidedown = true;\n                } else {\n                    upsidedown = false;\n                }\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getPitch = function () {\n            return pitch;\n        };\n\n        this.setPitchAnimated = function (newPitch, callback) {\n            var gauge = this;\n            newPitch = parseFloat(newPitch);\n            // perform all range checking in setPitch()\n            if (pitch !== newPitch) {\n                if (undefined !== tweenPitch && tweenPitch.isPlaying) {\n                    tweenPitch.stop();\n                }\n                tweenPitch = new Tween({}, '', Tween.regularEaseInOut, pitch, newPitch, 1);\n                tweenPitch.onMotionChanged = function (event) {\n                    pitch = event.target._pos;\n                    if (pitch > 90) {\n                        pitch = 90 - (pitch - 90);\n                        if (!upsidedown) {\n                            this.setRoll(roll - 180);\n                        }\n                        upsidedown = true;\n                    } else if (pitch < -90) {\n                        pitch = -90 + (-90 - pitch);\n                        if (!upsidedown) {\n                            this.setRoll(roll + 180);\n                        }\n                        upsidedown = true;\n                    } else {\n                        upsidedown = false;\n                    }\n                    if (!repainting) {\n                        repainting = true;\n                        requestAnimFrame(gauge.repaint);\n                    }\n                    gauge.setPitch(event.target._pos);\n                };\n\n                // do we have a callback function to process?\n                if (callback && typeof(callback) === \"function\") {\n                    tweenPitch.onMotionFinished = callback;\n                }\n\n                tweenPitch.start();\n            }\n            return this;\n        };\n\n        this.setPitchOffset = function (newPitchOffset) {\n            pitchOffset = parseFloat(newPitchOffset);\n            this.repaint();\n            return this;\n        };\n\n        this.setFrameDesign = function (newFrameDesign) {\n            resetBuffers();\n            frameDesign = newFrameDesign;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.setForegroundType = function (newForegroundType) {\n            resetBuffers();\n            foregroundType = newForegroundType;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init();\n            }\n\n            mainCtx.save();\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n\n            mainCtx.drawImage(backgroundBuffer, 0, 0);\n\n            mainCtx.save();\n\n            // Set the clipping area\n            mainCtx.beginPath();\n            mainCtx.arc(centerX, centerY, imageWidth * 0.831775 / 2, 0, TWO_PI, true);\n            mainCtx.closePath();\n            mainCtx.clip();\n\n            // Rotate around roll\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate(-(roll * RAD_FACTOR));\n            mainCtx.translate(-centerX, 0);\n            // Translate about dive\n            mainCtx.translate(0, (pitch * pitchPixel));\n\n            // Draw horizon\n            mainCtx.drawImage(valueBuffer, 0, -valueBuffer.height / 2);\n\n            // Draw the scale and angle indicator\n            mainCtx.translate(0, -(pitch * pitchPixel) - centerY);\n            mainCtx.drawImage(indicatorBuffer, (imageWidth * 0.5 - indicatorBuffer.width / 2), (imageWidth * 0.107476));\n            mainCtx.restore();\n\n            mainCtx.drawImage(foregroundBuffer, 0, 0);\n\n            mainCtx.restore();\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var led = function (canvas, parameters) {\n        parameters = parameters || {};\n        var size = (undefined === parameters.size ? 0 : parameters.size),\n            ledColor = (undefined === parameters.ledColor ? steelseries.LedColor.RED_LED : parameters.ledColor);\n\n        var ledBlinking = false;\n        var ledTimerId = 0;\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (size === 0) {\n            size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height);\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = size;\n        mainCtx.canvas.height = size;\n\n        var initialized = false;\n\n        // Buffer for led on painting code\n        var ledBufferOn = doc.createElement('canvas');\n        ledBufferOn.width = size;\n        ledBufferOn.height = size;\n        var ledContextOn = ledBufferOn.getContext('2d');\n\n        // Buffer for led off painting code\n        var ledBufferOff = doc.createElement('canvas');\n        ledBufferOff.width = size;\n        ledBufferOff.height = size;\n        var ledContextOff = ledBufferOff.getContext('2d');\n\n        // Buffer for current led painting code\n        var ledBuffer = ledBufferOff;\n\n        var init = function () {\n            initialized = true;\n\n            // Draw LED ON in ledBuffer_ON\n            ledContextOn.clearRect(0, 0, ledContextOn.canvas.width, ledContextOn.canvas.height);\n            ledContextOn.drawImage(createLedImage(size, 1, ledColor), 0, 0);\n\n            // Draw LED ON in ledBuffer_OFF\n            ledContextOff.clearRect(0, 0, ledContextOff.canvas.width, ledContextOff.canvas.height);\n            ledContextOff.drawImage(createLedImage(size, 0, ledColor), 0, 0);\n        };\n\n        this.toggleLed = function () {\n            if (ledBuffer === ledBufferOn) {\n                ledBuffer = ledBufferOff;\n            } else {\n                ledBuffer = ledBufferOn;\n            }\n            repaint();\n            return this;\n        };\n\n        this.setLedColor = function (newColor) {\n            ledColor = newColor;\n            initialized = false;\n            repaint();\n            return this;\n        };\n\n        this.setLedOnOff = function (on) {\n            if (!!on) {\n                ledBuffer = ledBufferOn;\n            } else {\n                ledBuffer = ledBufferOff;\n            }\n            repaint();\n            return this;\n        };\n\n        this.blink = function (blink) {\n            if (!!blink) {\n                if (!ledBlinking) {\n                    ledTimerId = setInterval(this.toggleLed, 1000);\n                    ledBlinking = true;\n                }\n            } else {\n                if (ledBlinking) {\n                    clearInterval(ledTimerId);\n                    ledBlinking = false;\n                    ledBuffer = ledBufferOff;\n                }\n            }\n            return this;\n        };\n\n        var repaint = function () {\n            if (!initialized) {\n                init();\n            }\n\n            mainCtx.save();\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n\n            mainCtx.drawImage(ledBuffer, 0, 0);\n\n            mainCtx.restore();\n        };\n\n        repaint();\n\n        return this;\n    };\n\n    var clock = function (canvas, parameters) {\n        parameters = parameters || {};\n        var size = (undefined === parameters.size ? 0 : parameters.size),\n            frameDesign = (undefined === parameters.frameDesign ? steelseries.FrameDesign.METAL : parameters.frameDesign),\n            frameVisible = (undefined === parameters.frameVisible ? true : parameters.frameVisible),\n            pointerType = (undefined === parameters.pointerType ? steelseries.PointerType.TYPE1 : parameters.pointerType),\n            pointerColor = (undefined === parameters.pointerColor ? (pointerType === steelseries.PointerType.TYPE1 ? steelseries.ColorDef.GRAY : steelseries.ColorDef.BLACK) : parameters.pointerColor),\n            backgroundColor = (undefined === parameters.backgroundColor ? (pointerType === steelseries.PointerType.TYPE1 ? steelseries.BackgroundColor.ANTHRACITE : steelseries.BackgroundColor.LIGHT_GRAY) : parameters.backgroundColor),\n            backgroundVisible = (undefined === parameters.backgroundVisible ? true : parameters.backgroundVisible),\n            foregroundType = (undefined === parameters.foregroundType ? steelseries.ForegroundType.TYPE1 : parameters.foregroundType),\n            foregroundVisible = (undefined === parameters.foregroundVisible ? true : parameters.foregroundVisible),\n            customLayer = (undefined === parameters.customLayer ? null : parameters.customLayer),\n            isAutomatic = (undefined === parameters.isAutomatic ? true : parameters.isAutomatic),\n            hour = (undefined === parameters.hour ? 11 : parameters.hour),\n            minute = (undefined === parameters.minute ? 5 : parameters.minute),\n            second = (undefined === parameters.second ? 0 : parameters.second),\n            secondMovesContinuous = (undefined === parameters.secondMovesContinuous ? false : parameters.secondMovesContinuous),\n            timeZoneOffsetHour = (undefined === parameters.timeZoneOffsetHour ? 0 : parameters.timeZoneOffsetHour),\n            timeZoneOffsetMinute = (undefined === parameters.timeZoneOffsetMinute ? 0 : parameters.timeZoneOffsetMinute),\n            secondPointerVisible = (undefined === parameters.secondPointerVisible ? true : parameters.secondPointerVisible);\n\n        // GaugeType specific private variables\n        var objDate = new Date();\n        var minutePointerAngle;\n        var hourPointerAngle;\n        var secondPointerAngle;\n        var tickTimer;\n        var tickInterval = (secondMovesContinuous ? 100 : 1000);\n        tickInterval = (secondPointerVisible ? tickInterval : 100);\n\n        var self = this;\n\n        // Constants\n        var ANGLE_STEP = 6;\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n        // Has a size been specified?\n        if (size === 0) {\n            size = Math.min(mainCtx.canvas.width, mainCtx.canvas.height);\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = size;\n        mainCtx.canvas.height = size;\n\n        var imageWidth = size;\n        var imageHeight = size;\n\n        var centerX = imageWidth / 2;\n        var centerY = imageHeight / 2;\n\n        var initialized = false;\n\n        // Buffer for the frame\n        var frameBuffer = createBuffer(size, size);\n        var frameContext = frameBuffer.getContext('2d');\n\n        // Buffer for static background painting code\n        var backgroundBuffer = createBuffer(size, size);\n        var backgroundContext = backgroundBuffer.getContext('2d');\n\n        // Buffer for hour pointer image painting code\n        var hourBuffer = createBuffer(size, size);\n        var hourContext = hourBuffer.getContext('2d');\n\n        // Buffer for minute pointer image painting code\n        var minuteBuffer = createBuffer(size, size);\n        var minuteContext = minuteBuffer.getContext('2d');\n\n        // Buffer for second pointer image painting code\n        var secondBuffer = createBuffer(size, size);\n        var secondContext = secondBuffer.getContext('2d');\n\n        // Buffer for static foreground painting code\n        var foregroundBuffer = createBuffer(size, size);\n        var foregroundContext = foregroundBuffer.getContext('2d');\n\n        var drawTickmarksImage = function (ctx, ptrType) {\n            var tickAngle;\n            var SMALL_TICK_HEIGHT;\n            var BIG_TICK_HEIGHT;\n            var OUTER_POINT, INNER_POINT;\n            OUTER_POINT = imageWidth * 0.405;\n            ctx.save();\n            ctx.translate(centerX, centerY);\n\n            switch (ptrType.type) {\n            case 'type1':\n                // Draw minutes tickmarks\n                SMALL_TICK_HEIGHT = imageWidth * 0.074766;\n                INNER_POINT = OUTER_POINT - SMALL_TICK_HEIGHT;\n                ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n                ctx.lineWidth = imageWidth * 0.014018;\n\n                for (tickAngle = 0; tickAngle < 360; tickAngle += 30) {\n                    ctx.beginPath();\n                    ctx.moveTo(OUTER_POINT, 0);\n                    ctx.lineTo(INNER_POINT, 0);\n                    ctx.closePath();\n                    ctx.stroke();\n                    ctx.rotate(30 * RAD_FACTOR);\n                }\n\n                // Draw hours tickmarks\n                BIG_TICK_HEIGHT = imageWidth * 0.126168;\n                INNER_POINT = OUTER_POINT - BIG_TICK_HEIGHT;\n                ctx.lineWidth = imageWidth * 0.032710;\n\n                for (tickAngle = 0; tickAngle < 360; tickAngle += 90) {\n                    ctx.beginPath();\n                    ctx.moveTo(OUTER_POINT, 0);\n                    ctx.lineTo(INNER_POINT, 0);\n                    ctx.closePath();\n                    ctx.stroke();\n                    ctx.rotate(90 * RAD_FACTOR);\n                }\n                break;\n\n            case 'type2':\n            /* falls through */\n            default:\n                // Draw minutes tickmarks\n                SMALL_TICK_HEIGHT = imageWidth * 0.037383;\n                INNER_POINT = OUTER_POINT - SMALL_TICK_HEIGHT;\n                ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n                ctx.lineWidth = imageWidth * 0.009345;\n\n                for (tickAngle = 0; tickAngle < 360; tickAngle += 6) {\n                    ctx.beginPath();\n                    ctx.moveTo(OUTER_POINT, 0);\n                    ctx.lineTo(INNER_POINT, 0);\n                    ctx.closePath();\n                    ctx.stroke();\n                    ctx.rotate(6 * RAD_FACTOR);\n                }\n\n                // Draw hours tickmarks\n                BIG_TICK_HEIGHT = imageWidth * 0.084112;\n                INNER_POINT = OUTER_POINT - BIG_TICK_HEIGHT;\n                ctx.lineWidth = imageWidth * 0.028037;\n\n                for (tickAngle = 0; tickAngle < 360; tickAngle += 30) {\n                    ctx.beginPath();\n                    ctx.moveTo(OUTER_POINT, 0);\n                    ctx.lineTo(INNER_POINT, 0);\n                    ctx.closePath();\n                    ctx.stroke();\n                    ctx.rotate(30 * RAD_FACTOR);\n                }\n                break;\n            }\n            ctx.translate(-centerX, -centerY);\n            ctx.restore();\n        };\n\n        var drawHourPointer = function (ctx, ptrType) {\n            ctx.save();\n            var grad;\n\n            switch (ptrType.type) {\n            case 'type2':\n                ctx.beginPath();\n                ctx.lineWidth = imageWidth * 0.046728;\n                ctx.moveTo(centerX, imageWidth * 0.289719);\n                ctx.lineTo(centerX, imageWidth * 0.289719 + imageWidth * 0.224299);\n                ctx.strokeStyle = pointerColor.medium.getRgbaColor();\n                ctx.closePath();\n                ctx.stroke();\n                break;\n\n            case 'type1':\n            /* falls through */\n            default:\n                ctx.beginPath();\n                ctx.moveTo(imageWidth * 0.471962, imageHeight * 0.560747);\n                ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.214953);\n                ctx.lineTo(imageWidth * 0.5, imageHeight * 0.182242);\n                ctx.lineTo(imageWidth * 0.528037, imageHeight * 0.214953);\n                ctx.lineTo(imageWidth * 0.528037, imageHeight * 0.560747);\n                ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.560747);\n                ctx.closePath();\n                grad = ctx.createLinearGradient(imageWidth * 0.471962, imageHeight * 0.560747, imageWidth * 0.528037, imageHeight * 0.214953);\n                grad.addColorStop(1, pointerColor.veryLight.getRgbaColor());\n                grad.addColorStop(0, pointerColor.light.getRgbaColor());\n                ctx.fillStyle = grad;\n                ctx.strokeStyle = pointerColor.light.getRgbaColor();\n                ctx.fill();\n                ctx.stroke();\n                break;\n            }\n            ctx.restore();\n        };\n\n        var drawMinutePointer = function (ctx, ptrType) {\n            ctx.save();\n            var grad;\n\n            switch (ptrType.type) {\n            case 'type2':\n                ctx.beginPath();\n                ctx.lineWidth = imageWidth * 0.032710;\n                ctx.moveTo(centerX, imageWidth * 0.116822);\n                ctx.lineTo(centerX, imageWidth * 0.116822 + imageWidth * 0.387850);\n                ctx.strokeStyle = pointerColor.medium.getRgbaColor();\n                ctx.closePath();\n                ctx.stroke();\n                break;\n\n            case 'type1':\n            /* falls through */\n            default:\n                ctx.beginPath();\n                ctx.moveTo(imageWidth * 0.518691, imageHeight * 0.574766);\n                ctx.lineTo(imageWidth * 0.523364, imageHeight * 0.135514);\n                ctx.lineTo(imageWidth * 0.5, imageHeight * 0.107476);\n                ctx.lineTo(imageWidth * 0.476635, imageHeight * 0.140186);\n                ctx.lineTo(imageWidth * 0.476635, imageHeight * 0.574766);\n                ctx.lineTo(imageWidth * 0.518691, imageHeight * 0.574766);\n                ctx.closePath();\n                grad = ctx.createLinearGradient(imageWidth * 0.518691, imageHeight * 0.574766, imageWidth * 0.476635, imageHeight * 0.140186);\n                grad.addColorStop(1, pointerColor.veryLight.getRgbaColor());\n                grad.addColorStop(0, pointerColor.light.getRgbaColor());\n                ctx.fillStyle = grad;\n                ctx.strokeStyle = pointerColor.light.getRgbaColor();\n                ctx.fill();\n                ctx.stroke();\n                break;\n            }\n            ctx.restore();\n        };\n\n        var drawSecondPointer = function (ctx, ptrType) {\n            ctx.save();\n            var grad;\n\n            switch (ptrType.type) {\n            case 'type2':\n                // top rectangle\n                ctx.lineWidth = imageWidth * 0.009345;\n                ctx.beginPath();\n                ctx.moveTo(centerX, imageWidth * 0.098130);\n                ctx.lineTo(centerX, imageWidth * 0.098130 + imageWidth * 0.126168);\n                ctx.closePath();\n                ctx.stroke();\n                // bottom rectangle\n                ctx.lineWidth = imageWidth * 0.018691;\n                ctx.beginPath();\n                ctx.moveTo(centerX, imageWidth * 0.308411);\n                ctx.lineTo(centerX, imageWidth * 0.308411 + imageWidth * 0.191588);\n                ctx.closePath();\n                ctx.stroke();\n                // circle\n                ctx.lineWidth = imageWidth * 0.016;\n                ctx.beginPath();\n                ctx.arc(centerX, imageWidth * 0.26, imageWidth * 0.085 / 2, 0, TWO_PI);\n                ctx.closePath();\n                ctx.stroke();\n                break;\n\n            case 'type1':\n            /* falls through */\n            default:\n                ctx.beginPath();\n                ctx.moveTo(imageWidth * 0.509345, imageHeight * 0.116822);\n                ctx.lineTo(imageWidth * 0.509345, imageHeight * 0.574766);\n                ctx.lineTo(imageWidth * 0.490654, imageHeight * 0.574766);\n                ctx.lineTo(imageWidth * 0.490654, imageHeight * 0.116822);\n                ctx.lineTo(imageWidth * 0.509345, imageHeight * 0.116822);\n                ctx.closePath();\n                grad = ctx.createLinearGradient(imageWidth * 0.509345, imageHeight * 0.116822, imageWidth * 0.490654, imageHeight * 0.574766);\n                grad.addColorStop(0, steelseries.ColorDef.RED.light.getRgbaColor());\n                grad.addColorStop(0.47, steelseries.ColorDef.RED.medium.getRgbaColor());\n                grad.addColorStop(1, steelseries.ColorDef.RED.dark.getRgbaColor());\n                ctx.fillStyle = grad;\n                ctx.strokeStyle = steelseries.ColorDef.RED.dark.getRgbaColor();\n                ctx.fill();\n                ctx.stroke();\n                break;\n            }\n            ctx.restore();\n        };\n\n        var drawKnob = function (ctx) {\n            var grad;\n\n            // draw the knob\n            ctx.beginPath();\n            ctx.arc(centerX, centerY, imageWidth * 0.045, 0, TWO_PI);\n            ctx.closePath();\n            grad = ctx.createLinearGradient(centerX - imageWidth * 0.045 / 2, centerY - imageWidth * 0.045 / 2, centerX + imageWidth * 0.045 / 2, centerY + imageWidth * 0.045 / 2);\n            grad.addColorStop(0, '#eef0f2');\n            grad.addColorStop(1, '#65696d');\n            ctx.fillStyle = grad;\n            ctx.fill();\n        };\n\n        var drawTopKnob = function (ctx, ptrType) {\n            var grad;\n\n            ctx.save();\n\n            switch (ptrType.type) {\n            case 'type2':\n                // draw knob\n                ctx.fillStyle = '#000000';\n                ctx.beginPath();\n                ctx.arc(centerX, centerY, imageWidth * 0.088785 / 2, 0, TWO_PI);\n                ctx.closePath();\n                ctx.fill();\n                break;\n\n            case 'type1':\n            /* falls through */\n            default:\n                // draw knob\n                grad = ctx.createLinearGradient(centerX - imageWidth * 0.027 / 2, centerY - imageWidth * 0.027 / 2, centerX + imageWidth * 0.027 / 2, centerY + imageWidth * 0.027 / 2);\n                grad.addColorStop(0, '#f3f4f7');\n                grad.addColorStop(0.11, '#f3f5f7');\n                grad.addColorStop(0.12, '#f1f3f5');\n                grad.addColorStop(0.2, '#c0c5cb');\n                grad.addColorStop(0.2, '#bec3c9');\n                grad.addColorStop(1, '#bec3c9');\n                ctx.fillStyle = grad;\n                ctx.beginPath();\n                ctx.arc(centerX, centerY, imageWidth * 0.027, 0, TWO_PI);\n                ctx.closePath();\n                ctx.fill();\n                break;\n            }\n\n            ctx.restore();\n        };\n\n        var calculateAngles = function (hour, minute, second) {\n            secondPointerAngle = second * ANGLE_STEP * RAD_FACTOR;\n            minutePointerAngle = minute * ANGLE_STEP * RAD_FACTOR;\n            hourPointerAngle = (hour + minute / 60) * ANGLE_STEP * 5 * RAD_FACTOR;\n        };\n\n        var tickTock = function () {\n            if (isAutomatic) {\n                objDate = new Date();\n            } else {\n                objDate.setHours(hour);\n                objDate.setMinutes(minute);\n                objDate.setSeconds(second);\n            }\n            // Seconds\n            second = objDate.getSeconds() + (secondMovesContinuous ? objDate.getMilliseconds() / 1000 : 0);\n\n            // Hours\n            if (timeZoneOffsetHour !== 0 && timeZoneOffsetMinute !== 0) {\n                hour = objDate.getUTCHours() + timeZoneOffsetHour;\n            } else {\n                hour = objDate.getHours();\n            }\n            hour = hour % 12;\n\n            // Minutes\n            if (timeZoneOffsetHour !== 0 && timeZoneOffsetMinute !== 0) {\n                minute = objDate.getUTCMinutes() + timeZoneOffsetMinute;\n            } else {\n                minute = objDate.getMinutes();\n            }\n            if (minute > 60) {\n                minute -= 60;\n                hour++;\n            }\n            if (minute < 0) {\n                minute += 60;\n                hour--;\n            }\n            hour = hour % 12;\n            // Calculate angles from current hour and minute values\n            calculateAngles(hour, minute, second);\n\n            if (isAutomatic) {\n                tickTimer = setTimeout(tickTock, tickInterval);\n            }\n\n            self.repaint();\n        };\n\n        // **************   Initialization  ********************\n        // Draw all static painting code to background\n        var init = function (parameters) {\n            parameters = parameters || {};\n            var drawFrame = (undefined === parameters.frame ? false : parameters.frame);\n            var drawBackground = (undefined === parameters.background ? false : parameters.background);\n            var drawPointers = (undefined === parameters.pointers ? false : parameters.pointers);\n            var drawForeground = (undefined === parameters.foreground ? false : parameters.foreground);\n\n            initialized = true;\n\n            if (drawFrame && frameVisible) {\n                drawRadialFrameImage(frameContext, frameDesign, centerX, centerY, imageWidth, imageHeight);\n            }\n\n            if (drawBackground && backgroundVisible) {\n                // Create background in background buffer (backgroundBuffer)\n                drawRadialBackgroundImage(backgroundContext, backgroundColor, centerX, centerY, imageWidth, imageHeight);\n\n                // Create custom layer in background buffer (backgroundBuffer)\n                drawRadialCustomImage(backgroundContext, customLayer, centerX, centerY, imageWidth, imageHeight);\n\n                drawTickmarksImage(backgroundContext, pointerType);\n            }\n\n            if (drawPointers) {\n                drawHourPointer(hourContext, pointerType);\n                drawMinutePointer(minuteContext, pointerType);\n                drawSecondPointer(secondContext, pointerType);\n            }\n\n            if (drawForeground && foregroundVisible) {\n                drawTopKnob(foregroundContext, pointerType);\n                drawRadialForegroundImage(foregroundContext, foregroundType, imageWidth, imageHeight, false);\n            }\n        };\n\n        var resetBuffers = function (buffers) {\n            buffers = buffers || {};\n            var resetFrame = (undefined === buffers.frame ? false : buffers.frame);\n            var resetBackground = (undefined === buffers.background ? false : buffers.background);\n            var resetPointers = (undefined === buffers.pointers ? false : buffers.pointers);\n            var resetForeground = (undefined === buffers.foreground ? false : buffers.foreground);\n\n            if (resetFrame) {\n                frameBuffer.width = size;\n                frameBuffer.height = size;\n                frameContext = frameBuffer.getContext('2d');\n            }\n\n            if (resetBackground) {\n                backgroundBuffer.width = size;\n                backgroundBuffer.height = size;\n                backgroundContext = backgroundBuffer.getContext('2d');\n            }\n\n            if (resetPointers) {\n                hourBuffer.width = size;\n                hourBuffer.height = size;\n                hourContext = hourBuffer.getContext('2d');\n\n                minuteBuffer.width = size;\n                minuteBuffer.height = size;\n                minuteContext = minuteBuffer.getContext('2d');\n\n                secondBuffer.width = size;\n                secondBuffer.height = size;\n                secondContext = secondBuffer.getContext('2d');\n            }\n\n            if (resetForeground) {\n                foregroundBuffer.width = size;\n                foregroundBuffer.height = size;\n                foregroundContext = foregroundBuffer.getContext('2d');\n            }\n        };\n\n        //************************************ Public methods **************************************\n        this.getAutomatic = function () {\n            return isAutomatic;\n        };\n\n        this.setAutomatic = function (newValue) {\n            newValue = !!newValue;\n            if (isAutomatic && !newValue) {\n                // stop the clock!\n                clearTimeout(tickTimer);\n                isAutomatic = newValue;\n            } else if (!isAutomatic && newValue) {\n                // start the clock\n                isAutomatic = newValue;\n                tickTock();\n            }\n            return this;\n        };\n\n        this.getHour = function () {\n            return hour;\n        };\n\n        this.setHour = function (newValue) {\n            newValue = parseInt(newValue, 10) % 12;\n            if (hour !== newValue) {\n                hour = newValue;\n                calculateAngles(hour, minute, second);\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getMinute = function () {\n            return minute;\n        };\n\n        this.setMinute = function (newValue) {\n            newValue = parseInt(newValue, 10) % 60;\n            if (minute !== newValue) {\n                minute = newValue;\n                calculateAngles(hour, minute, second);\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getSecond = function () {\n            return second;\n        };\n\n        this.setSecond = function (newValue) {\n            second = parseInt(newValue, 10) % 60;\n            if (second !== newValue) {\n                second = newValue;\n                calculateAngles(hour, minute, second);\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getTimeZoneOffsetHour = function () {\n            return timeZoneOffsetHour;\n        };\n\n        this.setTimeZoneOffsetHour = function (newValue) {\n            timeZoneOffsetHour = parseInt(newValue, 10);\n            this.repaint();\n            return this;\n        };\n\n        this.getTimeZoneOffsetMinute = function () {\n            return timeZoneOffsetMinute;\n        };\n\n        this.setTimeZoneOffsetMinute = function (newValue) {\n            timeZoneOffsetMinute = parseInt(newValue, 10);\n            this.repaint();\n            return this;\n        };\n\n        this.getSecondPointerVisible = function () {\n            return secondPointerVisible;\n        };\n\n        this.setSecondPointerVisible = function (newValue) {\n            secondPointerVisible = !!newValue;\n            this.repaint();\n            return this;\n        };\n\n        this.getSecondMovesContinuous = function () {\n            return secondMovesContinuous;\n        };\n\n        this.setSecondMovesContinuous = function (newValue) {\n            secondMovesContinuous = !!newValue;\n            tickInterval = (secondMovesContinuous ? 100 : 1000);\n            tickInterval = (secondPointerVisible ? tickInterval : 100);\n            return this;\n        };\n\n        this.setFrameDesign = function (newFrameDesign) {\n            resetBuffers({frame: true});\n            frameDesign = newFrameDesign;\n            init({frame: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setBackgroundColor = function (newBackgroundColor) {\n            resetBuffers({ frame: true,\n                           background: true });\n            backgroundColor = newBackgroundColor;\n            init({ frame: true,\n                   background: true });\n            this.repaint();\n            return this;\n        };\n\n        this.setForegroundType = function (newForegroundType) {\n            resetBuffers({foreground: true});\n            foregroundType = newForegroundType;\n            init({foreground: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerType = function (newPointerType) {\n            resetBuffers({ background: true,\n                           foreground: true,\n                           pointers: true });\n            pointerType = newPointerType;\n            if (pointerType.type === 'type1') {\n                pointerColor = steelseries.ColorDef.GRAY;\n                backgroundColor = steelseries.BackgroundColor.ANTHRACITE;\n            } else {\n                pointerColor = steelseries.ColorDef.BLACK;\n                backgroundColor = steelseries.BackgroundColor.LIGHT_GRAY;\n            }\n            init({ background: true,\n                   foreground: true,\n                   pointers: true });\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerColor = function (newPointerColor) {\n            resetBuffers({pointers: true});\n            pointerColor = newPointerColor;\n            init({pointers: true});\n            this.repaint();\n            return this;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init({frame: true,\n                      background: true,\n                      pointers: true,\n                      foreground: true});\n            }\n\n            //mainCtx.save();\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n\n            // Draw frame\n            if (frameVisible) {\n                mainCtx.drawImage(frameBuffer, 0, 0);\n            }\n\n            // Draw buffered image to visible canvas\n            if (backgroundVisible) {\n                mainCtx.drawImage(backgroundBuffer, 0, 0);\n            }\n\n            // have to draw to a rotated temporary image area so we can translate in\n            // absolute x, y values when drawing to main context\n            var shadowOffset = imageWidth * 0.006;\n\n            // draw hour pointer\n            // Define rotation center\n            mainCtx.save();\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate(hourPointerAngle);\n            mainCtx.translate(-centerX, -centerY);\n            // Set the pointer shadow params\n            mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n            mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset;\n            mainCtx.shadowBlur = shadowOffset * 2;\n            // Draw the pointer\n            mainCtx.drawImage(hourBuffer, 0, 0);\n\n            // draw minute pointer\n            // Define rotation center\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate(minutePointerAngle - hourPointerAngle);\n            mainCtx.translate(-centerX, -centerY);\n            mainCtx.drawImage(minuteBuffer, 0, 0);\n            mainCtx.restore();\n\n            if (pointerType.type === 'type1') {\n                drawKnob(mainCtx);\n            }\n\n            if (secondPointerVisible) {\n                // draw second pointer\n                // Define rotation center\n                mainCtx.save();\n                mainCtx.translate(centerX, centerY);\n                mainCtx.rotate(secondPointerAngle);\n                mainCtx.translate(-centerX, -centerY);\n                // Set the pointer shadow params\n                mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n                mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset;\n                mainCtx.shadowBlur = shadowOffset * 2;\n                // Draw the pointer\n                mainCtx.drawImage(secondBuffer, 0, 0);\n                mainCtx.restore();\n            }\n\n            // Draw foreground\n            if (foregroundVisible) {\n                mainCtx.drawImage(foregroundBuffer, 0, 0);\n            }\n        };\n\n        // Visualize the component\n        tickTock();\n\n        return this;\n    };\n\n    var battery = function (canvas, parameters) {\n        parameters = parameters || {};\n        var size = (undefined === parameters.size ? 0 : parameters.size),\n            value = (undefined === parameters.value ? 50 : parameters.value);\n\n        // Get the canvas context and clear it\n        var mainCtx = getCanvasContext(canvas);\n\n        // Has a size been specified?\n        if (size === 0) {\n            size = mainCtx.canvas.width;\n        }\n\n        var imageWidth = size;\n        var imageHeight = Math.ceil(size * 0.45);\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = imageWidth;\n        mainCtx.canvas.height = imageHeight;\n\n        var createBatteryImage = function (ctx, imageWidth, imageHeight, value) {\n            var grad;\n\n            // Background\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.025, imageHeight * 0.055555);\n            ctx.lineTo(imageWidth * 0.9, imageHeight * 0.055555);\n            ctx.lineTo(imageWidth * 0.9, imageHeight * 0.944444);\n            ctx.lineTo(imageWidth * 0.025, imageHeight * 0.944444);\n            ctx.lineTo(imageWidth * 0.025, imageHeight * 0.055555);\n            ctx.closePath();\n            //\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.925, 0);\n            ctx.lineTo(0, 0);\n            ctx.lineTo(0, imageHeight);\n            ctx.lineTo(imageWidth * 0.925, imageHeight);\n            ctx.lineTo(imageWidth * 0.925, imageHeight * 0.722222);\n            ctx.bezierCurveTo(imageWidth * 0.925, imageHeight * 0.722222, imageWidth * 0.975, imageHeight * 0.722222, imageWidth * 0.975, imageHeight * 0.722222);\n            ctx.bezierCurveTo(imageWidth, imageHeight * 0.722222, imageWidth, imageHeight * 0.666666, imageWidth, imageHeight * 0.666666);\n            ctx.bezierCurveTo(imageWidth, imageHeight * 0.666666, imageWidth, imageHeight * 0.333333, imageWidth, imageHeight * 0.333333);\n            ctx.bezierCurveTo(imageWidth, imageHeight * 0.333333, imageWidth, imageHeight * 0.277777, imageWidth * 0.975, imageHeight * 0.277777);\n            ctx.bezierCurveTo(imageWidth * 0.975, imageHeight * 0.277777, imageWidth * 0.925, imageHeight * 0.277777, imageWidth * 0.925, imageHeight * 0.277777);\n            ctx.lineTo(imageWidth * 0.925, 0);\n            ctx.closePath();\n            //\n            grad = ctx.createLinearGradient(0, 0, 0, imageHeight);\n            grad.addColorStop(0, '#ffffff');\n            grad.addColorStop(1, '#7e7e7e');\n            ctx.fillStyle = grad;\n            ctx.fill();\n\n            // Main\n            ctx.beginPath();\n            var end = Math.max(imageWidth * 0.875 * (value / 100), Math.ceil(imageWidth * 0.01));\n            ctx.rect(imageWidth * 0.025, imageWidth * 0.025, end, imageHeight * 0.888888);\n            ctx.closePath();\n            var BORDER_FRACTIONS = [0, 0.4, 1];\n            var BORDER_COLORS = [new RgbaColor(177, 25, 2, 1),   // 0xB11902\n                                 new RgbaColor(219, 167, 21, 1), // 0xDBA715\n                                 new RgbaColor(121, 162, 75, 1)  // 0x79A24B\n                                ];\n            var border = new GradientWrapper(0, 100, BORDER_FRACTIONS, BORDER_COLORS);\n            ctx.fillStyle = border.getColorAt(value / 100).getRgbColor();\n            ctx.fill();\n            ctx.beginPath();\n            end = Math.max(end - imageWidth * 0.05, 0);\n            ctx.rect(imageWidth * 0.05, imageWidth * 0.05, end, imageHeight * 0.777777);\n            ctx.closePath();\n            var LIQUID_COLORS_DARK = [new RgbaColor(198, 39, 5, 1),   // 0xC62705\n                                      new RgbaColor(228, 189, 32, 1), // 0xE4BD20\n                                      new RgbaColor(163, 216, 102, 1) // 0xA3D866\n                                    ];\n\n            var LIQUID_COLORS_LIGHT = [new RgbaColor(246, 121, 48, 1),   // 0xF67930\n                                       new RgbaColor(246, 244, 157, 1),  // 0xF6F49D\n                                       new RgbaColor(223, 233, 86, 1)    // 0xDFE956\n                                      ];\n            var LIQUID_GRADIENT_FRACTIONS = [0, 0.4, 1];\n            var liquidDark = new GradientWrapper(0, 100, LIQUID_GRADIENT_FRACTIONS, LIQUID_COLORS_DARK);\n            var liquidLight = new GradientWrapper(0, 100, LIQUID_GRADIENT_FRACTIONS, LIQUID_COLORS_LIGHT);\n            grad = ctx.createLinearGradient(imageWidth * 0.05, 0, imageWidth * 0.875, 0);\n            grad.addColorStop(0, liquidDark.getColorAt(value / 100).getRgbColor());\n            grad.addColorStop(0.5, liquidLight.getColorAt(value / 100).getRgbColor());\n            grad.addColorStop(1, liquidDark.getColorAt(value / 100).getRgbColor());\n            ctx.fillStyle = grad;\n            ctx.fill();\n\n            // Foreground\n            ctx.beginPath();\n            ctx.rect(imageWidth * 0.025, imageWidth * 0.025, imageWidth * 0.875, imageHeight * 0.444444);\n            ctx.closePath();\n            grad = ctx.createLinearGradient(imageWidth * 0.025, imageWidth * 0.025, imageWidth * 0.875, imageHeight * 0.444444);\n            grad.addColorStop(0, 'rgba(255, 255, 255, 0)');\n            grad.addColorStop(1, 'rgba(255, 255, 255, 0.8)');\n            ctx.fillStyle = grad;\n            ctx.fill();\n        };\n\n        // **************   Public methods  ********************\n        this.setValue = function (newValue) {\n            newValue = (newValue < 0 ? 0 : (newValue > 100 ? 100 : newValue));\n            if (value !== newValue) {\n                value = newValue;\n                this.repaint();\n            }\n            return this;\n        };\n\n        this.getValue = function () {\n            return value;\n        };\n\n        this.repaint = function () {\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n            createBatteryImage(mainCtx, imageWidth, imageHeight, value);\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var stopwatch = function (canvas, parameters) {\n        parameters = parameters || {};\n        var size = (undefined === parameters.size ? 0 : parameters.size),\n            frameDesign = (undefined === parameters.frameDesign ? steelseries.FrameDesign.METAL : parameters.frameDesign),\n            frameVisible = (undefined === parameters.frameVisible ? true : parameters.frameVisible),\n            pointerColor = (undefined === parameters.pointerColor ? steelseries.ColorDef.BLACK : parameters.pointerColor),\n            backgroundColor = (undefined === parameters.backgroundColor ? steelseries.BackgroundColor.LIGHT_GRAY : parameters.backgroundColor),\n            backgroundVisible = (undefined === parameters.backgroundVisible ? true : parameters.backgroundVisible),\n            foregroundType = (undefined === parameters.foregroundType ? steelseries.ForegroundType.TYPE1 : parameters.foregroundType),\n            foregroundVisible = (undefined === parameters.foregroundVisible ? true : parameters.foregroundVisible),\n            customLayer = (undefined === parameters.customLayer ? null : parameters.customLayer),\n\n            minutePointerAngle = 0,\n            secondPointerAngle = 0,\n            tickTimer,\n            ANGLE_STEP = 6,\n            self = this,\n\n            start = 0,\n            currentMilliSeconds = 0,\n            minutes = 0,\n            seconds = 0,\n            milliSeconds = 0,\n            running = false,\n            lap = false,\n            // Get the canvas context\n            mainCtx = getCanvasContext(canvas),\n\n            imageWidth, imageHeight,\n            centerX, centerY,\n\n            smallPointerSize, smallPointerX_Offset, smallPointerY_Offset,\n\n            initialized = false,\n\n            // Buffer for the frame\n            frameBuffer, frameContext,\n\n            // Buffer for static background painting code\n            backgroundBuffer, backgroundContext,\n\n            // Buffer for small pointer image painting code\n            smallPointerBuffer, smallPointerContext,\n\n            // Buffer for large pointer image painting code\n            largePointerBuffer, largePointerContext,\n\n            // Buffer for static foreground painting code\n            foregroundBuffer, foregroundContext,\n\n            drawTickmarksImage = function (ctx, width, range, text_scale, text_dist_factor, x_offset, y_offset) {\n                var STD_FONT_SIZE = text_scale * width,\n                    STD_FONT = STD_FONT_SIZE + 'px ' + stdFontName,\n                    TEXT_WIDTH = width * 0.15,\n                    THIN_STROKE = 0.5,\n                    MEDIUM_STROKE = 1,\n                    THICK_STROKE = 1.5,\n                    TEXT_DISTANCE = text_dist_factor * width,\n                    MIN_LENGTH = Math.round(0.025 * width),\n                    MED_LENGTH = Math.round(0.035 * width),\n                    MAX_LENGTH = Math.round(0.045 * width),\n                    TEXT_COLOR = backgroundColor.labelColor.getRgbaColor(),\n                    TICK_COLOR = backgroundColor.labelColor.getRgbaColor(),\n                    CENTER = width / 2,\n                    // Create the ticks itself\n                    RADIUS = width * 0.4,\n                    innerPoint, outerPoint, textPoint,\n                    counter = 0,\n                    numberCounter = 0,\n                    tickCounter = 0,\n                    valueCounter, // value for the tickmarks\n                    sinValue = 0,\n                    cosValue = 0,\n                    alpha, // angle for the tickmarks\n                    ALPHA_START = -PI,\n                    ANGLE_STEPSIZE = TWO_PI / (range);\n\n                ctx.width = ctx.height = width;\n                ctx.save();\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.font = STD_FONT;\n\n                for (alpha = ALPHA_START, valueCounter = 0; valueCounter <= range + 1; alpha -= ANGLE_STEPSIZE * 0.1, valueCounter += 0.1) {\n                    ctx.lineWidth = THIN_STROKE;\n                    sinValue = Math.sin(alpha);\n                    cosValue = Math.cos(alpha);\n\n                    // tickmark every 2 units\n                    if (counter % 2 === 0) {\n                        //ctx.lineWidth = THIN_STROKE;\n                        innerPoint = [CENTER + (RADIUS - MIN_LENGTH) * sinValue + x_offset, CENTER + (RADIUS - MIN_LENGTH) * cosValue + y_offset];\n                        outerPoint = [CENTER + RADIUS * sinValue + x_offset, CENTER + RADIUS * cosValue + y_offset];\n                        // Draw ticks\n                        ctx.strokeStyle = TICK_COLOR;\n                        ctx.beginPath();\n                        ctx.moveTo(innerPoint[0], innerPoint[1]);\n                        ctx.lineTo(outerPoint[0], outerPoint[1]);\n                        ctx.closePath();\n                        ctx.stroke();\n                    }\n\n                    // Different tickmark every 10 units\n                    if (counter === 10 || counter === 0) {\n                        ctx.fillStyle = TEXT_COLOR;\n                        ctx.lineWidth = MEDIUM_STROKE;\n                        outerPoint = [CENTER + RADIUS * sinValue + x_offset, CENTER + RADIUS * cosValue + y_offset];\n                        textPoint  = [CENTER + (RADIUS - TEXT_DISTANCE) * sinValue + x_offset, CENTER + (RADIUS - TEXT_DISTANCE) * cosValue + y_offset];\n\n                        // Draw text\n                        if (numberCounter === 5) {\n                            if (valueCounter !== range) {\n                                if (Math.round(valueCounter) !== 60) {\n                                    ctx.fillText(Math.round(valueCounter), textPoint[0], textPoint[1], TEXT_WIDTH);\n                                }\n                            }\n                            ctx.lineWidth = THICK_STROKE;\n                            innerPoint = [CENTER + (RADIUS - MAX_LENGTH) * sinValue + x_offset, CENTER + (RADIUS - MAX_LENGTH) * cosValue + y_offset];\n                            numberCounter = 0;\n                        } else {\n                            ctx.lineWidth = MEDIUM_STROKE;\n                            innerPoint = [CENTER + (RADIUS - MED_LENGTH) * sinValue + x_offset, CENTER + (RADIUS - MED_LENGTH) * cosValue + y_offset];\n                        }\n\n                        // Draw ticks\n                        ctx.strokeStyle = TICK_COLOR;\n                        ctx.beginPath();\n                        ctx.moveTo(innerPoint[0], innerPoint[1]);\n                        ctx.lineTo(outerPoint[0], outerPoint[1]);\n                        ctx.closePath();\n                        ctx.stroke();\n\n                        counter = 0;\n                        tickCounter++;\n                        numberCounter++;\n                    }\n                    counter++;\n                }\n                ctx.restore();\n            },\n\n            drawLargePointer = function (ctx) {\n                var grad, radius;\n\n                ctx.save();\n                ctx.beginPath();\n                ctx.moveTo(imageWidth * 0.509345, imageWidth * 0.457943);\n                ctx.lineTo(imageWidth * 0.5, imageWidth * 0.102803);\n                ctx.lineTo(imageWidth * 0.490654, imageWidth * 0.457943);\n                ctx.bezierCurveTo(imageWidth * 0.490654, imageWidth * 0.457943, imageWidth * 0.490654, imageWidth * 0.457943, imageWidth * 0.490654, imageWidth * 0.457943);\n                ctx.bezierCurveTo(imageWidth * 0.471962, imageWidth * 0.462616, imageWidth * 0.457943, imageWidth * 0.481308, imageWidth * 0.457943, imageWidth * 0.5);\n                ctx.bezierCurveTo(imageWidth * 0.457943, imageWidth * 0.518691, imageWidth * 0.471962, imageWidth * 0.537383, imageWidth * 0.490654, imageWidth * 0.542056);\n                ctx.bezierCurveTo(imageWidth * 0.490654, imageWidth * 0.542056, imageWidth * 0.490654, imageWidth * 0.542056, imageWidth * 0.490654, imageWidth * 0.542056);\n                ctx.lineTo(imageWidth * 0.490654, imageWidth * 0.621495);\n                ctx.lineTo(imageWidth * 0.509345, imageWidth * 0.621495);\n                ctx.lineTo(imageWidth * 0.509345, imageWidth * 0.542056);\n                ctx.bezierCurveTo(imageWidth * 0.509345, imageWidth * 0.542056, imageWidth * 0.509345, imageWidth * 0.542056, imageWidth * 0.509345, imageWidth * 0.542056);\n                ctx.bezierCurveTo(imageWidth * 0.528037, imageWidth * 0.537383, imageWidth * 0.542056, imageWidth * 0.518691, imageWidth * 0.542056, imageWidth * 0.5);\n                ctx.bezierCurveTo(imageWidth * 0.542056, imageWidth * 0.481308, imageWidth * 0.528037, imageWidth * 0.462616, imageWidth * 0.509345, imageWidth * 0.457943);\n                ctx.bezierCurveTo(imageWidth * 0.509345, imageWidth * 0.457943, imageWidth * 0.509345, imageWidth * 0.457943, imageWidth * 0.509345, imageWidth * 0.457943);\n                ctx.closePath();\n                grad = ctx.createLinearGradient(0, 0, 0, imageWidth * 0.621495);\n                grad.addColorStop(0, pointerColor.medium.getRgbaColor());\n                grad.addColorStop(0.388888, pointerColor.medium.getRgbaColor());\n                grad.addColorStop(0.5, pointerColor.light.getRgbaColor());\n                grad.addColorStop(0.611111, pointerColor.medium.getRgbaColor());\n                grad.addColorStop(1, pointerColor.medium.getRgbaColor());\n                ctx.fillStyle = grad;\n                ctx.strokeStyle = pointerColor.dark.getRgbaColor();\n                ctx.fill();\n                ctx.stroke();\n                // Draw the rings\n                ctx.beginPath();\n                radius = imageWidth * 0.065420 / 2;\n                ctx.arc(centerX, centerY, radius, 0, TWO_PI);\n                grad = ctx.createLinearGradient(centerX - radius, centerX + radius, 0, centerX + radius);\n                grad.addColorStop(0, '#e6b35c');\n                grad.addColorStop(0.01, '#e6b35c');\n                grad.addColorStop(0.99, '#c48200');\n                grad.addColorStop(1, '#c48200');\n                ctx.fillStyle = grad;\n                ctx.closePath();\n                ctx.fill();\n                ctx.beginPath();\n                radius = imageWidth * 0.046728 / 2;\n                ctx.arc(centerX, centerY, radius, 0, TWO_PI);\n                grad = ctx.createRadialGradient(centerX, centerX, 0, centerX, centerX, radius);\n                grad.addColorStop(0, '#c5c5c5');\n                grad.addColorStop(0.19, '#c5c5c5');\n                grad.addColorStop(0.22, '#000000');\n                grad.addColorStop(0.8, '#000000');\n                grad.addColorStop(0.99, '#707070');\n                grad.addColorStop(1, '#707070');\n                ctx.fillStyle = grad;\n                ctx.closePath();\n                ctx.fill();\n                ctx.restore();\n            },\n\n            drawSmallPointer = function (ctx) {\n                var grad, radius;\n\n                ctx.save();\n                ctx.beginPath();\n                ctx.moveTo(imageWidth * 0.476635, imageWidth * 0.313084);\n                ctx.bezierCurveTo(imageWidth * 0.476635, imageWidth * 0.322429, imageWidth * 0.485981, imageWidth * 0.331775, imageWidth * 0.495327, imageWidth * 0.336448);\n                ctx.bezierCurveTo(imageWidth * 0.495327, imageWidth * 0.336448, imageWidth * 0.495327, imageWidth * 0.350467, imageWidth * 0.495327, imageWidth * 0.350467);\n                ctx.lineTo(imageWidth * 0.504672, imageWidth * 0.350467);\n                ctx.bezierCurveTo(imageWidth * 0.504672, imageWidth * 0.350467, imageWidth * 0.504672, imageWidth * 0.336448, imageWidth * 0.504672, imageWidth * 0.336448);\n                ctx.bezierCurveTo(imageWidth * 0.514018, imageWidth * 0.331775, imageWidth * 0.523364, imageWidth * 0.322429, imageWidth * 0.523364, imageWidth * 0.313084);\n                ctx.bezierCurveTo(imageWidth * 0.523364, imageWidth * 0.303738, imageWidth * 0.514018, imageWidth * 0.294392, imageWidth * 0.504672, imageWidth * 0.289719);\n                ctx.bezierCurveTo(imageWidth * 0.504672, imageWidth * 0.289719, imageWidth * 0.5, imageWidth * 0.200934, imageWidth * 0.5, imageWidth * 0.200934);\n                ctx.bezierCurveTo(imageWidth * 0.5, imageWidth * 0.200934, imageWidth * 0.495327, imageWidth * 0.289719, imageWidth * 0.495327, imageWidth * 0.289719);\n                ctx.bezierCurveTo(imageWidth * 0.485981, imageWidth * 0.294392, imageWidth * 0.476635, imageWidth * 0.303738, imageWidth * 0.476635, imageWidth * 0.313084);\n                ctx.closePath();\n                grad = ctx.createLinearGradient(0, 0, imageWidth, 0);\n                grad.addColorStop(0, pointerColor.medium.getRgbaColor());\n                grad.addColorStop(0.388888, pointerColor.medium.getRgbaColor());\n                grad.addColorStop(0.5, pointerColor.light.getRgbaColor());\n                grad.addColorStop(0.611111, pointerColor.medium.getRgbaColor());\n                grad.addColorStop(1, pointerColor.medium.getRgbaColor());\n                ctx.fillStyle = grad;\n                ctx.strokeStyle = pointerColor.dark.getRgbaColor();\n                ctx.fill();\n                ctx.stroke();\n                // Draw the rings\n                ctx.beginPath();\n                radius = imageWidth * 0.037383 / 2;\n                ctx.arc(centerX, smallPointerY_Offset + smallPointerSize / 2, radius, 0, TWO_PI);\n                ctx.fillStyle = '#C48200';\n                ctx.closePath();\n                ctx.fill();\n                ctx.beginPath();\n                radius = imageWidth * 0.028037 / 2;\n                ctx.arc(centerX, smallPointerY_Offset + smallPointerSize / 2, radius, 0, TWO_PI);\n                ctx.fillStyle = '#999999';\n                ctx.closePath();\n                ctx.fill();\n                ctx.beginPath();\n                radius = imageWidth * 0.018691 / 2;\n                ctx.arc(centerX, smallPointerY_Offset + smallPointerSize / 2, radius, 0, TWO_PI);\n                ctx.fillStyle = '#000000';\n                ctx.closePath();\n                ctx.fill();\n                ctx.restore();\n            },\n\n            calculateAngles = function () {\n                currentMilliSeconds = new Date().getTime() - start;\n                secondPointerAngle = (currentMilliSeconds * ANGLE_STEP / 1000);\n                minutePointerAngle = (secondPointerAngle % 10800) / 30;\n\n                minutes = (currentMilliSeconds / 60000) % 30;\n                seconds = (currentMilliSeconds / 1000) % 60;\n                milliSeconds = (currentMilliSeconds) % 1000;\n            },\n\n            init = function (parameters) {\n                parameters = parameters || {};\n                var drawFrame = (undefined === parameters.frame ? false : parameters.frame),\n                    drawBackground = (undefined === parameters.background ? false : parameters.background),\n                    drawPointers = (undefined === parameters.pointers ? false : parameters.pointers),\n                    drawForeground = (undefined === parameters.foreground ? false : parameters.foreground);\n\n                initialized = true;\n\n                if (drawFrame && frameVisible) {\n                    drawRadialFrameImage(frameContext, frameDesign, centerX, centerY, imageWidth, imageHeight);\n                }\n\n                if (drawBackground && backgroundVisible) {\n                    // Create background in background buffer (backgroundBuffer)\n                    drawRadialBackgroundImage(backgroundContext, backgroundColor, centerX, centerY, imageWidth, imageHeight);\n\n                    // Create custom layer in background buffer (backgroundBuffer)\n                    drawRadialCustomImage(backgroundContext, customLayer, centerX, centerY, imageWidth, imageHeight);\n\n                    drawTickmarksImage(backgroundContext, imageWidth, 60, 0.075, 0.1, 0, 0);\n                    drawTickmarksImage(backgroundContext, smallPointerSize, 30, 0.095, 0.13, smallPointerX_Offset, smallPointerY_Offset);\n                }\n                if (drawPointers) {\n                    drawLargePointer(largePointerContext);\n                    drawSmallPointer(smallPointerContext);\n                }\n\n                if (drawForeground && foregroundVisible) {\n                    drawRadialForegroundImage(foregroundContext, foregroundType, imageWidth, imageHeight, false);\n                }\n            },\n\n            resetBuffers = function (buffers) {\n                buffers = buffers || {};\n                var resetFrame = (undefined === buffers.frame ? false : buffers.frame),\n                    resetBackground = (undefined === buffers.background ? false : buffers.background),\n                    resetPointers = (undefined === buffers.pointers ? false : buffers.pointers),\n                    resetForeground = (undefined === buffers.foreground ? false : buffers.foreground);\n\n                if (resetFrame) {\n                    frameBuffer.width = size;\n                    frameBuffer.height = size;\n                    frameContext = frameBuffer.getContext('2d');\n                }\n\n                if (resetBackground) {\n                    backgroundBuffer.width = size;\n                    backgroundBuffer.height = size;\n                    backgroundContext = backgroundBuffer.getContext('2d');\n                }\n\n                if (resetPointers) {\n                    smallPointerBuffer.width = size;\n                    smallPointerBuffer.height = size;\n                    smallPointerContext = smallPointerBuffer.getContext('2d');\n\n                    largePointerBuffer.width = size;\n                    largePointerBuffer.height = size;\n                    largePointerContext = largePointerBuffer.getContext('2d');\n                }\n\n                if (resetForeground) {\n                    foregroundBuffer.width = size;\n                    foregroundBuffer.height = size;\n                    foregroundContext = foregroundBuffer.getContext('2d');\n                }\n            },\n\n            tickTock = function () {\n                if (!lap) {\n                    calculateAngles();\n                    self.repaint();\n                }\n                if (running) {\n                    tickTimer = setTimeout(tickTock, 200);\n                }\n\n            };\n\n        //************************************ Public methods **************************************\n        // Returns true if the stopwatch is running\n        this.isRunning = function () {\n            return running;\n        };\n\n        // Starts the stopwatch\n        this.start = function () {\n            if (!running) {\n                running = true;\n                start = new Date().getTime() - currentMilliSeconds;\n                tickTock();\n            }\n            return this;\n        };\n\n        // Stops the stopwatch\n        this.stop = function () {\n            if (running) {\n                running = false;\n                clearTimeout(tickTimer);\n                //calculateAngles();\n            }\n            if (lap) {\n                lap = false;\n                calculateAngles();\n                this.repaint();\n            }\n            return this;\n        };\n\n        // Resets the stopwatch\n        this.reset = function () {\n            if (running) {\n                running = false;\n                lap = false;\n                clearTimeout(tickTimer);\n            }\n            start = new Date().getTime();\n            calculateAngles();\n            this.repaint();\n            return this;\n        };\n\n        // Laptimer, stop/restart stopwatch\n        this.lap = function () {\n            if (running && !lap) {\n                lap = true;\n            } else if (lap) {\n                lap = false;\n            }\n            return this;\n        };\n\n        this.getMeasuredTime = function () {\n            return (minutes + ':' + seconds + ':' + milliSeconds);\n        };\n\n        this.setFrameDesign = function (newFrameDesign) {\n            resetBuffers({frame: true});\n            frameDesign = newFrameDesign;\n            init({frame: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setBackgroundColor = function (newBackgroundColor) {\n            resetBuffers({ background: true });\n            backgroundColor = newBackgroundColor;\n            init({ background: true });\n            this.repaint();\n            return this;\n        };\n\n        this.setForegroundType = function (newForegroundType) {\n            resetBuffers({foreground: true});\n            foregroundType = newForegroundType;\n            init({foreground: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setPointerColor = function (newPointerColor) {\n            resetBuffers({pointers: true});\n            pointerColor = newPointerColor;\n            init({pointers: true});\n            this.repaint();\n            return this;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init({frame: true,\n                      background: true,\n                      pointers: true,\n                      foreground: true});\n            }\n\n            mainCtx.clearRect(0, 0, imageWidth, imageHeight);\n\n            // Draw frame\n            if (frameVisible) {\n                mainCtx.drawImage(frameBuffer, 0, 0);\n            }\n\n            // Draw buffered image to visible canvas\n            if (backgroundVisible) {\n                mainCtx.drawImage(backgroundBuffer, 0, 0);\n            }\n\n            // have to draw to a rotated temporary image area so we can translate in\n            // absolute x, y values when drawing to main context\n            var shadowOffset = imageWidth * 0.006;\n\n            var rotationAngle = (minutePointerAngle + (2 * Math.sin(minutePointerAngle * RAD_FACTOR))) * RAD_FACTOR;\n            var secRotationAngle = (secondPointerAngle + (2 * Math.sin(secondPointerAngle * RAD_FACTOR))) * RAD_FACTOR;\n\n            // Draw the minute pointer\n            // Define rotation center\n            mainCtx.save();\n            mainCtx.translate(centerX, smallPointerY_Offset + smallPointerSize / 2);\n            mainCtx.rotate(rotationAngle);\n            mainCtx.translate(-centerX, -(smallPointerY_Offset + smallPointerSize / 2));\n            // Set the pointer shadow params\n            mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n            mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset / 2;\n            mainCtx.shadowBlur = shadowOffset;\n            // Draw the pointer\n            mainCtx.drawImage(smallPointerBuffer, 0, 0);\n            mainCtx.restore();\n\n            // Draw the second pointer\n            // Define rotation center\n            mainCtx.save();\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate(secRotationAngle);\n            mainCtx.translate(-centerX, -centerY);\n            // Set the pointer shadow params\n            mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n            mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset / 2;\n            mainCtx.shadowBlur = shadowOffset;\n            // Draw the pointer\n            mainCtx.drawImage(largePointerBuffer, 0, 0);\n            // Undo the translations & shadow settings\n            mainCtx.restore();\n\n            // Draw the foreground\n            if (foregroundVisible) {\n                mainCtx.drawImage(foregroundBuffer, 0, 0);\n            }\n        };\n\n        // Has a size been specified?\n        size = (size === 0 ? Math.min(mainCtx.canvas.width, mainCtx.canvas.height) : size);\n\n        // Set the size - also clears it\n        mainCtx.canvas.width = size;\n        mainCtx.canvas.height = size;\n\n        imageWidth = size;\n        imageHeight = size;\n\n        centerX = imageWidth / 2;\n        centerY = imageHeight / 2;\n\n        smallPointerSize = 0.285 * imageWidth;\n        smallPointerX_Offset = centerX - smallPointerSize / 2;\n        smallPointerY_Offset = 0.17 * imageWidth;\n\n        // Buffer for the frame\n        frameBuffer = createBuffer(size, size);\n        frameContext = frameBuffer.getContext('2d');\n\n        // Buffer for static background painting code\n        backgroundBuffer = createBuffer(size, size);\n        backgroundContext = backgroundBuffer.getContext('2d');\n\n        // Buffer for small pointer image painting code\n        smallPointerBuffer = createBuffer(size, size);\n        smallPointerContext = smallPointerBuffer.getContext('2d');\n\n        // Buffer for large pointer image painting code\n        largePointerBuffer = createBuffer(size, size);\n        largePointerContext = largePointerBuffer.getContext('2d');\n\n        // Buffer for static foreground painting code\n        foregroundBuffer = createBuffer(size, size);\n        foregroundContext = foregroundBuffer.getContext('2d');\n\n        // Visualize the component\n        start = new Date().getTime();\n        tickTock();\n\n        return this;\n    };\n\n    var altimeter = function (canvas, parameters) {\n        parameters = parameters || {};\n            // parameters\n        var size = (undefined === parameters.size ? 0 : parameters.size),\n            frameDesign = (undefined === parameters.frameDesign ? steelseries.FrameDesign.METAL : parameters.frameDesign),\n            frameVisible = (undefined === parameters.frameVisible ? true : parameters.frameVisible),\n            backgroundColor = (undefined === parameters.backgroundColor ? steelseries.BackgroundColor.DARK_GRAY : parameters.backgroundColor),\n            backgroundVisible = (undefined === parameters.backgroundVisible ? true : parameters.backgroundVisible),\n            knobType = (undefined === parameters.knobType ? steelseries.KnobType.METAL_KNOB : parameters.knobType),\n            knobStyle = (undefined === parameters.knobStyle ? steelseries.KnobStyle.BLACK : parameters.knobStyle),\n            lcdColor = (undefined === parameters.lcdColor ? steelseries.LcdColor.BLACK : parameters.lcdColor),\n            lcdVisible = (undefined === parameters.lcdVisible ? true : parameters.lcdVisible),\n            digitalFont = (undefined === parameters.digitalFont ? false : parameters.digitalFont),\n            foregroundType = (undefined === parameters.foregroundType ? steelseries.ForegroundType.TYPE1 : parameters.foregroundType),\n            foregroundVisible = (undefined === parameters.foregroundVisible ? true : parameters.foregroundVisible),\n            customLayer = (undefined === parameters.customLayer ? null : parameters.customLayer),\n            //\n            minValue = 0, maxValue = 10, value = minValue,\n            value100 = 0, value1000 = 0, value10000 = 0,\n            angleStep100ft, angleStep1000ft, angleStep10000ft,\n            tickLabelPeriod = 1, // Draw value at every 10th tickmark\n            tween,\n            repainting = false,\n            imageWidth, imageHeight,\n            centerX, centerY,\n            stdFont,\n            mainCtx = getCanvasContext(canvas),  // Get the canvas context\n            // Constants\n            TICKMARK_OFFSET = PI,\n            //\n            initialized = false,\n            // **************   Buffer creation  ********************\n            // Buffer for the frame\n            frameBuffer = createBuffer(size, size),\n            frameContext = frameBuffer.getContext('2d'),\n            // Buffer for the background\n            backgroundBuffer = createBuffer(size, size),\n            backgroundContext = backgroundBuffer.getContext('2d'),\n\n            lcdBuffer,\n\n            // Buffer for 10000ft pointer image painting code\n            pointer10000Buffer = createBuffer(size, size),\n            pointer10000Context = pointer10000Buffer.getContext('2d'),\n\n            // Buffer for 1000ft pointer image painting code\n            pointer1000Buffer = createBuffer(size, size),\n            pointer1000Context = pointer1000Buffer.getContext('2d'),\n\n            // Buffer for 100ft pointer image painting code\n            pointer100Buffer = createBuffer(size, size),\n            pointer100Context = pointer100Buffer.getContext('2d'),\n\n            // Buffer for static foreground painting code\n            foregroundBuffer = createBuffer(size, size),\n            foregroundContext = foregroundBuffer.getContext('2d');\n            // End of variables\n\n        // Get the canvas context and clear it\n        mainCtx.save();\n        // Has a size been specified?\n        size = (size === 0 ? Math.min(mainCtx.canvas.width, mainCtx.canvas.height) : size);\n\n        // Set the size\n        mainCtx.canvas.width = size;\n        mainCtx.canvas.height = size;\n\n        imageWidth = size;\n        imageHeight = size;\n\n        centerX = imageWidth / 2;\n        centerY = imageHeight / 2;\n\n        stdFont = Math.floor(imageWidth * 0.09) + 'px ' + stdFontName;\n\n        // **************   Image creation  ********************\n        var drawLcdText = function (value) {\n            mainCtx.save();\n            mainCtx.textAlign = 'right';\n            mainCtx.textBaseline = 'middle';\n            mainCtx.strokeStyle = lcdColor.textColor;\n            mainCtx.fillStyle = lcdColor.textColor;\n\n            if (lcdColor === steelseries.LcdColor.STANDARD || lcdColor === steelseries.LcdColor.STANDARD_GREEN) {\n                mainCtx.shadowColor = 'gray';\n                mainCtx.shadowOffsetX = imageWidth * 0.007;\n                mainCtx.shadowOffsetY = imageWidth * 0.007;\n                mainCtx.shadowBlur = imageWidth * 0.009;\n            }\n            if (digitalFont) {\n                mainCtx.font = Math.floor(imageWidth * 0.075) + 'px ' + lcdFontName;\n            } else {\n                mainCtx.font = Math.floor(imageWidth * 0.075) + 'px ' + stdFontName;\n            }\n            mainCtx.fillText(Math.round(value), (imageWidth + (imageWidth * 0.4)) / 2 - 4, imageWidth * 0.607, imageWidth * 0.4);\n            mainCtx.restore();\n        };\n\n        var drawTickmarksImage = function (ctx, freeAreaAngle, offset, minVal, maxVal, angleStep) {\n            var MEDIUM_STROKE = Math.max(imageWidth * 0.012, 2),\n                THIN_STROKE = Math.max(imageWidth * 0.007, 1.5),\n                TEXT_DISTANCE = imageWidth * 0.13,\n                MED_LENGTH = imageWidth * 0.05,\n                MAX_LENGTH = imageWidth * 0.07,\n                RADIUS = imageWidth * 0.4,\n                counter = 0,\n                tickCounter = 0,\n                sinValue = 0,\n                cosValue = 0,\n                alpha,          // angle for tickmarks\n                valueCounter,   // value for tickmarks\n                ALPHA_START = -offset - (freeAreaAngle / 2);\n\n            ctx.save();\n            ctx.textAlign = 'center';\n            ctx.textBaseline = 'middle';\n            ctx.font = stdFont;\n            ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n            ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n\n            for (alpha = ALPHA_START, valueCounter = 0; valueCounter <= 10; alpha -= angleStep * 0.1, valueCounter += 0.1) {\n                sinValue = Math.sin(alpha);\n                cosValue = Math.cos(alpha);\n\n                // tickmark every 2 units\n                if (counter % 2 === 0) {\n                    ctx.lineWidth = THIN_STROKE;\n                    // Draw ticks\n                    ctx.beginPath();\n                    ctx.moveTo(centerX + (RADIUS - MED_LENGTH) * sinValue, centerY + (RADIUS - MED_LENGTH) * cosValue);\n                    ctx.lineTo(centerX + RADIUS * sinValue, centerY + RADIUS * cosValue);\n                    ctx.closePath();\n                    ctx.stroke();\n                }\n\n                // Different tickmark every 10 units\n                if (counter === 10 || counter === 0) {\n                    ctx.lineWidth = MEDIUM_STROKE;\n\n                    // if gauge is full circle, avoid painting maxValue over minValue\n                    if (freeAreaAngle === 0) {\n                        if (Math.round(valueCounter) !== maxValue) {\n                            ctx.fillText(Math.round(valueCounter).toString(), centerX + (RADIUS - TEXT_DISTANCE) * sinValue, centerY + (RADIUS - TEXT_DISTANCE) * cosValue);\n                        }\n                    }\n                    counter = 0;\n                    tickCounter++;\n\n                    // Draw ticks\n                    ctx.beginPath();\n                    ctx.moveTo(centerX + (RADIUS - MAX_LENGTH) * sinValue, centerY + (RADIUS - MAX_LENGTH) * cosValue);\n                    ctx.lineTo(centerX + RADIUS * sinValue, centerY + RADIUS * cosValue);\n                    ctx.closePath();\n                    ctx.stroke();\n                }\n                counter++;\n            }\n            ctx.restore();\n        };\n\n        var draw100ftPointer = function (ctx, shadow) {\n            var grad;\n\n            if (shadow) {\n                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';\n            } else {\n                grad = ctx.createLinearGradient(0, imageHeight * 0.168224, 0, imageHeight * 0.626168);\n                grad.addColorStop(0, '#ffffff');\n                grad.addColorStop(0.31, '#ffffff');\n                grad.addColorStop(0.3101, '#ffffff');\n                grad.addColorStop(0.32, '#202020');\n                grad.addColorStop(1, '#202020');\n                ctx.fillStyle = grad;\n            }\n\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.518691, imageHeight * 0.471962);\n            ctx.bezierCurveTo(imageWidth * 0.514018, imageHeight * 0.471962, imageWidth * 0.509345, imageHeight * 0.467289, imageWidth * 0.509345, imageHeight * 0.467289);\n            ctx.lineTo(imageWidth * 0.509345, imageHeight * 0.200934);\n            ctx.lineTo(imageWidth * 0.5, imageHeight * 0.168224);\n            ctx.lineTo(imageWidth * 0.490654, imageHeight * 0.200934);\n            ctx.lineTo(imageWidth * 0.490654, imageHeight * 0.467289);\n            ctx.bezierCurveTo(imageWidth * 0.490654, imageHeight * 0.467289, imageWidth * 0.481308, imageHeight * 0.471962, imageWidth * 0.481308, imageHeight * 0.471962);\n            ctx.bezierCurveTo(imageWidth * 0.471962, imageHeight * 0.481308, imageWidth * 0.467289, imageHeight * 0.490654, imageWidth * 0.467289, imageHeight * 0.5);\n            ctx.bezierCurveTo(imageWidth * 0.467289, imageHeight * 0.514018, imageWidth * 0.476635, imageHeight * 0.528037, imageWidth * 0.490654, imageHeight * 0.532710);\n            ctx.bezierCurveTo(imageWidth * 0.490654, imageHeight * 0.532710, imageWidth * 0.490654, imageHeight * 0.579439, imageWidth * 0.490654, imageHeight * 0.588785);\n            ctx.bezierCurveTo(imageWidth * 0.485981, imageHeight * 0.593457, imageWidth * 0.481308, imageHeight * 0.598130, imageWidth * 0.481308, imageHeight * 0.607476);\n            ctx.bezierCurveTo(imageWidth * 0.481308, imageHeight * 0.616822, imageWidth * 0.490654, imageHeight * 0.626168, imageWidth * 0.5, imageHeight * 0.626168);\n            ctx.bezierCurveTo(imageWidth * 0.509345, imageHeight * 0.626168, imageWidth * 0.518691, imageHeight * 0.616822, imageWidth * 0.518691, imageHeight * 0.607476);\n            ctx.bezierCurveTo(imageWidth * 0.518691, imageHeight * 0.598130, imageWidth * 0.514018, imageHeight * 0.593457, imageWidth * 0.504672, imageHeight * 0.588785);\n            ctx.bezierCurveTo(imageWidth * 0.504672, imageHeight * 0.579439, imageWidth * 0.504672, imageHeight * 0.532710, imageWidth * 0.509345, imageHeight * 0.532710);\n            ctx.bezierCurveTo(imageWidth * 0.523364, imageHeight * 0.528037, imageWidth * 0.532710, imageHeight * 0.514018, imageWidth * 0.532710, imageHeight * 0.5);\n            ctx.bezierCurveTo(imageWidth * 0.532710, imageHeight * 0.490654, imageWidth * 0.528037, imageHeight * 0.481308, imageWidth * 0.518691, imageHeight * 0.471962);\n            ctx.closePath();\n            ctx.fill();\n            ctx.restore();\n        };\n\n        var draw1000ftPointer = function (ctx) {\n            var grad;\n\n            grad = ctx.createLinearGradient(0, imageHeight * 0.401869, 0, imageHeight * 0.616822);\n            grad.addColorStop(0, '#ffffff');\n            grad.addColorStop(0.51, '#ffffff');\n            grad.addColorStop(0.52, '#ffffff');\n            grad.addColorStop(0.5201, '#202020');\n            grad.addColorStop(0.53, '#202020');\n            grad.addColorStop(1, '#202020');\n            ctx.fillStyle = grad;\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.518691, imageHeight * 0.471962);\n            ctx.bezierCurveTo(imageWidth * 0.514018, imageHeight * 0.462616, imageWidth * 0.528037, imageHeight * 0.401869, imageWidth * 0.528037, imageHeight * 0.401869);\n            ctx.lineTo(imageWidth * 0.5, imageHeight * 0.331775);\n            ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.401869);\n            ctx.bezierCurveTo(imageWidth * 0.471962, imageHeight * 0.401869, imageWidth * 0.485981, imageHeight * 0.462616, imageWidth * 0.481308, imageHeight * 0.471962);\n            ctx.bezierCurveTo(imageWidth * 0.471962, imageHeight * 0.481308, imageWidth * 0.467289, imageHeight * 0.490654, imageWidth * 0.467289, imageHeight * 0.5);\n            ctx.bezierCurveTo(imageWidth * 0.467289, imageHeight * 0.514018, imageWidth * 0.476635, imageHeight * 0.528037, imageWidth * 0.490654, imageHeight * 0.532710);\n            ctx.bezierCurveTo(imageWidth * 0.490654, imageHeight * 0.532710, imageWidth * 0.462616, imageHeight * 0.574766, imageWidth * 0.462616, imageHeight * 0.593457);\n            ctx.bezierCurveTo(imageWidth * 0.467289, imageHeight * 0.616822, imageWidth * 0.5, imageHeight * 0.612149, imageWidth * 0.5, imageHeight * 0.612149);\n            ctx.bezierCurveTo(imageWidth * 0.5, imageHeight * 0.612149, imageWidth * 0.532710, imageHeight * 0.616822, imageWidth * 0.537383, imageHeight * 0.593457);\n            ctx.bezierCurveTo(imageWidth * 0.537383, imageHeight * 0.574766, imageWidth * 0.509345, imageHeight * 0.532710, imageWidth * 0.509345, imageHeight * 0.532710);\n            ctx.bezierCurveTo(imageWidth * 0.523364, imageHeight * 0.528037, imageWidth * 0.532710, imageHeight * 0.514018, imageWidth * 0.532710, imageHeight * 0.5);\n            ctx.bezierCurveTo(imageWidth * 0.532710, imageHeight * 0.490654, imageWidth * 0.528037, imageHeight * 0.481308, imageWidth * 0.518691, imageHeight * 0.471962);\n            ctx.closePath();\n            ctx.fill();\n            ctx.restore();\n        };\n\n        var draw10000ftPointer = function (ctx) {\n            ctx.fillStyle = '#ffffff';\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.518691, imageHeight * 0.471962);\n            ctx.bezierCurveTo(imageWidth * 0.514018, imageHeight * 0.471962, imageWidth * 0.514018, imageHeight * 0.467289, imageWidth * 0.514018, imageHeight * 0.467289);\n            ctx.lineTo(imageWidth * 0.514018, imageHeight * 0.317757);\n            ctx.lineTo(imageWidth * 0.504672, imageHeight * 0.303738);\n            ctx.lineTo(imageWidth * 0.504672, imageHeight * 0.182242);\n            ctx.lineTo(imageWidth * 0.532710, imageHeight * 0.116822);\n            ctx.lineTo(imageWidth * 0.462616, imageHeight * 0.116822);\n            ctx.lineTo(imageWidth * 0.495327, imageHeight * 0.182242);\n            ctx.lineTo(imageWidth * 0.495327, imageHeight * 0.299065);\n            ctx.lineTo(imageWidth * 0.485981, imageHeight * 0.317757);\n            ctx.lineTo(imageWidth * 0.485981, imageHeight * 0.467289);\n            ctx.bezierCurveTo(imageWidth * 0.485981, imageHeight * 0.467289, imageWidth * 0.485981, imageHeight * 0.471962, imageWidth * 0.481308, imageHeight * 0.471962);\n            ctx.bezierCurveTo(imageWidth * 0.471962, imageHeight * 0.481308, imageWidth * 0.467289, imageHeight * 0.490654, imageWidth * 0.467289, imageHeight * 0.5);\n            ctx.bezierCurveTo(imageWidth * 0.467289, imageHeight * 0.518691, imageWidth * 0.481308, imageHeight * 0.532710, imageWidth * 0.5, imageHeight * 0.532710);\n            ctx.bezierCurveTo(imageWidth * 0.518691, imageHeight * 0.532710, imageWidth * 0.532710, imageHeight * 0.518691, imageWidth * 0.532710, imageHeight * 0.5);\n            ctx.bezierCurveTo(imageWidth * 0.532710, imageHeight * 0.490654, imageWidth * 0.528037, imageHeight * 0.481308, imageWidth * 0.518691, imageHeight * 0.471962);\n            ctx.closePath();\n            ctx.fill();\n        };\n\n        function calcAngleStep() {\n            angleStep100ft = (TWO_PI) / (maxValue - minValue);\n            angleStep1000ft = angleStep100ft / 10;\n            angleStep10000ft = angleStep1000ft / 10;\n        }\n\n        function calcValues() {\n            value100 = (value % 1000) / 100;\n            value1000 = (value % 10000) / 100;\n            value10000 = (value % 100000) / 100;\n        }\n\n        // **************   Initialization  ********************\n        // Draw all static painting code to background\n        var init = function (parameters) {\n            parameters = parameters || {};\n            // Parameters\n            var drawFrame = (undefined === parameters.frame ? false : parameters.frame),\n                drawBackground = (undefined === parameters.background ? false : parameters.background),\n                drawPointers = (undefined === parameters.pointers ? false : parameters.pointers),\n                drawForeground = (undefined === parameters.foreground ? false : parameters.foreground);\n\n            initialized = true;\n\n            calcAngleStep();\n\n            // Create frame in frame buffer (backgroundBuffer)\n            if (drawFrame && frameVisible) {\n                drawRadialFrameImage(frameContext, frameDesign, centerX, centerY, imageWidth, imageHeight);\n            }\n\n            if (drawBackground && backgroundVisible) {\n                // Create background in background buffer (backgroundBuffer)\n                drawRadialBackgroundImage(backgroundContext, backgroundColor, centerX, centerY, imageWidth, imageHeight);\n\n                // Create custom layer in background buffer (backgroundBuffer)\n                drawRadialCustomImage(backgroundContext, customLayer, centerX, centerY, imageWidth, imageHeight);\n\n                // Create tickmarks in background buffer (backgroundBuffer)\n                drawTickmarksImage(backgroundContext, 0, TICKMARK_OFFSET, 0, 10, angleStep100ft, tickLabelPeriod, 0, true, true, null);\n            }\n\n            // Create lcd background if selected in background buffer (backgroundBuffer)\n            if (drawBackground && lcdVisible) {\n                lcdBuffer = createLcdBackgroundImage(imageWidth * 0.4, imageHeight * 0.09, lcdColor);\n                backgroundContext.drawImage(lcdBuffer, (imageWidth - (imageWidth * 0.4)) / 2, imageHeight * 0.56);\n            }\n\n            if (drawPointers) {\n                // Create 100ft pointer in buffer\n                draw100ftPointer(pointer100Context, false);\n                // Create 1000ft pointer in buffer\n                draw1000ftPointer(pointer1000Context, false);\n                // Create 10000ft pointer in buffer\n                draw10000ftPointer(pointer10000Context, false);\n            }\n\n            if (drawForeground && foregroundVisible) {\n                drawRadialForegroundImage(foregroundContext, foregroundType, imageWidth, imageHeight, true, knobType, knobStyle);\n            }\n        };\n\n        var resetBuffers = function (buffers) {\n            buffers = buffers || {};\n            var resetFrame = (undefined === buffers.frame ? false : buffers.frame),\n                resetBackground = (undefined === buffers.background ? false : buffers.background),\n                resetPointers = (undefined === buffers.pointers ? false : buffers.pointers),\n                resetForeground = (undefined === buffers.foreground ? false : buffers.foreground);\n\n            if (resetFrame) {\n                frameBuffer.width = size;\n                frameBuffer.height = size;\n                frameContext = frameBuffer.getContext('2d');\n            }\n\n            if (resetBackground) {\n                backgroundBuffer.width = size;\n                backgroundBuffer.height = size;\n                backgroundContext = backgroundBuffer.getContext('2d');\n            }\n\n            if (resetPointers) {\n                pointer100Buffer.width = size;\n                pointer100Buffer.height = size;\n                pointer100Context = pointer100Buffer.getContext('2d');\n\n                pointer1000Buffer.width = size;\n                pointer1000Buffer.height = size;\n                pointer1000Context = pointer1000Buffer.getContext('2d');\n\n                pointer10000Buffer.width = size;\n                pointer10000Buffer.height = size;\n                pointer10000Context = pointer10000Buffer.getContext('2d');\n            }\n\n            if (resetForeground) {\n                foregroundBuffer.width = size;\n                foregroundBuffer.height = size;\n                foregroundContext = foregroundBuffer.getContext('2d');\n            }\n        };\n\n        //************************************ Public methods **************************************\n        this.setValue = function (newValue) {\n            value = parseFloat(newValue);\n            this.repaint();\n        };\n\n        this.getValue = function () {\n            return value;\n        };\n\n        this.setValueAnimated = function (newValue, callback) {\n            newValue = parseFloat(newValue);\n            var targetValue = (newValue < minValue ? minValue : newValue),\n                gauge = this,\n                time;\n\n            if (value !== targetValue) {\n                if (undefined !==  tween && tween.isPlaying) {\n                    tween.stop();\n                }\n                // Allow 5 secs per 10,000ft\n                time = Math.max(Math.abs(value - targetValue) / 10000 * 5, 1);\n                tween = new Tween({}, '', Tween.regularEaseInOut, value, targetValue, time);\n                //tween = new Tween(new Object(), '', Tween.strongEaseInOut, value, targetValue, 1);\n                tween.onMotionChanged = function (event) {\n                        value = event.target._pos;\n                        if (!repainting) {\n                            repainting = true;\n                            requestAnimFrame(gauge.repaint);\n                        }\n                    };\n\n                // do we have a callback function to process?\n                if (callback && typeof(callback) === \"function\") {\n                    tween.onMotionFinished = callback;\n                }\n\n                tween.start();\n            }\n            return this;\n        };\n\n        this.setFrameDesign = function (newFrameDesign) {\n            resetBuffers({frame: true});\n            frameDesign = newFrameDesign;\n            init({frame: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setBackgroundColor = function (newBackgroundColor) {\n            resetBuffers({background: true,\n                          pointer: true       // type2 & 13 depend on background\n                });\n            backgroundColor = newBackgroundColor;\n            init({background: true,   // type2 & 13 depend on background\n                  pointer: true\n                });\n            this.repaint();\n            return this;\n        };\n\n        this.setForegroundType = function (newForegroundType) {\n            resetBuffers({foreground: true});\n            foregroundType = newForegroundType;\n            init({foreground: true});\n            this.repaint();\n            return this;\n        };\n\n        this.setLcdColor = function (newLcdColor) {\n            lcdColor = newLcdColor;\n            resetBuffers({background: true});\n            init({background: true});\n            this.repaint();\n            return this;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init({frame: true,\n                      background: true,\n                      led: true,\n                      pointers: true,\n                      foreground: true});\n            }\n\n            //mainCtx.save();\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n\n            // Draw frame\n            if (frameVisible) {\n                mainCtx.drawImage(frameBuffer, 0, 0);\n            }\n\n            // Draw buffered image to visible canvas\n            mainCtx.drawImage(backgroundBuffer, 0, 0);\n\n            // Draw lcd display\n            if (lcdVisible) {\n                drawLcdText(value);\n            }\n\n            // re-calculate the spearate pointer values\n            calcValues();\n\n            var shadowOffset = imageWidth * 0.006 * 0.5;\n\n            mainCtx.save();\n            //Draw 10000ft pointer\n            // Define rotation center\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate((value10000 - minValue) * angleStep10000ft);\n            mainCtx.translate(-centerX, -centerY);\n            // Set the pointer shadow params\n            mainCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n            mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset;\n            mainCtx.shadowBlur = shadowOffset * 2;\n            // Draw the pointer\n            mainCtx.drawImage(pointer10000Buffer, 0, 0);\n\n            shadowOffset = imageWidth * 0.006 * 0.75;\n            mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset;\n\n            //Draw 1000ft pointer\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate((value1000 - minValue) * angleStep1000ft - (value10000 - minValue) * angleStep10000ft);\n            mainCtx.translate(-centerX, -centerY);\n            mainCtx.drawImage(pointer1000Buffer, 0, 0);\n\n            shadowOffset = imageWidth * 0.006;\n            mainCtx.shadowOffsetX = mainCtx.shadowOffsetY = shadowOffset;\n\n            //Draw 100ft pointer\n            mainCtx.translate(centerX, centerY);\n            mainCtx.rotate((value100 - minValue) * angleStep100ft - (value1000 - minValue) * angleStep1000ft);\n            mainCtx.translate(-centerX, -centerY);\n            mainCtx.drawImage(pointer100Buffer, 0, 0);\n            mainCtx.restore();\n\n            //Draw the foregound\n            if (foregroundVisible) {\n                mainCtx.drawImage(foregroundBuffer, 0, 0);\n            }\n\n            repainting = false;\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var trafficlight = function (canvas, parameters) {\n        parameters = parameters || {};\n        var width = (undefined === parameters.width ? 0 : parameters.width),\n            height = (undefined === parameters.height ? 0 : parameters.height),\n            //\n            mainCtx = getCanvasContext(canvas),\n            prefHeight, imageWidth, imageHeight,\n            redOn = false,\n            yellowOn = false,\n            greenOn = false,\n            initialized = false,\n            housingBuffer = doc.createElement('canvas'),\n            housingCtx = housingBuffer.getContext('2d'),\n            lightGreenBuffer = doc.createElement('canvas'),\n            lightGreenCtx = lightGreenBuffer.getContext('2d'),\n            greenOnBuffer = doc.createElement('canvas'),\n            greenOnCtx = greenOnBuffer.getContext('2d'),\n            greenOffBuffer = doc.createElement('canvas'),\n            greenOffCtx = greenOffBuffer.getContext('2d'),\n            lightYellowBuffer = doc.createElement('canvas'),\n            lightYellowCtx = lightYellowBuffer.getContext('2d'),\n            yellowOnBuffer = doc.createElement('canvas'),\n            yellowOnCtx = yellowOnBuffer.getContext('2d'),\n            yellowOffBuffer = doc.createElement('canvas'),\n            yellowOffCtx = yellowOffBuffer.getContext('2d'),\n            lightRedBuffer = doc.createElement('canvas'),\n            lightRedCtx = lightRedBuffer.getContext('2d'),\n            redOnBuffer = doc.createElement('canvas'),\n            redOnCtx = redOnBuffer.getContext('2d'),\n            redOffBuffer = doc.createElement('canvas'),\n            redOffCtx = redOffBuffer.getContext('2d');\n            // End of variables\n\n        // Has a size been specified?\n        if (width === 0) {\n            width = mainCtx.canvas.width;\n        }\n        if (height === 0) {\n            height = mainCtx.canvas.height;\n        }\n\n        // Set the size - also clears the canvas\n        mainCtx.canvas.width = width;\n        mainCtx.canvas.height = height;\n\n        prefHeight = width < (height * 0.352517) ? (width * 2.836734) : height;\n        imageWidth = prefHeight * 0.352517;\n        imageHeight = prefHeight;\n\n        housingBuffer.width = imageWidth;\n        housingBuffer.height = imageHeight;\n\n        lightGreenBuffer.width = imageWidth;\n        lightGreenBuffer.height = imageHeight;\n\n        greenOnBuffer.width = imageWidth;\n        greenOnBuffer.height = imageHeight;\n\n        greenOffBuffer.width = imageWidth;\n        greenOffBuffer.height = imageHeight;\n\n        lightYellowBuffer.width = imageWidth;\n        lightYellowBuffer.height = imageHeight;\n\n        yellowOnBuffer.width = imageWidth;\n        yellowOnBuffer.height = imageHeight;\n\n        yellowOffBuffer.width = imageWidth;\n        yellowOffBuffer.height = imageHeight;\n\n        lightRedBuffer.width = imageWidth;\n        lightRedBuffer.height = imageHeight;\n\n        redOnBuffer.width = imageWidth;\n        redOnBuffer.height = imageHeight;\n\n        redOffBuffer.width = imageWidth;\n        redOffBuffer.height = imageHeight;\n\n        var drawHousing = function (ctx) {\n            var housingFill, housingFrontFill;\n\n            ctx.save();\n\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(0.107142 * imageWidth, 0);\n            ctx.lineTo(imageWidth - 0.107142 * imageWidth, 0);\n            ctx.quadraticCurveTo(imageWidth, 0, imageWidth, 0.107142 * imageWidth);\n            ctx.lineTo(imageWidth, imageHeight - 0.107142 * imageWidth);\n            ctx.quadraticCurveTo(imageWidth, imageHeight, imageWidth - 0.107142 * imageWidth, imageHeight);\n            ctx.lineTo(0.107142 * imageWidth, imageHeight);\n            ctx.quadraticCurveTo(0, imageHeight, 0, imageHeight - 0.107142 * imageWidth);\n            ctx.lineTo(0, 0.107142 * imageWidth);\n            ctx.quadraticCurveTo(0, 0, 0.107142 * imageWidth, imageHeight);\n            ctx.closePath();\n            housingFill = ctx.createLinearGradient(0.040816 * imageWidth, 0.007194 * imageHeight, 0.952101 * imageWidth, 0.995882 * imageHeight);\n            housingFill.addColorStop(0, 'rgb(152, 152, 154)');\n            housingFill.addColorStop(0.01, 'rgb(152, 152, 154)');\n            housingFill.addColorStop(0.09, '#333333');\n            housingFill.addColorStop(0.24, 'rgb(152, 152, 154)');\n            housingFill.addColorStop(0.55, 'rgb(31, 31, 31)');\n            housingFill.addColorStop(0.78, '#363636');\n            housingFill.addColorStop(0.98, '#000000');\n            housingFill.addColorStop(1, '#000000');\n            ctx.fillStyle = housingFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(0.030612 * imageWidth + 0.084183 * imageWidth, 0.010791 * imageHeight);\n            ctx.lineTo(0.030612 * imageWidth + 0.938775 * imageWidth - 0.084183 * imageWidth, 0.010791 * imageHeight);\n            ctx.quadraticCurveTo(0.030612 * imageWidth + 0.938775 * imageWidth, 0.010791 * imageHeight, 0.030612 * imageWidth + 0.938775 * imageWidth, 0.010791 * imageHeight + 0.084183 * imageWidth);\n            ctx.lineTo(0.030612 * imageWidth + 0.938775 * imageWidth, 0.010791 * imageHeight + 0.978417 * imageHeight - 0.084183 * imageWidth);\n            ctx.quadraticCurveTo(0.030612 * imageWidth + 0.938775 * imageWidth, 0.010791 * imageHeight + 0.978417 * imageHeight, 0.030612 * imageWidth + 0.938775 * imageWidth - 0.084183 * imageWidth, 0.010791 * imageHeight + 0.978417 * imageHeight);\n            ctx.lineTo(0.030612 * imageWidth + 0.084183 * imageWidth, 0.010791 * imageHeight + 0.978417 * imageHeight);\n            ctx.quadraticCurveTo(0.030612 * imageWidth, 0.010791 * imageHeight + 0.978417 * imageHeight, 0.030612 * imageWidth, 0.010791 * imageHeight + 0.978417 * imageHeight - 0.084183 * imageWidth);\n            ctx.lineTo(0.030612 * imageWidth, 0.010791 * imageHeight + 0.084183 * imageWidth);\n            ctx.quadraticCurveTo(0.030612 * imageWidth, 0.010791 * imageHeight, 0.030612 * imageWidth + 0.084183 * imageWidth, 0.010791 * imageHeight);\n            ctx.closePath();\n            housingFrontFill = ctx.createLinearGradient(-0.132653 * imageWidth, -0.053956 * imageHeight, 2.061408 * imageWidth, 0.667293 * imageHeight);\n            housingFrontFill.addColorStop(0, '#000000');\n            housingFrontFill.addColorStop(0.01, '#000000');\n            housingFrontFill.addColorStop(0.16, '#373735');\n            housingFrontFill.addColorStop(0.31, '#000000');\n            housingFrontFill.addColorStop(0.44, '#303030');\n            housingFrontFill.addColorStop(0.65, '#000000');\n            housingFrontFill.addColorStop(0.87, '#363636');\n            housingFrontFill.addColorStop(0.98, '#000000');\n            housingFrontFill.addColorStop(1, '#000000');\n            ctx.fillStyle = housingFrontFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.restore();\n        };\n\n        var drawLightGreen = function (ctx) {\n            var lightGreenFrameFill, lightGreenInnerFill, lightGreenEffectFill, lightGreenInnerShadowFill;\n\n            ctx.save();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.805755 * imageHeight, 0.397959 * imageWidth, 0, TWO_PI, false);\n            lightGreenFrameFill = ctx.createLinearGradient(0, 0.665467 * imageHeight, 0, 0.946043 * imageHeight);\n            lightGreenFrameFill.addColorStop(0, '#ffffff');\n            lightGreenFrameFill.addColorStop(0.05, 'rgb(204, 204, 204)');\n            lightGreenFrameFill.addColorStop(0.1, 'rgb(153, 153, 153)');\n            lightGreenFrameFill.addColorStop(0.17, '#666666');\n            lightGreenFrameFill.addColorStop(0.27, '#333333');\n            lightGreenFrameFill.addColorStop(1, '#010101');\n            ctx.fillStyle = lightGreenFrameFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.save();\n            ctx.scale(1.083333, 1);\n            ctx.beginPath();\n            ctx.arc(0.461538 * imageWidth, 0.816546 * imageHeight, 0.367346 * imageWidth, 0, TWO_PI, false);\n            lightGreenInnerFill = ctx.createLinearGradient(0, 0.687050 * imageHeight, 0, 0.946043 * imageHeight);\n            lightGreenInnerFill.addColorStop(0, '#000000');\n            lightGreenInnerFill.addColorStop(0.35, '#040404');\n            lightGreenInnerFill.addColorStop(0.66, '#000000');\n            lightGreenInnerFill.addColorStop(1, '#010101');\n            ctx.fillStyle = lightGreenInnerFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.809352 * imageHeight, 0.357142 * imageWidth, 0, TWO_PI, false);\n            lightGreenEffectFill = ctx.createRadialGradient(0.5 * imageWidth, 0.809352 * imageHeight, 0, 0.5 * imageWidth, 0.809352 * imageHeight, 0.362244 * imageWidth);\n            lightGreenEffectFill.addColorStop(0, '#000000');\n            lightGreenEffectFill.addColorStop(0.88, '#000000');\n            lightGreenEffectFill.addColorStop(0.95, 'rgb(94, 94, 94)');\n            lightGreenEffectFill.addColorStop(1, '#010101');\n            ctx.fillStyle = lightGreenEffectFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.809352 * imageHeight, 0.357142 * imageWidth, 0, TWO_PI, false);\n            lightGreenInnerShadowFill = ctx.createLinearGradient(0, 0.687050 * imageHeight, 0, 0.917266 * imageHeight);\n            lightGreenInnerShadowFill.addColorStop(0, '#000000');\n            lightGreenInnerShadowFill.addColorStop(1, 'rgba(1, 1, 1, 0)');\n            ctx.fillStyle = lightGreenInnerShadowFill;\n            ctx.fill();\n            ctx.restore();\n            ctx.restore();\n        };\n\n        var drawGreenOn = function (ctx) {\n            var greenOnFill, greenOnGlowFill;\n\n            ctx.save();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.809352 * imageHeight, 0.326530 * imageWidth, 0, TWO_PI, false);\n            greenOnFill = ctx.createRadialGradient(0.5 * imageWidth, 0.809352 * imageHeight, 0, 0.5 * imageWidth, 0.809352 * imageHeight, 0.326530 * imageWidth);\n            greenOnFill.addColorStop(0, 'rgb(85, 185, 123)');\n            greenOnFill.addColorStop(1, 'rgb(0, 31, 0)');\n            ctx.fillStyle = greenOnFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(0, 0.812949 * imageHeight);\n            ctx.bezierCurveTo(0, 0.910071 * imageHeight, 0.224489 * imageWidth, 0.989208 * imageHeight, 0.5 * imageWidth, 0.989208 * imageHeight);\n            ctx.bezierCurveTo(0.775510 * imageWidth, 0.989208 * imageHeight, imageWidth, 0.910071 * imageHeight, imageWidth, 0.809352 * imageHeight);\n            ctx.bezierCurveTo(0.908163 * imageWidth, 0.751798 * imageHeight, 0.704081 * imageWidth, 0.687050 * imageHeight, 0.5 * imageWidth, 0.687050 * imageHeight);\n            ctx.bezierCurveTo(0.285714 * imageWidth, 0.687050 * imageHeight, 0.081632 * imageWidth, 0.751798 * imageHeight, 0, 0.812949 * imageHeight);\n            ctx.closePath();\n            greenOnGlowFill = ctx.createRadialGradient(0.5 * imageWidth, 0.809352 * imageHeight, 0, 0.5 * imageWidth, 0.809352 * imageHeight, 0.515306 * imageWidth);\n            greenOnGlowFill.addColorStop(0, 'rgb(65, 187, 126)');\n            greenOnGlowFill.addColorStop(1, 'rgba(4, 37, 8, 0)');\n            ctx.fillStyle = greenOnGlowFill;\n            ctx.fill();\n            ctx.restore();\n            ctx.restore();\n        };\n\n        var drawGreenOff = function (ctx) {\n            var greenOffFill, greenOffInnerShadowFill;\n\n            ctx.save();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.809352 * imageHeight, 0.326530 * imageWidth, 0, TWO_PI, false);\n            greenOffFill = ctx.createRadialGradient(0.5 * imageWidth, 0.809352 * imageHeight, 0, 0.5 * imageWidth, 0.809352 * imageHeight, 0.326530 * imageWidth);\n            greenOffFill.addColorStop(0, 'rgba(0, 255, 0, 0.25)');\n            greenOffFill.addColorStop(1, 'rgba(0, 255, 0, 0.05)');\n            ctx.fillStyle = greenOffFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.809352 * imageHeight, 0.326530 * imageWidth, 0, TWO_PI, false);\n            greenOffInnerShadowFill = ctx.createRadialGradient(0.5 * imageWidth, 0.809352 * imageHeight, 0, 0.5 * imageWidth, 0.809352 * imageHeight, 0.326530 * imageWidth);\n            greenOffInnerShadowFill.addColorStop(0, 'rgba(1, 1, 1, 0)');\n            greenOffInnerShadowFill.addColorStop(0.55, 'rgba(0, 0, 0, 0)');\n            greenOffInnerShadowFill.addColorStop(0.5501, 'rgba(0, 0, 0, 0)');\n            greenOffInnerShadowFill.addColorStop(0.78, 'rgba(0, 0, 0, 0.12)');\n            greenOffInnerShadowFill.addColorStop(0.79, 'rgba(0, 0, 0, 0.12)');\n            greenOffInnerShadowFill.addColorStop(1, 'rgba(0, 0, 0, 0.5)');\n            ctx.fillStyle = greenOffInnerShadowFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.fillStyle = ctx.createPattern(hatchBuffer, 'repeat');\n            ctx.fill();\n\n            ctx.restore();\n        };\n\n        var drawLightYellow = function (ctx) {\n            var lightYellowFrameFill, lightYellowInnerFill, lightYellowEffectFill, lightYellowInnerShadowFill;\n\n            ctx.save();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.496402 * imageHeight, 0.397959 * imageWidth, 0, TWO_PI, false);\n            lightYellowFrameFill = ctx.createLinearGradient(0, 0.356115 * imageHeight, 0, 0.636690 * imageHeight);\n            lightYellowFrameFill.addColorStop(0, '#ffffff');\n            lightYellowFrameFill.addColorStop(0.05, 'rgb(204, 204, 204)');\n            lightYellowFrameFill.addColorStop(0.1, 'rgb(153, 153, 153)');\n            lightYellowFrameFill.addColorStop(0.17, '#666666');\n            lightYellowFrameFill.addColorStop(0.27, '#333333');\n            lightYellowFrameFill.addColorStop(1, '#010101');\n            ctx.fillStyle = lightYellowFrameFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.save();\n            ctx.scale(1.083333, 1);\n            ctx.beginPath();\n            ctx.arc(0.461538 * imageWidth, 0.507194 * imageHeight, 0.367346 * imageWidth, 0, TWO_PI, false);\n            lightYellowInnerFill = ctx.createLinearGradient(0, 0.377697 * imageHeight, 0, 0.636690 * imageHeight);\n            lightYellowInnerFill.addColorStop(0, '#000000');\n            lightYellowInnerFill.addColorStop(0.35, '#040404');\n            lightYellowInnerFill.addColorStop(0.66, '#000000');\n            lightYellowInnerFill.addColorStop(1, '#010101');\n            ctx.fillStyle = lightYellowInnerFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.5 * imageHeight, 0.357142 * imageWidth, 0, TWO_PI, false);\n            lightYellowEffectFill = ctx.createRadialGradient(0.5 * imageWidth, 0.5 * imageHeight, 0, 0.5 * imageWidth, 0.5 * imageHeight, 0.362244 * imageWidth);\n            lightYellowEffectFill.addColorStop(0, '#000000');\n            lightYellowEffectFill.addColorStop(0.88, '#000000');\n            lightYellowEffectFill.addColorStop(0.95, '#5e5e5e');\n            lightYellowEffectFill.addColorStop(1, '#010101');\n            ctx.fillStyle = lightYellowEffectFill;\n            ctx.fill();\n            ctx.restore();\n\n            //lIGHT_YELLOW_4_E_INNER_SHADOW_3_4\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.5 * imageHeight, 0.357142 * imageWidth, 0, TWO_PI, false);\n            lightYellowInnerShadowFill = ctx.createLinearGradient(0, 0.377697 * imageHeight, 0, 0.607913 * imageHeight);\n            lightYellowInnerShadowFill.addColorStop(0, '#000000');\n            lightYellowInnerShadowFill.addColorStop(1, 'rgba(1, 1, 1, 0)');\n            ctx.fillStyle = lightYellowInnerShadowFill;\n            ctx.fill();\n            ctx.restore();\n            ctx.restore();\n        };\n\n        var drawYellowOn = function (ctx) {\n            var yellowOnFill, yellowOnGlowFill;\n\n            ctx.save();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.5 * imageHeight, 0.326530 * imageWidth, 0, TWO_PI, false);\n            yellowOnFill = ctx.createRadialGradient(0.5 * imageWidth, 0.5 * imageHeight, 0, 0.5 * imageWidth, 0.5 * imageHeight, 0.326530 * imageWidth);\n            yellowOnFill.addColorStop(0, '#fed434');\n            yellowOnFill.addColorStop(1, '#82330c');\n            ctx.fillStyle = yellowOnFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(0, 0.503597 * imageHeight);\n            ctx.bezierCurveTo(0, 0.600719 * imageHeight, 0.224489 * imageWidth, 0.679856 * imageHeight, 0.5 * imageWidth, 0.679856 * imageHeight);\n            ctx.bezierCurveTo(0.775510 * imageWidth, 0.679856 * imageHeight, imageWidth, 0.600719 * imageHeight, imageWidth, 0.5 * imageHeight);\n            ctx.bezierCurveTo(0.908163 * imageWidth, 0.442446 * imageHeight, 0.704081 * imageWidth, 0.377697 * imageHeight, 0.5 * imageWidth, 0.377697 * imageHeight);\n            ctx.bezierCurveTo(0.285714 * imageWidth, 0.377697 * imageHeight, 0.081632 * imageWidth, 0.442446 * imageHeight, 0, 0.503597 * imageHeight);\n            ctx.closePath();\n            yellowOnGlowFill = ctx.createRadialGradient(0.5 * imageWidth, 0.5 * imageHeight, 0, 0.5 * imageWidth, 0.5 * imageHeight, 0.515306 * imageWidth);\n            yellowOnGlowFill.addColorStop(0, '#fed434');\n            yellowOnGlowFill.addColorStop(1, 'rgba(130, 51, 12, 0)');\n            ctx.fillStyle = yellowOnGlowFill;\n            ctx.fill();\n            ctx.restore();\n            ctx.restore();\n        };\n\n        var drawYellowOff = function (ctx) {\n            var yellowOffFill, yellowOffInnerShadowFill;\n\n            ctx.save();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.5 * imageHeight, 0.326530 * imageWidth, 0, TWO_PI, false);\n            yellowOffFill = ctx.createRadialGradient(0.5 * imageWidth, 0.5 * imageHeight, 0, 0.5 * imageWidth, 0.5 * imageHeight, 0.326530 * imageWidth);\n            yellowOffFill.addColorStop(0, 'rgba(255, 255, 0, 0.25)');\n            yellowOffFill.addColorStop(1, 'rgba(255, 255, 0, 0.05)');\n            ctx.fillStyle = yellowOffFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.5 * imageHeight, 0.326530 * imageWidth, 0, TWO_PI, false);\n            yellowOffInnerShadowFill = ctx.createRadialGradient(0.5 * imageWidth, 0.5 * imageHeight, 0, 0.5 * imageWidth, 0.5 * imageHeight, 0.326530 * imageWidth);\n            yellowOffInnerShadowFill.addColorStop(0, 'rgba(1, 1, 1, 0)');\n            yellowOffInnerShadowFill.addColorStop(0.55, 'rgba(0, 0, 0, 0)');\n            yellowOffInnerShadowFill.addColorStop(0.5501, 'rgba(0, 0, 0, 0)');\n            yellowOffInnerShadowFill.addColorStop(0.78, 'rgba(0, 0, 0, 0.12)');\n            yellowOffInnerShadowFill.addColorStop(0.79, 'rgba(0, 0, 0, 0.13)');\n            yellowOffInnerShadowFill.addColorStop(1, 'rgba(0, 0, 0, 0.5)');\n            ctx.fillStyle = yellowOffInnerShadowFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.fillStyle = ctx.createPattern(hatchBuffer, 'repeat');\n            ctx.fill();\n\n            ctx.restore();\n        };\n\n        var drawLightRed = function (ctx) {\n            var lightRedFrameFill, lightRedInnerFill, lightRedEffectFill, lightRedInnerShadowFill;\n\n            ctx.save();\n\n            //lIGHT_RED_7_E_FRAME_0_1\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.187050 * imageHeight, 0.397959 * imageWidth, 0, TWO_PI, false);\n            lightRedFrameFill = ctx.createLinearGradient((0.5 * imageWidth), (0.046762 * imageHeight), ((0.500000) * imageWidth), ((0.327338) * imageHeight));\n            lightRedFrameFill.addColorStop(0, '#ffffff');\n            lightRedFrameFill.addColorStop(0.05, '#cccccc');\n            lightRedFrameFill.addColorStop(0.1, '#999999');\n            lightRedFrameFill.addColorStop(0.17, '#666666');\n            lightRedFrameFill.addColorStop(0.27, '#333333');\n            lightRedFrameFill.addColorStop(1, '#010101');\n            ctx.fillStyle = lightRedFrameFill;\n            ctx.fill();\n            ctx.restore();\n\n            //lIGHT_RED_7_E_INNER_CLIP_1_2\n            ctx.save();\n            ctx.scale(1.083333, 1);\n            ctx.beginPath();\n            ctx.arc(0.461538 * imageWidth, 0.197841 * imageHeight, 0.367346 * imageWidth, 0, TWO_PI, false);\n            lightRedInnerFill = ctx.createLinearGradient((0.5 * imageWidth), (0.068345 * imageHeight), ((0.500000) * imageWidth), ((0.327338) * imageHeight));\n            lightRedInnerFill.addColorStop(0, '#000000');\n            lightRedInnerFill.addColorStop(0.35, '#040404');\n            lightRedInnerFill.addColorStop(0.66, '#000000');\n            lightRedInnerFill.addColorStop(1, '#010101');\n            ctx.fillStyle = lightRedInnerFill;\n            ctx.fill();\n            ctx.restore();\n\n            //lIGHT_RED_7_E_LIGHT_EFFECT_2_3\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.190647 * imageHeight, 0.357142 * imageWidth, 0, TWO_PI, false);\n            lightRedEffectFill = ctx.createRadialGradient((0.5) * imageWidth, ((0.190647) * imageHeight), 0, ((0.5) * imageWidth), ((0.190647) * imageHeight), 0.362244 * imageWidth);\n            lightRedEffectFill.addColorStop(0, '#000000');\n            lightRedEffectFill.addColorStop(0.88, '#000000');\n            lightRedEffectFill.addColorStop(0.95, '#5e5e5e');\n            lightRedEffectFill.addColorStop(1, '#010101');\n            ctx.fillStyle = lightRedEffectFill;\n            ctx.fill();\n            ctx.restore();\n\n            //lIGHT_RED_7_E_INNER_SHADOW_3_4\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.190647 * imageHeight, 0.357142 * imageWidth, 0, TWO_PI, false);\n            lightRedInnerShadowFill = ctx.createLinearGradient((0.5 * imageWidth), (0.068345 * imageHeight), ((0.500000) * imageWidth), ((0.298561) * imageHeight));\n            lightRedInnerShadowFill.addColorStop(0, '#000000');\n            lightRedInnerShadowFill.addColorStop(1, 'rgba(1, 1, 1, 0)');\n            ctx.fillStyle = lightRedInnerShadowFill;\n            ctx.fill();\n            ctx.restore();\n            ctx.restore();\n        };\n\n        var drawRedOn = function (ctx) {\n            var redOnFill, redOnGlowFill;\n\n            ctx.save();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.190647 * imageHeight, 0.326530 * imageWidth, 0, TWO_PI, false);\n            redOnFill = ctx.createRadialGradient(0.5 * imageWidth, 0.190647 * imageHeight, 0, 0.5 * imageWidth, 0.190647 * imageHeight, 0.326530 * imageWidth);\n            redOnFill.addColorStop(0, '#ff0000');\n            redOnFill.addColorStop(1, '#410004');\n            ctx.fillStyle = redOnFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(0, 0.194244 * imageHeight);\n            ctx.bezierCurveTo(0, 0.291366 * imageHeight, 0.224489 * imageWidth, 0.370503 * imageHeight, 0.5 * imageWidth, 0.370503 * imageHeight);\n            ctx.bezierCurveTo(0.775510 * imageWidth, 0.370503 * imageHeight, imageWidth, 0.291366 * imageHeight, imageWidth, 0.190647 * imageHeight);\n            ctx.bezierCurveTo(0.908163 * imageWidth, 0.133093 * imageHeight, 0.704081 * imageWidth, 0.068345 * imageHeight, 0.5 * imageWidth, 0.068345 * imageHeight);\n            ctx.bezierCurveTo(0.285714 * imageWidth, 0.068345 * imageHeight, 0.081632 * imageWidth, 0.133093 * imageHeight, 0, 0.194244 * imageHeight);\n            ctx.closePath();\n            redOnGlowFill = ctx.createRadialGradient(0.5 * imageWidth, 0.190647 * imageHeight, 0, 0.5 * imageWidth, 0.190647 * imageHeight, 0.515306 * imageWidth);\n            redOnGlowFill.addColorStop(0, '#ff0000');\n            redOnGlowFill.addColorStop(1, 'rgba(118, 5, 1, 0)');\n            ctx.fillStyle = redOnGlowFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.restore();\n        };\n\n        var drawRedOff = function (ctx) {\n            var redOffFill, redOffInnerShadowFill;\n\n            ctx.save();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.190647 * imageHeight, 0.326530 * imageWidth, 0, TWO_PI, false);\n            redOffFill = ctx.createRadialGradient(0.5 * imageWidth, 0.190647 * imageHeight, 0, 0.5 * imageWidth, 0.190647 * imageHeight, 0.326530 * imageWidth);\n            redOffFill.addColorStop(0, 'rgba(255, 0, 0, 0.25)');\n            redOffFill.addColorStop(1, 'rgba(255, 0, 0, 0.05)');\n            ctx.fillStyle = redOffFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.save();\n            ctx.scale(1, 1);\n            ctx.beginPath();\n            ctx.arc(0.5 * imageWidth, 0.190647 * imageHeight, 0.326530 * imageWidth, 0, TWO_PI, false);\n            redOffInnerShadowFill = ctx.createRadialGradient(0.5 * imageWidth, 0.190647 * imageHeight, 0, 0.5 * imageWidth, 0.190647 * imageHeight, 0.326530 * imageWidth);\n            redOffInnerShadowFill.addColorStop(0, 'rgba(1, 1, 1, 0)');\n            redOffInnerShadowFill.addColorStop(0.55, 'rgba(0, 0, 0, 0)');\n            redOffInnerShadowFill.addColorStop(0.5501, 'rgba(0, 0, 0, 0)');\n            redOffInnerShadowFill.addColorStop(0.78, 'rgba(0, 0, 0, 0.12)');\n            redOffInnerShadowFill.addColorStop(0.79, 'rgba(0, 0, 0, 0.13)');\n            redOffInnerShadowFill.addColorStop(1, 'rgba(0, 0, 0, 0.5)');\n            ctx.fillStyle = redOffInnerShadowFill;\n            ctx.fill();\n            ctx.restore();\n\n            ctx.fillStyle = ctx.createPattern(hatchBuffer, 'repeat');\n            ctx.fill();\n\n            ctx.restore();\n        };\n\n        function drawToBuffer(width, height, drawFunction) {\n            var buffer = doc.createElement('canvas');\n            buffer.width = width;\n            buffer.height = height;\n            drawFunction(buffer.getContext('2d'));\n            return buffer;\n        }\n\n        var hatchBuffer = drawToBuffer(2, 2, function (ctx) {\n            ctx.save();\n            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';\n            ctx.beginPath();\n            ctx.lineTo(0, 0, 1, 0);\n            ctx.lineTo(0, 1, 0, 1);\n            ctx.stroke();\n            ctx.restore();\n        });\n\n        var init = function () {\n            initialized = true;\n\n            drawHousing(housingCtx);\n            drawLightGreen(lightGreenCtx);\n            drawGreenOn(greenOnCtx);\n            drawGreenOff(greenOffCtx);\n            drawLightYellow(lightYellowCtx);\n            drawYellowOn(yellowOnCtx);\n            drawYellowOff(yellowOffCtx);\n            drawLightRed(lightRedCtx);\n            drawRedOn(redOnCtx);\n            drawRedOff(redOffCtx);\n        };\n\n        // **************   P U B L I C   M E T H O D S   ********************************\n        this.setRedOn = function (on) {\n            redOn = !!on;\n            this.repaint();\n        };\n\n        this.isRedOn = function () {\n            return redOn;\n        };\n\n        this.setYellowOn = function (on) {\n            yellowOn = !!on;\n            this.repaint();\n        };\n\n        this.isYellowOn = function () {\n            return yellowOn;\n        };\n\n        this.setGreenOn = function (on) {\n            greenOn = !!on;\n            this.repaint();\n        };\n\n        this.isGreenOn = function () {\n            return greenOn;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init();\n            }\n\n            mainCtx.save();\n            mainCtx.clearRect(0, 0, mainCtx.canvas.width, mainCtx.canvas.height);\n\n            // housing\n            mainCtx.drawImage(housingBuffer, 0, 0);\n\n            // Green light\n            mainCtx.drawImage(lightGreenBuffer, 0, 0);\n\n            if (greenOn) {\n                mainCtx.drawImage(greenOnBuffer, 0, 0);\n            }\n\n            mainCtx.drawImage(greenOffBuffer, 0, 0);\n\n            // Yellow light\n            mainCtx.drawImage(lightYellowBuffer, 0, 0);\n\n            if (yellowOn) {\n                mainCtx.drawImage(yellowOnBuffer, 0, 0);\n            }\n\n            mainCtx.drawImage(yellowOffBuffer, 0, 0);\n\n            // Red light\n            mainCtx.drawImage(lightRedBuffer, 0, 0);\n\n            if (redOn) {\n                mainCtx.drawImage(redOnBuffer, 0, 0);\n            }\n\n            mainCtx.drawImage(redOffBuffer, 0, 0);\n            mainCtx.restore();\n        };\n\n        // Visualize the component\n        this.repaint();\n\n        return this;\n    };\n\n    var lightbulb = function (canvas, parameters) {\n        parameters = parameters || {};\n        var mainCtx,\n            // parameters\n            width = (undefined === parameters.width ? 0 : parameters.width),\n            height = (undefined === parameters.height ? 0 : parameters.height),\n            glowColor = (undefined === parameters.glowColor ? '#ffff00' : parameters.glowColor),\n            //\n            size, imageWidth, imageHeight,\n            initialized = false,\n            lightOn = false,\n            alpha = 1,\n            offBuffer = doc.createElement('canvas'),\n            offCtx = offBuffer.getContext('2d'),\n            onBuffer = doc.createElement('canvas'),\n            onCtx = onBuffer.getContext('2d'),\n            bulbBuffer = doc.createElement('canvas'),\n            bulbCtx = bulbBuffer.getContext('2d');\n            // End of variables\n\n        // Get the canvas context and clear it\n        mainCtx = document.getElementById(canvas).getContext('2d');\n\n        // Has a size been specified?\n        if (width === 0) {\n            width = mainCtx.canvas.width;\n        }\n        if (height === 0) {\n            height = mainCtx.canvas.height;\n        }\n\n        // Get the size\n        mainCtx.canvas.width = width;\n        mainCtx.canvas.height = height;\n        size = width < height ? width : height;\n        imageWidth = size;\n        imageHeight = size;\n\n        function drawToBuffer(width, height, drawFunction) {\n            var buffer = doc.createElement('canvas');\n            buffer.width = width;\n            buffer.height = height;\n            drawFunction(buffer.getContext('2d'));\n            return buffer;\n        }\n\n        var getColorValues = function (color) {\n            var colorData,\n                lookupBuffer = drawToBuffer(1, 1, function (ctx) {\n                    ctx.fillStyle = color;\n                    ctx.beginPath();\n                    ctx.rect(0, 0, 1, 1);\n                    ctx.fill();\n                });\n\n            colorData = lookupBuffer.getContext('2d').getImageData(0, 0, 2, 2).data;\n            return [colorData[0], colorData[1], colorData[2]];\n        };\n\n        offBuffer.width = imageWidth;\n        offBuffer.height = imageHeight;\n\n        onBuffer.width = imageWidth;\n        onBuffer.height = imageHeight;\n\n        bulbBuffer.width = imageWidth;\n        bulbBuffer.height = imageHeight;\n\n        var drawOff = function (ctx) {\n            var glassOffFill;\n\n            ctx.save();\n\n            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(0.289473 * imageWidth, 0.438596 * imageHeight);\n            ctx.bezierCurveTo(0.289473 * imageWidth, 0.561403 * imageHeight, 0.385964 * imageWidth, 0.605263 * imageHeight, 0.385964 * imageWidth, 0.745614 * imageHeight);\n            ctx.bezierCurveTo(0.385964 * imageWidth, 0.745614 * imageHeight, 0.587719 * imageWidth, 0.745614 * imageHeight, 0.587719 * imageWidth, 0.745614 * imageHeight);\n            ctx.bezierCurveTo(0.587719 * imageWidth, 0.605263 * imageHeight, 0.692982 * imageWidth, 0.561403 * imageHeight, 0.692982 * imageWidth, 0.438596 * imageHeight);\n            ctx.bezierCurveTo(0.692982 * imageWidth, 0.324561 * imageHeight, 0.605263 * imageWidth, 0.228070 * imageHeight, 0.5 * imageWidth, 0.228070 * imageHeight);\n            ctx.bezierCurveTo(0.385964 * imageWidth, 0.228070 * imageHeight, 0.289473 * imageWidth, 0.324561 * imageHeight, 0.289473 * imageWidth, 0.438596 * imageHeight);\n            ctx.closePath();\n            glassOffFill = ctx.createLinearGradient(0, 0.289473 * imageHeight, 0, 0.701754 * imageHeight);\n            glassOffFill.addColorStop(0, '#eeeeee');\n            glassOffFill.addColorStop(0.99, '#999999');\n            glassOffFill.addColorStop(1, '#999999');\n            ctx.fillStyle = glassOffFill;\n            ctx.fill();\n            ctx.lineCap = 'butt';\n            ctx.lineJoin = 'round';\n            ctx.lineWidth = 0.008771 * imageWidth;\n            ctx.strokeStyle = '#cccccc';\n            ctx.stroke();\n            ctx.restore();\n            ctx.restore();\n        };\n\n        var drawOn = function (ctx) {\n            var glassOnFill,\n                data = getColorValues(glowColor),\n                red = data[0],\n                green = data[1],\n                blue = data[2],\n                hsl = rgbToHsl(red, green, blue);\n\n            ctx.save();\n            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(0.289473 * imageWidth, 0.438596 * imageHeight);\n            ctx.bezierCurveTo(0.289473 * imageWidth, 0.561403 * imageHeight, 0.385964 * imageWidth, 0.605263 * imageHeight, 0.385964 * imageWidth, 0.745614 * imageHeight);\n            ctx.bezierCurveTo(0.385964 * imageWidth, 0.745614 * imageHeight, 0.587719 * imageWidth, 0.745614 * imageHeight, 0.587719 * imageWidth, 0.745614 * imageHeight);\n            ctx.bezierCurveTo(0.587719 * imageWidth, 0.605263 * imageHeight, 0.692982 * imageWidth, 0.561403 * imageHeight, 0.692982 * imageWidth, 0.438596 * imageHeight);\n            ctx.bezierCurveTo(0.692982 * imageWidth, 0.324561 * imageHeight, 0.605263 * imageWidth, 0.228070 * imageHeight, 0.5 * imageWidth, 0.228070 * imageHeight);\n            ctx.bezierCurveTo(0.385964 * imageWidth, 0.228070 * imageHeight, 0.289473 * imageWidth, 0.324561 * imageHeight, 0.289473 * imageWidth, 0.438596 * imageHeight);\n            ctx.closePath();\n\n            glassOnFill = ctx.createLinearGradient(0, 0.289473 * imageHeight, 0, 0.701754 * imageHeight);\n\n            if (red === green && green === blue) {\n                glassOnFill.addColorStop(0, 'hsl(0, 60%, 0%)');\n                glassOnFill.addColorStop(1, 'hsl(0, 40%, 0%)');\n            } else {\n                glassOnFill.addColorStop(0, 'hsl(' + hsl[0] * 255 + ', ' + hsl[1] * 100 + '%, 70%)');\n                glassOnFill.addColorStop(1, 'hsl(' + hsl[0] * 255 + ', ' + hsl[1] * 100 + '%, 80%)');\n            }\n            ctx.fillStyle = glassOnFill;\n\n            // sets shadow properties\n            ctx.shadowOffsetX = 0;\n            ctx.shadowOffsetY = 0;\n            ctx.shadowBlur = 30;\n            ctx.shadowColor = glowColor;\n\n            ctx.fill();\n\n            ctx.lineCap = 'butt';\n            ctx.lineJoin = 'round';\n            ctx.lineWidth = 0.008771 * imageWidth;\n            ctx.strokeStyle = 'rgba(' + red + ', ' + green + ', ' + blue + ', 0.4)';\n            ctx.stroke();\n\n            ctx.restore();\n\n            ctx.restore();\n        };\n\n        var drawBulb = function (ctx) {\n            var highlight, winding, winding1, contactPlate;\n\n            ctx.save();\n\n            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(0.350877 * imageWidth, 0.333333 * imageHeight);\n            ctx.bezierCurveTo(0.350877 * imageWidth, 0.280701 * imageHeight, 0.412280 * imageWidth, 0.236842 * imageHeight, 0.5 * imageWidth, 0.236842 * imageHeight);\n            ctx.bezierCurveTo(0.578947 * imageWidth, 0.236842 * imageHeight, 0.640350 * imageWidth, 0.280701 * imageHeight, 0.640350 * imageWidth, 0.333333 * imageHeight);\n            ctx.bezierCurveTo(0.640350 * imageWidth, 0.385964 * imageHeight, 0.578947 * imageWidth, 0.429824 * imageHeight, 0.5 * imageWidth, 0.429824 * imageHeight);\n            ctx.bezierCurveTo(0.412280 * imageWidth, 0.429824 * imageHeight, 0.350877 * imageWidth, 0.385964 * imageHeight, 0.350877 * imageWidth, 0.333333 * imageHeight);\n            ctx.closePath();\n            highlight = ctx.createLinearGradient(0, 0.245614 * imageHeight, 0, 0.429824 * imageHeight);\n            highlight.addColorStop(0, '#ffffff');\n            highlight.addColorStop(0.99, 'rgba(255, 255, 255, 0)');\n            highlight.addColorStop(1, 'rgba(255, 255, 255, 0)');\n            ctx.fillStyle = highlight;\n            ctx.fill();\n            ctx.restore();\n\n            //winding\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(0.377192 * imageWidth, 0.745614 * imageHeight);\n            ctx.bezierCurveTo(0.377192 * imageWidth, 0.745614 * imageHeight, 0.429824 * imageWidth, 0.728070 * imageHeight, 0.491228 * imageWidth, 0.728070 * imageHeight);\n            ctx.bezierCurveTo(0.561403 * imageWidth, 0.728070 * imageHeight, 0.605263 * imageWidth, 0.736842 * imageHeight, 0.605263 * imageWidth, 0.736842 * imageHeight);\n            ctx.lineTo(0.605263 * imageWidth, 0.763157 * imageHeight);\n            ctx.lineTo(0.596491 * imageWidth, 0.780701 * imageHeight);\n            ctx.lineTo(0.605263 * imageWidth, 0.798245 * imageHeight);\n            ctx.lineTo(0.596491 * imageWidth, 0.815789 * imageHeight);\n            ctx.lineTo(0.605263 * imageWidth, 0.833333 * imageHeight);\n            ctx.lineTo(0.596491 * imageWidth, 0.850877 * imageHeight);\n            ctx.lineTo(0.605263 * imageWidth, 0.868421 * imageHeight);\n            ctx.lineTo(0.596491 * imageWidth, 0.885964 * imageHeight);\n            ctx.lineTo(0.605263 * imageWidth, 0.894736 * imageHeight);\n            ctx.bezierCurveTo(0.605263 * imageWidth, 0.894736 * imageHeight, 0.570175 * imageWidth, 0.956140 * imageHeight, 0.535087 * imageWidth, 0.991228 * imageHeight);\n            ctx.bezierCurveTo(0.526315 * imageWidth, 0.991228 * imageHeight, 0.517543 * imageWidth, imageHeight, 0.5 * imageWidth, imageHeight);\n            ctx.bezierCurveTo(0.482456 * imageWidth, imageHeight, 0.473684 * imageWidth, imageHeight, 0.464912 * imageWidth, 0.991228 * imageHeight);\n            ctx.bezierCurveTo(0.421052 * imageWidth, 0.947368 * imageHeight, 0.394736 * imageWidth, 0.903508 * imageHeight, 0.394736 * imageWidth, 0.903508 * imageHeight);\n            ctx.lineTo(0.394736 * imageWidth, 0.894736 * imageHeight);\n            ctx.lineTo(0.385964 * imageWidth, 0.885964 * imageHeight);\n            ctx.lineTo(0.394736 * imageWidth, 0.868421 * imageHeight);\n            ctx.lineTo(0.385964 * imageWidth, 0.850877 * imageHeight);\n            ctx.lineTo(0.394736 * imageWidth, 0.833333 * imageHeight);\n            ctx.lineTo(0.385964 * imageWidth, 0.815789 * imageHeight);\n            ctx.lineTo(0.394736 * imageWidth, 0.798245 * imageHeight);\n            ctx.lineTo(0.377192 * imageWidth, 0.789473 * imageHeight);\n            ctx.lineTo(0.394736 * imageWidth, 0.771929 * imageHeight);\n            ctx.lineTo(0.377192 * imageWidth, 0.763157 * imageHeight);\n            ctx.lineTo(0.377192 * imageWidth, 0.745614 * imageHeight);\n            ctx.closePath();\n            winding = ctx.createLinearGradient(0.473684 * imageWidth, 0.728070 * imageHeight, 0.484702 * imageWidth, 0.938307 * imageHeight);\n            winding.addColorStop(0, '#333333');\n            winding.addColorStop(0.04, '#d9dad6');\n            winding.addColorStop(0.19, '#e4e5e0');\n            winding.addColorStop(0.24, '#979996');\n            winding.addColorStop(0.31, '#fbffff');\n            winding.addColorStop(0.4, '#818584');\n            winding.addColorStop(0.48, '#f5f7f4');\n            winding.addColorStop(0.56, '#959794');\n            winding.addColorStop(0.64, '#f2f2f0');\n            winding.addColorStop(0.7, '#828783');\n            winding.addColorStop(0.78, '#fcfcfc');\n            winding.addColorStop(1, '#666666');\n            ctx.fillStyle = winding;\n            ctx.fill();\n            ctx.restore();\n\n            // winding\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(0.377192 * imageWidth, 0.745614 * imageHeight);\n            ctx.bezierCurveTo(0.377192 * imageWidth, 0.745614 * imageHeight, 0.429824 * imageWidth, 0.728070 * imageHeight, 0.491228 * imageWidth, 0.728070 * imageHeight);\n            ctx.bezierCurveTo(0.561403 * imageWidth, 0.728070 * imageHeight, 0.605263 * imageWidth, 0.736842 * imageHeight, 0.605263 * imageWidth, 0.736842 * imageHeight);\n            ctx.lineTo(0.605263 * imageWidth, 0.763157 * imageHeight);\n            ctx.lineTo(0.596491 * imageWidth, 0.780701 * imageHeight);\n            ctx.lineTo(0.605263 * imageWidth, 0.798245 * imageHeight);\n            ctx.lineTo(0.596491 * imageWidth, 0.815789 * imageHeight);\n            ctx.lineTo(0.605263 * imageWidth, 0.833333 * imageHeight);\n            ctx.lineTo(0.596491 * imageWidth, 0.850877 * imageHeight);\n            ctx.lineTo(0.605263 * imageWidth, 0.868421 * imageHeight);\n            ctx.lineTo(0.596491 * imageWidth, 0.885964 * imageHeight);\n            ctx.lineTo(0.605263 * imageWidth, 0.894736 * imageHeight);\n            ctx.bezierCurveTo(0.605263 * imageWidth, 0.894736 * imageHeight, 0.570175 * imageWidth, 0.956140 * imageHeight, 0.535087 * imageWidth, 0.991228 * imageHeight);\n            ctx.bezierCurveTo(0.526315 * imageWidth, 0.991228 * imageHeight, 0.517543 * imageWidth, imageHeight, 0.5 * imageWidth, imageHeight);\n            ctx.bezierCurveTo(0.482456 * imageWidth, imageHeight, 0.473684 * imageWidth, imageHeight, 0.464912 * imageWidth, 0.991228 * imageHeight);\n            ctx.bezierCurveTo(0.421052 * imageWidth, 0.947368 * imageHeight, 0.394736 * imageWidth, 0.903508 * imageHeight, 0.394736 * imageWidth, 0.903508 * imageHeight);\n            ctx.lineTo(0.394736 * imageWidth, 0.894736 * imageHeight);\n            ctx.lineTo(0.385964 * imageWidth, 0.885964 * imageHeight);\n            ctx.lineTo(0.394736 * imageWidth, 0.868421 * imageHeight);\n            ctx.lineTo(0.385964 * imageWidth, 0.850877 * imageHeight);\n            ctx.lineTo(0.394736 * imageWidth, 0.833333 * imageHeight);\n            ctx.lineTo(0.385964 * imageWidth, 0.815789 * imageHeight);\n            ctx.lineTo(0.394736 * imageWidth, 0.798245 * imageHeight);\n            ctx.lineTo(0.377192 * imageWidth, 0.789473 * imageHeight);\n            ctx.lineTo(0.394736 * imageWidth, 0.771929 * imageHeight);\n            ctx.lineTo(0.377192 * imageWidth, 0.763157 * imageHeight);\n            ctx.lineTo(0.377192 * imageWidth, 0.745614 * imageHeight);\n            ctx.closePath();\n            winding1 = ctx.createLinearGradient(0.377192 * imageWidth, 0.789473 * imageHeight, 0.605263 * imageWidth, 0.789473 * imageHeight);\n            winding1.addColorStop(0, 'rgba(0, 0, 0, 0.4)');\n            winding1.addColorStop(0.15, 'rgba(0, 0, 0, 0.32)');\n            winding1.addColorStop(0.85, 'rgba(0, 0, 0, 0.33)');\n            winding1.addColorStop(1, 'rgba(0, 0, 0, 0.4)');\n            ctx.fillStyle = winding1;\n            ctx.fill();\n            ctx.restore();\n\n            // contact plate\n            ctx.save();\n            ctx.beginPath();\n            ctx.moveTo(0.421052 * imageWidth, 0.947368 * imageHeight);\n            ctx.bezierCurveTo(0.438596 * imageWidth, 0.956140 * imageHeight, 0.447368 * imageWidth, 0.973684 * imageHeight, 0.464912 * imageWidth, 0.991228 * imageHeight);\n            ctx.bezierCurveTo(0.473684 * imageWidth, imageHeight, 0.482456 * imageWidth, imageHeight, 0.5 * imageWidth, imageHeight);\n            ctx.bezierCurveTo(0.517543 * imageWidth, imageHeight, 0.526315 * imageWidth, 0.991228 * imageHeight, 0.535087 * imageWidth, 0.991228 * imageHeight);\n            ctx.bezierCurveTo(0.543859 * imageWidth, 0.982456 * imageHeight, 0.561403 * imageWidth, 0.956140 * imageHeight, 0.578947 * imageWidth, 0.947368 * imageHeight);\n            ctx.bezierCurveTo(0.552631 * imageWidth, 0.938596 * imageHeight, 0.526315 * imageWidth, 0.938596 * imageHeight, 0.5 * imageWidth, 0.938596 * imageHeight);\n            ctx.bezierCurveTo(0.473684 * imageWidth, 0.938596 * imageHeight, 0.447368 * imageWidth, 0.938596 * imageHeight, 0.421052 * imageWidth, 0.947368 * imageHeight);\n            ctx.closePath();\n            contactPlate = ctx.createLinearGradient(0, 0.938596 * imageHeight, 0, imageHeight);\n            contactPlate.addColorStop(0, '#050a06');\n            contactPlate.addColorStop(0.61, '#070602');\n            contactPlate.addColorStop(0.71, '#999288');\n            contactPlate.addColorStop(0.83, '#010101');\n            contactPlate.addColorStop(1, '#000000');\n            ctx.fillStyle = contactPlate;\n            ctx.fill();\n            ctx.restore();\n            ctx.restore();\n        };\n\n        var clearCanvas = function (ctx) {\n            // Store the current transformation matrix\n            ctx.save();\n\n            // Use the identity matrix while clearing the canvas\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n            // Restore the transform\n            ctx.restore();\n        };\n\n        var init = function () {\n            initialized = true;\n            drawOff(offCtx);\n            drawOn(onCtx);\n            drawBulb(bulbCtx);\n        };\n\n        // **************   P U B L I C   M E T H O D S   ********************************\n        this.setOn = function (on) {\n            lightOn = !!on;\n            this.repaint();\n            return this;\n        };\n\n        this.isOn = function () {\n            return lightOn;\n        };\n\n        this.setAlpha = function (a) {\n            alpha = a;\n            this.repaint();\n            return this;\n        };\n\n        this.getAlpha = function () {\n            return alpha;\n        };\n\n        this.setGlowColor = function (color) {\n            glowColor = color;\n            init();\n            this.repaint();\n            return this;\n        };\n\n        this.getGlowColor = function () {\n            return glowColor;\n        };\n\n        // Component visualization\n        this.repaint = function () {\n            if (!initialized) {\n                init();\n            }\n\n            clearCanvas(mainCtx);\n\n            mainCtx.save();\n\n            mainCtx.drawImage(offBuffer, 0, 0);\n\n            mainCtx.globalAlpha = alpha;\n            if (lightOn) {\n                mainCtx.drawImage(onBuffer, 0, 0);\n            }\n            mainCtx.globalAlpha = 1;\n            mainCtx.drawImage(bulbBuffer, 0, 0);\n            mainCtx.restore();\n        };\n\n        this.repaint();\n\n        return this;\n    };\n\n    var odometer = function (canvas, parameters) {\n        parameters = parameters || {};\n\n        // parameters\n        var _context = (undefined === parameters._context ? null : parameters._context),  // If component used internally by steelseries\n            height = (undefined === parameters.height ? 0 : parameters.height),\n            digits = (undefined === parameters.digits ? 6 : parameters.digits),\n            decimals = (undefined === parameters.decimals ? 1 : parameters.decimals),\n            decimalBackColor = (undefined === parameters.decimalBackColor ? '#F0F0F0' : parameters.decimalBackColor),\n            decimalForeColor = (undefined === parameters.decimalForeColor ? '#F01010' : parameters.decimalForeColor),\n            font = (undefined === parameters.font ? 'sans-serif' : parameters.font),\n            value = (undefined === parameters.value ? 0 : parameters.value),\n            valueBackColor = (undefined === parameters.valueBackColor ? '#050505' : parameters.valueBackColor),\n            valueForeColor = (undefined === parameters.valueForeColor ? '#F8F8F8' : parameters.valueForeColor),\n            wobbleFactor = (undefined === parameters.wobbleFactor ? 0.07 : parameters.wobbleFactor),\n            //\n            initialized = false,\n            tween, ctx,\n            repainting = false,\n            digitHeight, digitWidth, stdFont,\n            width, columnHeight, verticalSpace, zeroOffset,\n            wobble = [],\n            //buffers\n            backgroundBuffer, backgroundContext,\n            foregroundBuffer, foregroundContext,\n            digitBuffer, digitContext,\n            decimalBuffer, decimalContext;\n            // End of variables\n\n        // Get the canvas context and clear it\n        if (_context) {\n            ctx = _context;\n        } else {\n            ctx = getCanvasContext(canvas);\n        }\n\n        // Has a height been specified?\n        if (height === 0) {\n            height = ctx.canvas.height;\n        }\n\n        // Cannot display negative values yet\n        if (value < 0) {\n            value = 0;\n        }\n\n        digitHeight = Math.floor(height * 0.85);\n        stdFont = '600 ' + digitHeight + 'px ' + font;\n\n        digitWidth = Math.floor(height * 0.68);\n        width = digitWidth * (digits + decimals);\n        columnHeight = digitHeight * 11;\n        verticalSpace = columnHeight / 12;\n        zeroOffset = verticalSpace * 0.81;\n\n        // Resize and clear the main context\n        ctx.canvas.width = width;\n        ctx.canvas.height = height;\n\n        // Create buffers\n        backgroundBuffer = createBuffer(width, height);\n        backgroundContext = backgroundBuffer.getContext('2d');\n\n        foregroundBuffer = createBuffer(width, height);\n        foregroundContext = foregroundBuffer.getContext('2d');\n\n        digitBuffer = createBuffer(digitWidth, columnHeight * 1.1);\n        digitContext = digitBuffer.getContext('2d');\n\n        decimalBuffer = createBuffer(digitWidth, columnHeight * 1.1);\n        decimalContext = decimalBuffer.getContext('2d');\n\n        function init() {\n            var grad, i;\n\n            initialized = true;\n\n            // Create the foreground\n            foregroundContext.rect(0, 0, width, height);\n            grad = foregroundContext.createLinearGradient(0, 0, 0, height);\n            grad.addColorStop(0, 'rgba(0, 0, 0, 1)');\n            grad.addColorStop(0.1, 'rgba(0, 0, 0, 0.4)');\n            grad.addColorStop(0.33, 'rgba(255, 255, 255, 0.45)');\n            grad.addColorStop(0.46, 'rgba(255, 255, 255, 0)');\n            grad.addColorStop(0.9, 'rgba(0, 0, 0, 0.4)');\n            grad.addColorStop(1, 'rgba(0, 0, 0, 1)');\n            foregroundContext.fillStyle = grad;\n            foregroundContext.fill();\n\n            // Create a digit column\n            // background\n            digitContext.rect(0, 0, digitWidth, columnHeight * 1.1);\n            digitContext.fillStyle = valueBackColor;\n            digitContext.fill();\n            // edges\n            digitContext.strokeStyle = '#f0f0f0';\n            digitContext.lineWidth = '1px'; //height * 0.1 + 'px';\n            digitContext.moveTo(0, 0);\n            digitContext.lineTo(0, columnHeight * 1.1);\n            digitContext.stroke();\n            digitContext.strokeStyle = '#202020';\n            digitContext.moveTo(digitWidth, 0);\n            digitContext.lineTo(digitWidth, columnHeight * 1.1);\n            digitContext.stroke();\n            // numerals\n            digitContext.textAlign = 'center';\n            digitContext.textBaseline = 'middle';\n            digitContext.font = stdFont;\n            digitContext.fillStyle = valueForeColor;\n            // put the digits 901234567890 vertically into the buffer\n            for (i = 9; i < 21; i++) {\n                digitContext.fillText(i % 10, digitWidth * 0.5, verticalSpace * (i - 9) + verticalSpace / 2);\n            }\n\n            // Create a decimal column\n            if (decimals > 0) {\n                // background\n                decimalContext.rect(0, 0, digitWidth, columnHeight * 1.1);\n                decimalContext.fillStyle = decimalBackColor;\n                decimalContext.fill();\n                // edges\n                decimalContext.strokeStyle = '#f0f0f0';\n                decimalContext.lineWidth = '1px'; //height * 0.1 + 'px';\n                decimalContext.moveTo(0, 0);\n                decimalContext.lineTo(0, columnHeight * 1.1);\n                decimalContext.stroke();\n                decimalContext.strokeStyle = '#202020';\n                decimalContext.moveTo(digitWidth, 0);\n                decimalContext.lineTo(digitWidth, columnHeight * 1.1);\n                decimalContext.stroke();\n                // numerals\n                decimalContext.textAlign = 'center';\n                decimalContext.textBaseline = 'middle';\n                decimalContext.font = stdFont;\n                decimalContext.fillStyle = decimalForeColor;\n                // put the digits 901234567890 vertically into the buffer\n                for (i = 9; i < 21; i++) {\n                    decimalContext.fillText(i % 10, digitWidth * 0.5, verticalSpace * (i - 9) + verticalSpace / 2);\n                }\n            }\n            // wobble factors\n            for (i = 0; i < (digits + decimals); i++) {\n                wobble[i] = Math.random() * wobbleFactor * height - wobbleFactor * height / 2;\n            }\n\n        }\n\n        function drawDigits() {\n            var pos = 1,\n            val = value, i, num, numb, frac, prevNum;\n\n            // do not use Math.pow() - rounding errors!\n            for (i = 0; i < decimals; i++) {\n                val *= 10;\n            }\n\n            numb = Math.floor(val);\n            frac = val - numb;\n            numb = String(numb);\n            prevNum = 9;\n\n            for (i = 0; i < decimals + digits; i++) {\n                num = +numb.substring(numb.length - i - 1, numb.length - i) || 0;\n                if (prevNum !== 9) {\n                    frac = 0;\n                }\n                if (i < decimals) {\n                    backgroundContext.drawImage(decimalBuffer, width - digitWidth * pos, -(verticalSpace * (num + frac) + zeroOffset + wobble[i]));\n                } else {\n                    backgroundContext.drawImage(digitBuffer, width - digitWidth * pos, -(verticalSpace * (num + frac) + zeroOffset + wobble[i]));\n                }\n                pos++;\n                prevNum = num;\n            }\n        }\n\n        this.setValueAnimated = function (newVal, callback) {\n            var gauge = this;\n            newVal = parseFloat(newVal);\n\n            if (newVal < 0) {\n                newVal = 0;\n            }\n            if (value !== newVal) {\n                if (undefined !== tween && tween.isPlaying) {\n                    tween.stop();\n                }\n\n                tween = new Tween({}, '', Tween.strongEaseOut, value, newVal, 2);\n                tween.onMotionChanged = function (event) {\n                    value = event.target._pos;\n                    if (!repainting) {\n                        repainting = true;\n                        requestAnimFrame(gauge.repaint);\n                    }\n                };\n\n                // do we have a callback function to process?\n                if (callback && typeof(callback) === \"function\") {\n                    tween.onMotionFinished = callback;\n                }\n\n                tween.start();\n            }\n            this.repaint();\n            return this;\n        };\n\n        this.setValue = function (newVal) {\n            value = parseFloat(newVal);\n            if (value < 0) {\n                value = 0;\n            }\n            this.repaint();\n            return this;\n        };\n\n        this.getValue = function () {\n            return value;\n        };\n\n        this.repaint = function () {\n            if (!initialized) {\n                init();\n            }\n\n            // draw digits\n            drawDigits();\n\n            // draw the foreground\n            backgroundContext.drawImage(foregroundBuffer, 0, 0);\n\n            // paint back to the main context\n            ctx.drawImage(backgroundBuffer, 0, 0);\n\n            repainting = false;\n        };\n\n        this.repaint();\n    };\n\n    //************************************  I M A G E   -   F U N C T I O N S  *****************************************\n\n    var drawRoseImage = function (ctx, centerX, centerY, imageWidth, imageHeight, backgroundColor) {\n        var fill = true,\n            i, grad,\n            symbolColor = backgroundColor.symbolColor.getRgbaColor();\n\n        ctx.save();\n        ctx.lineWidth = 1;\n        ctx.fillStyle = symbolColor;\n        ctx.strokeStyle = symbolColor;\n        ctx.translate(centerX, centerY);\n        // broken ring\n        for (i = 0; i < 360; i += 15) {\n            fill = !fill;\n\n            ctx.beginPath();\n            ctx.arc(0, 0, imageWidth * 0.26, i * RAD_FACTOR, (i + 15) * RAD_FACTOR, false);\n            ctx.arc(0, 0, imageWidth * 0.23, (i + 15) * RAD_FACTOR, i * RAD_FACTOR, true);\n            ctx.closePath();\n            if (fill) {\n                ctx.fill();\n            }\n            ctx.stroke();\n        }\n\n        ctx.translate(-centerX, -centerY);\n\n/*\n        // PATH1_2\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(imageWidth * 0.560747, imageHeight * 0.584112);\n        ctx.lineTo(imageWidth * 0.640186, imageHeight * 0.644859);\n        ctx.lineTo(imageWidth * 0.584112, imageHeight * 0.560747);\n        ctx.lineTo(imageWidth * 0.560747, imageHeight * 0.584112);\n        ctx.closePath();\n        ctx.fillStyle = fillColorPath;\n        ctx.fill();\n        ctx.stroke();\n\n        // PATH2_2\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(imageWidth * 0.411214, imageHeight * 0.560747);\n        ctx.lineTo(imageWidth * 0.355140, imageHeight * 0.644859);\n        ctx.lineTo(imageWidth * 0.439252, imageHeight * 0.588785);\n        ctx.lineTo(imageWidth * 0.411214, imageHeight * 0.560747);\n        ctx.closePath();\n        ctx.fillStyle = fillColorPath;\n        ctx.fill();\n        ctx.stroke();\n\n        // PATH3_2\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(imageWidth * 0.584112, imageHeight * 0.443925);\n        ctx.lineTo(imageWidth * 0.640186, imageHeight * 0.359813);\n        ctx.lineTo(imageWidth * 0.560747, imageHeight * 0.420560);\n        ctx.lineTo(imageWidth * 0.584112, imageHeight * 0.443925);\n        ctx.closePath();\n        ctx.fillStyle = fillColorPath;\n        ctx.fill();\n        ctx.stroke();\n\n        // PATH4_2\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(imageWidth * 0.439252, imageHeight * 0.415887);\n        ctx.lineTo(imageWidth * 0.355140, imageHeight * 0.359813);\n        ctx.lineTo(imageWidth * 0.415887, imageHeight * 0.439252);\n        ctx.lineTo(imageWidth * 0.439252, imageHeight * 0.415887);\n        ctx.closePath();\n        ctx.fillStyle = fillColorPath;\n        ctx.fill();\n        ctx.stroke();\n\n        // PATH5_2\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(imageWidth * 0.523364, imageHeight * 0.397196);\n        ctx.lineTo(imageWidth * 0.5, imageHeight * 0.196261);\n        ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.397196);\n        ctx.lineTo(imageWidth * 0.523364, imageHeight * 0.397196);\n        ctx.closePath();\n        var PATH5_2_GRADIENT = ctx.createLinearGradient(0.476635 * imageWidth, 0, 0.518691 * imageWidth, 0);\n        PATH5_2_GRADIENT.addColorStop(0, 'rgb(222, 223, 218)');\n        PATH5_2_GRADIENT.addColorStop(0.48, 'rgb(222, 223, 218)');\n        PATH5_2_GRADIENT.addColorStop(0.49, backgroundColor.symbolColor.getRgbaColor());\n        PATH5_2_GRADIENT.addColorStop(1, backgroundColor.symbolColor.getRgbaColor());\n        ctx.fillStyle = PATH5_2_GRADIENT;\n        ctx.fill();\n        ctx.stroke();\n\n        // PATH6_2\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(imageWidth * 0.471962, imageHeight * 0.607476);\n        ctx.lineTo(imageWidth * 0.5, imageHeight * 0.813084);\n        ctx.lineTo(imageWidth * 0.523364, imageHeight * 0.607476);\n        ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.607476);\n        ctx.closePath();\n        var PATH6_2_GRADIENT = ctx.createLinearGradient(0.518691 * imageWidth, 0, (0.518691 + -0.037383) * imageWidth, 0);\n        PATH6_2_GRADIENT.addColorStop(0, 'rgb(222, 223, 218)');\n        PATH6_2_GRADIENT.addColorStop(0.56, 'rgb(222, 223, 218)');\n        PATH6_2_GRADIENT.addColorStop(0.5601, backgroundColor.symbolColor.getRgbaColor());\n        PATH6_2_GRADIENT.addColorStop(1, backgroundColor.symbolColor.getRgbaColor());\n        ctx.fillStyle = PATH6_2_GRADIENT;\n        ctx.lineWidth = 1;\n        ctx.lineCap = 'square';\n        ctx.lineJoin = 'miter';\n        ctx.strokeStyle = backgroundColor.symbolColor.getRgbaColor();\n        ctx.fill();\n        ctx.stroke();\n\n        // PATH7_2\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(imageWidth * 0.602803, imageHeight * 0.528037);\n        ctx.lineTo(imageWidth * 0.803738, imageHeight * 0.5);\n        ctx.lineTo(imageWidth * 0.602803, imageHeight * 0.476635);\n        ctx.lineTo(imageWidth * 0.602803, imageHeight * 0.528037);\n        ctx.closePath();\n        var PATH7_2_GRADIENT = ctx.createLinearGradient(0, 0.485981 * imageHeight, 0, 0.514018 * imageHeight);\n        PATH7_2_GRADIENT.addColorStop(0, 'rgb(222, 223, 218)');\n        PATH7_2_GRADIENT.addColorStop(0.48, 'rgb(222, 223, 218)');\n        PATH7_2_GRADIENT.addColorStop(0.49, backgroundColor.symbolColor.getRgbaColor());\n        PATH7_2_GRADIENT.addColorStop(1, backgroundColor.symbolColor.getRgbaColor());\n        ctx.fillStyle = PATH7_2_GRADIENT;\n        ctx.fill();\n        ctx.stroke();\n\n        // PATH8_2\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(imageWidth * 0.392523, imageHeight * 0.476635);\n        ctx.lineTo(imageWidth * 0.191588, imageHeight * 0.5);\n        ctx.lineTo(imageWidth * 0.392523, imageHeight * 0.528037);\n        ctx.lineTo(imageWidth * 0.392523, imageHeight * 0.476635);\n        ctx.closePath();\n        var PATH8_2_GRADIENT = ctx.createLinearGradient(0, 0.528037 * imageHeight, 0, 0.485981 * imageHeight);\n        PATH8_2_GRADIENT.addColorStop(0, 'rgb(222, 223, 218)');\n        PATH8_2_GRADIENT.addColorStop(0.52, 'rgb(222, 223, 218)');\n        PATH8_2_GRADIENT.addColorStop(0.53, backgroundColor.symbolColor.getRgbaColor());\n        PATH8_2_GRADIENT.addColorStop(1, backgroundColor.symbolColor.getRgbaColor());\n        ctx.fillStyle = PATH8_2_GRADIENT;\n        ctx.fill();\n        ctx.stroke();\n\n        // PATH9_2\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(imageWidth * 0.406542, imageHeight * 0.504672);\n        ctx.bezierCurveTo(imageWidth * 0.406542, imageHeight * 0.453271, imageWidth * 0.448598, imageHeight * 0.411214, imageWidth * 0.5, imageHeight * 0.411214);\n        ctx.bezierCurveTo(imageWidth * 0.546728, imageHeight * 0.411214, imageWidth * 0.588785, imageHeight * 0.453271, imageWidth * 0.588785, imageHeight * 0.504672);\n        ctx.bezierCurveTo(imageWidth * 0.588785, imageHeight * 0.551401, imageWidth * 0.546728, imageHeight * 0.593457, imageWidth * 0.5, imageHeight * 0.593457);\n        ctx.bezierCurveTo(imageWidth * 0.448598, imageHeight * 0.593457, imageWidth * 0.406542, imageHeight * 0.551401, imageWidth * 0.406542, imageHeight * 0.504672);\n        ctx.closePath();\n        ctx.moveTo(imageWidth * 0.387850, imageHeight * 0.504672);\n        ctx.bezierCurveTo(imageWidth * 0.387850, imageHeight * 0.560747, imageWidth * 0.439252, imageHeight * 0.612149, imageWidth * 0.5, imageHeight * 0.612149);\n        ctx.bezierCurveTo(imageWidth * 0.556074, imageHeight * 0.612149, imageWidth * 0.607476, imageHeight * 0.560747, imageWidth * 0.607476, imageHeight * 0.504672);\n        ctx.bezierCurveTo(imageWidth * 0.607476, imageHeight * 0.443925, imageWidth * 0.556074, imageHeight * 0.392523, imageWidth * 0.5, imageHeight * 0.392523);\n        ctx.bezierCurveTo(imageWidth * 0.439252, imageHeight * 0.392523, imageWidth * 0.387850, imageHeight * 0.443925, imageWidth * 0.387850, imageHeight * 0.504672);\n        ctx.closePath();\n        ctx.fillStyle = fillColorPath;\n        ctx.lineWidth = 1;\n        ctx.lineCap = 'square';\n        ctx.lineJoin = 'miter';\n        ctx.strokeStyle = backgroundColor.symbolColor.getRgbaColor();\n        ctx.fill();\n        ctx.stroke();\n        ctx.restore();\n*/\n        // Replacement code, not quite the same but much smaller!\n\n        for (i = 0; 360 >= i; i += 90) {\n            // Small pointers\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.560747, imageHeight * 0.584112);\n            ctx.lineTo(imageWidth * 0.640186, imageHeight * 0.644859);\n            ctx.lineTo(imageWidth * 0.584112, imageHeight * 0.560747);\n            ctx.lineTo(imageWidth * 0.560747, imageHeight * 0.584112);\n            ctx.closePath();\n            ctx.fillStyle = symbolColor;\n            ctx.fill();\n            ctx.stroke();\n            // Large pointers\n            ctx.beginPath();\n            ctx.moveTo(imageWidth * 0.523364, imageHeight * 0.397196);\n            ctx.lineTo(imageWidth * 0.5, imageHeight * 0.196261);\n            ctx.lineTo(imageWidth * 0.471962, imageHeight * 0.397196);\n            ctx.lineTo(imageWidth * 0.523364, imageHeight * 0.397196);\n            ctx.closePath();\n            grad = ctx.createLinearGradient(0.476635 * imageWidth, 0, 0.518691 * imageWidth, 0);\n            grad.addColorStop(0, 'rgb(222, 223, 218)');\n            grad.addColorStop(0.48, 'rgb(222, 223, 218)');\n            grad.addColorStop(0.49, symbolColor);\n            grad.addColorStop(1, symbolColor);\n            ctx.fillStyle = grad;\n            ctx.fill();\n            ctx.stroke();\n            ctx.translate(centerX, centerY);\n            ctx.rotate(i * RAD_FACTOR);\n            ctx.translate(-centerX, -centerY);\n        }\n\n        // Central ring\n        ctx.beginPath();\n        ctx.translate(centerX, centerY);\n        ctx.arc(0, 0, imageWidth * 0.1, 0, TWO_PI, false);\n        ctx.lineWidth = imageWidth * 0.022;\n        ctx.stroke();\n        ctx.translate(-centerX, -centerY);\n\n        ctx.restore();\n\n    };\n\n    var drawPointerImage = function (ctx, size, ptrType, ptrColor, lblColor) {\n        var ptrBuffer, ptrCtx,\n            grad, radius,\n            cacheKey = size.toString() + ptrType.type + ptrColor.light.getHexColor() + ptrColor.medium.getHexColor();\n\n        // check if we have already created and cached this buffer, if not create it\n        if (!drawPointerImage.cache[cacheKey]) {\n            // create a pointer buffer\n            ptrBuffer = createBuffer(size, size);\n            ptrCtx = ptrBuffer.getContext('2d');\n\n            switch (ptrType.type) {\n            case 'type2':\n                grad = ptrCtx.createLinearGradient(0, size * 0.471962, 0, size * 0.130841);\n                grad.addColorStop(0, lblColor.getRgbaColor());\n                grad.addColorStop(0.36, lblColor.getRgbaColor());\n                grad.addColorStop(0.361, ptrColor.light.getRgbaColor());\n                grad.addColorStop(1, ptrColor.light.getRgbaColor());\n                ptrCtx.fillStyle = grad;\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(size * 0.518691, size * 0.471962);\n                ptrCtx.lineTo(size * 0.509345, size * 0.462616);\n                ptrCtx.lineTo(size * 0.509345, size * 0.341121);\n                ptrCtx.lineTo(size * 0.504672, size * 0.130841);\n                ptrCtx.lineTo(size * 0.495327, size * 0.130841);\n                ptrCtx.lineTo(size * 0.490654, size * 0.341121);\n                ptrCtx.lineTo(size * 0.490654, size * 0.462616);\n                ptrCtx.lineTo(size * 0.481308, size * 0.471962);\n                ptrCtx.closePath();\n                ptrCtx.fill();\n                break;\n\n            case 'type3':\n                ptrCtx.beginPath();\n                ptrCtx.rect(size * 0.495327, size * 0.130841, size * 0.009345, size * 0.373831);\n                ptrCtx.closePath();\n                ptrCtx.fillStyle = ptrColor.light.getRgbaColor();\n                ptrCtx.fill();\n                break;\n\n            case 'type4':\n                grad = ptrCtx.createLinearGradient(0.467289 * size, 0, 0.528036 * size, 0);\n                grad.addColorStop(0, ptrColor.dark.getRgbaColor());\n                grad.addColorStop(0.51, ptrColor.dark.getRgbaColor());\n                grad.addColorStop(0.52, ptrColor.light.getRgbaColor());\n                grad.addColorStop(1, ptrColor.light.getRgbaColor());\n                ptrCtx.fillStyle = grad;\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(size * 0.5, size * 0.126168);\n                ptrCtx.lineTo(size * 0.514018, size * 0.135514);\n                ptrCtx.lineTo(size * 0.532710, size * 0.5);\n                ptrCtx.lineTo(size * 0.523364, size * 0.602803);\n                ptrCtx.lineTo(size * 0.476635, size * 0.602803);\n                ptrCtx.lineTo(size * 0.467289, size * 0.5);\n                ptrCtx.lineTo(size * 0.485981, size * 0.135514);\n                ptrCtx.lineTo(size * 0.5, size * 0.126168);\n                ptrCtx.closePath();\n                ptrCtx.fill();\n                break;\n\n            case 'type5':\n                grad = ptrCtx.createLinearGradient(0.471962 * size, 0, 0.528036 * size, 0);\n                grad.addColorStop(0, ptrColor.light.getRgbaColor());\n                grad.addColorStop(0.5, ptrColor.light.getRgbaColor());\n                grad.addColorStop(0.5, ptrColor.medium.getRgbaColor());\n                grad.addColorStop(1, ptrColor.medium.getRgbaColor());\n                ptrCtx.fillStyle = grad;\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(size * 0.5, size * 0.495327);\n                ptrCtx.lineTo(size * 0.528037, size * 0.495327);\n                ptrCtx.lineTo(size * 0.5, size * 0.149532);\n                ptrCtx.lineTo(size * 0.471962, size * 0.495327);\n                ptrCtx.lineTo(size * 0.5, size * 0.495327);\n                ptrCtx.closePath();\n                ptrCtx.fill();\n\n                ptrCtx.lineWidth = 1;\n                ptrCtx.lineCap = 'square';\n                ptrCtx.lineJoin = 'miter';\n                ptrCtx.strokeStyle = ptrColor.dark.getRgbaColor();\n                ptrCtx.stroke();\n                break;\n\n            case 'type6':\n                ptrCtx.fillStyle = ptrColor.medium.getRgbaColor();\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(size * 0.481308, size * 0.485981);\n                ptrCtx.lineTo(size * 0.481308, size * 0.392523);\n                ptrCtx.lineTo(size * 0.485981, size * 0.317757);\n                ptrCtx.lineTo(size * 0.495327, size * 0.130841);\n                ptrCtx.lineTo(size * 0.504672, size * 0.130841);\n                ptrCtx.lineTo(size * 0.514018, size * 0.317757);\n                ptrCtx.lineTo(size * 0.518691, size * 0.387850);\n                ptrCtx.lineTo(size * 0.518691, size * 0.485981);\n                ptrCtx.lineTo(size * 0.504672, size * 0.485981);\n                ptrCtx.lineTo(size * 0.504672, size * 0.387850);\n                ptrCtx.lineTo(size * 0.5, size * 0.317757);\n                ptrCtx.lineTo(size * 0.495327, size * 0.392523);\n                ptrCtx.lineTo(size * 0.495327, size * 0.485981);\n                ptrCtx.lineTo(size * 0.481308, size * 0.485981);\n                ptrCtx.closePath();\n                ptrCtx.fill();\n                break;\n\n            case 'type7':\n                grad = ptrCtx.createLinearGradient(0.481308 * size, 0, 0.518691 * size, 0);\n                grad.addColorStop(0, ptrColor.dark.getRgbaColor());\n                grad.addColorStop(1, ptrColor.medium.getRgbaColor());\n                ptrCtx.fillStyle = grad;\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(size * 0.490654, size * 0.130841);\n                ptrCtx.lineTo(size * 0.481308, size * 0.5);\n                ptrCtx.lineTo(size * 0.518691, size * 0.5);\n                ptrCtx.lineTo(size * 0.504672, size * 0.130841);\n                ptrCtx.lineTo(size * 0.490654, size * 0.130841);\n                ptrCtx.closePath();\n                ptrCtx.fill();\n                break;\n\n            case 'type8':\n                grad = ptrCtx.createLinearGradient(0.471962 * size, 0, 0.528036 * size, 0);\n                grad.addColorStop(0, ptrColor.light.getRgbaColor());\n                grad.addColorStop(0.5, ptrColor.light.getRgbaColor());\n                grad.addColorStop(0.5, ptrColor.medium.getRgbaColor());\n                grad.addColorStop(1, ptrColor.medium.getRgbaColor());\n                ptrCtx.fillStyle = grad;\n                ptrCtx.strokeStyle = ptrColor.dark.getRgbaColor();\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(size * 0.5, size * 0.532710);\n                ptrCtx.lineTo(size * 0.532710, size * 0.5);\n                ptrCtx.bezierCurveTo(size * 0.532710, size * 0.5, size * 0.509345, size * 0.457943, size * 0.5, size * 0.149532);\n                ptrCtx.bezierCurveTo(size * 0.490654, size * 0.457943, size * 0.467289, size * 0.5, size * 0.467289, size * 0.5);\n                ptrCtx.lineTo(size * 0.5, size * 0.532710);\n                ptrCtx.closePath();\n                ptrCtx.fill();\n                ptrCtx.stroke();\n                break;\n\n            case 'type9':\n                grad = ptrCtx.createLinearGradient(0.471962 * size, 0, 0.528036 * size, 0);\n                grad.addColorStop(0, 'rgb(50, 50, 50)');\n                grad.addColorStop(0.5, '#666666');\n                grad.addColorStop(1, 'rgb(50, 50, 50)');\n                ptrCtx.fillStyle = grad;\n                ptrCtx.strokeStyle = '#2E2E2E';\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(size * 0.495327, size * 0.233644);\n                ptrCtx.lineTo(size * 0.504672, size * 0.233644);\n                ptrCtx.lineTo(size * 0.514018, size * 0.439252);\n                ptrCtx.lineTo(size * 0.485981, size * 0.439252);\n                ptrCtx.lineTo(size * 0.495327, size * 0.233644);\n                ptrCtx.closePath();\n                ptrCtx.moveTo(size * 0.490654, size * 0.130841);\n                ptrCtx.lineTo(size * 0.471962, size * 0.471962);\n                ptrCtx.lineTo(size * 0.471962, size * 0.528037);\n                ptrCtx.bezierCurveTo(size * 0.471962, size * 0.528037, size * 0.476635, size * 0.602803, size * 0.476635, size * 0.602803);\n                ptrCtx.bezierCurveTo(size * 0.476635, size * 0.607476, size * 0.481308, size * 0.607476, size * 0.5, size * 0.607476);\n                ptrCtx.bezierCurveTo(size * 0.518691, size * 0.607476, size * 0.523364, size * 0.607476, size * 0.523364, size * 0.602803);\n                ptrCtx.bezierCurveTo(size * 0.523364, size * 0.602803, size * 0.528037, size * 0.528037, size * 0.528037, size * 0.528037);\n                ptrCtx.lineTo(size * 0.528037, size * 0.471962);\n                ptrCtx.lineTo(size * 0.509345, size * 0.130841);\n                ptrCtx.lineTo(size * 0.490654, size * 0.130841);\n                ptrCtx.closePath();\n                ptrCtx.fill();\n\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(size * 0.495327, size * 0.219626);\n                ptrCtx.lineTo(size * 0.504672, size * 0.219626);\n                ptrCtx.lineTo(size * 0.504672, size * 0.135514);\n                ptrCtx.lineTo(size * 0.495327, size * 0.135514);\n                ptrCtx.lineTo(size * 0.495327, size * 0.219626);\n                ptrCtx.closePath();\n\n                ptrCtx.fillStyle = ptrColor.medium.getRgbaColor();\n                ptrCtx.fill();\n                break;\n\n            case 'type10':\n                // POINTER_TYPE10\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(size * 0.5, size * 0.149532);\n                ptrCtx.bezierCurveTo(size * 0.5, size * 0.149532, size * 0.443925, size * 0.490654, size * 0.443925, size * 0.5);\n                ptrCtx.bezierCurveTo(size * 0.443925, size * 0.532710, size * 0.467289, size * 0.556074, size * 0.5, size * 0.556074);\n                ptrCtx.bezierCurveTo(size * 0.532710, size * 0.556074, size * 0.556074, size * 0.532710, size * 0.556074, size * 0.5);\n                ptrCtx.bezierCurveTo(size * 0.556074, size * 0.490654, size * 0.5, size * 0.149532, size * 0.5, size * 0.149532);\n                ptrCtx.closePath();\n                grad = ptrCtx.createLinearGradient(0.471962 * size, 0, 0.528036 * size, 0);\n                grad.addColorStop(0, ptrColor.light.getRgbaColor());\n                grad.addColorStop(0.5, ptrColor.light.getRgbaColor());\n                grad.addColorStop(0.5, ptrColor.medium.getRgbaColor());\n                grad.addColorStop(1, ptrColor.medium.getRgbaColor());\n                ptrCtx.fillStyle = grad;\n                ptrCtx.strokeStyle = ptrColor.medium.getRgbaColor();\n                ptrCtx.lineWidth = 1;\n                ptrCtx.lineCap = 'square';\n                ptrCtx.lineJoin = 'miter';\n                ptrCtx.fill();\n                ptrCtx.stroke();\n                break;\n\n            case 'type11':\n                // POINTER_TYPE11\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(0.5 * size, 0.168224 * size);\n                ptrCtx.lineTo(0.485981 * size, 0.5 * size);\n                ptrCtx.bezierCurveTo(0.485981 * size, 0.5 * size, 0.481308 * size, 0.584112 * size, 0.5 * size, 0.584112 * size);\n                ptrCtx.bezierCurveTo(0.514018 * size, 0.584112 * size, 0.509345 * size, 0.5 * size, 0.509345 * size, 0.5 * size);\n                ptrCtx.lineTo(0.5 * size, 0.168224 * size);\n                ptrCtx.closePath();\n                grad = ptrCtx.createLinearGradient(0, 0.168224 * size, 0, 0.584112 * size);\n                grad.addColorStop(0, ptrColor.medium.getRgbaColor());\n                grad.addColorStop(1, ptrColor.dark.getRgbaColor());\n                ptrCtx.fillStyle = grad;\n                ptrCtx.strokeStyle = ptrColor.dark.getRgbaColor();\n                ptrCtx.fill();\n                ptrCtx.stroke();\n                break;\n\n            case 'type12':\n                // POINTER_TYPE12\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(0.5 * size, 0.168224 * size);\n                ptrCtx.lineTo(0.485981 * size, 0.5 * size);\n                ptrCtx.lineTo(0.5 * size, 0.504672 * size);\n                ptrCtx.lineTo(0.509345 * size, 0.5 * size);\n                ptrCtx.lineTo(0.5 * size, 0.168224 * size);\n                ptrCtx.closePath();\n                grad = ptrCtx.createLinearGradient(0, 0.168224 * size, 0, 0.504672 * size);\n                grad.addColorStop(0, ptrColor.medium.getRgbaColor());\n                grad.addColorStop(1, ptrColor.dark.getRgbaColor());\n                ptrCtx.fillStyle = grad;\n                ptrCtx.strokeStyle = ptrColor.dark.getRgbaColor();\n                ptrCtx.fill();\n                ptrCtx.stroke();\n                break;\n\n            case 'type13':\n                // POINTER_TYPE13\n            case 'type14':\n                // POINTER_TYPE14 (same shape as 13)\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(0.485981 * size, 0.168224 * size);\n                ptrCtx.lineTo(0.5 * size, 0.130841 * size);\n                ptrCtx.lineTo(0.509345 * size, 0.168224 * size);\n                ptrCtx.lineTo(0.509345 * size, 0.509345 * size);\n                ptrCtx.lineTo(0.485981 * size, 0.509345 * size);\n                ptrCtx.lineTo(0.485981 * size, 0.168224 * size);\n                ptrCtx.closePath();\n                if (ptrType.type === 'type13') {\n                    // TYPE13\n                    grad = ptrCtx.createLinearGradient(0, 0.5 * size, 0, 0.130841 * size);\n                    grad.addColorStop(0, lblColor.getRgbaColor());\n                    grad.addColorStop(0.85, lblColor.getRgbaColor());\n                    grad.addColorStop(0.85, ptrColor.medium.getRgbaColor());\n                    grad.addColorStop(1, ptrColor.medium.getRgbaColor());\n                    ptrCtx.fillStyle = grad;\n                } else {\n                    // TYPE14\n                    grad = ptrCtx.createLinearGradient(0.485981 * size, 0, 0.509345 * size, 0);\n                    grad.addColorStop(0, ptrColor.veryDark.getRgbaColor());\n                    grad.addColorStop(0.5, ptrColor.light.getRgbaColor());\n                    grad.addColorStop(1, ptrColor.veryDark.getRgbaColor());\n                    ptrCtx.fillStyle = grad;\n                }\n                ptrCtx.fill();\n                break;\n\n            case 'type15':\n                // POINTER TYPE15 - Classic with crescent\n            case 'type16':\n                // POINTER TYPE16 - Classic without crescent\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(size * 0.509345, size * 0.457943);\n                ptrCtx.lineTo(size * 0.5015, size * 0.13);\n                ptrCtx.lineTo(size * 0.4985, size * 0.13);\n                ptrCtx.lineTo(size * 0.490654, size * 0.457943);\n                ptrCtx.bezierCurveTo(size * 0.490654, size * 0.457943, size * 0.490654, size * 0.457943, size * 0.490654, size * 0.457943);\n                ptrCtx.bezierCurveTo(size * 0.471962, size * 0.462616, size * 0.457943, size * 0.481308, size * 0.457943, size * 0.5);\n                ptrCtx.bezierCurveTo(size * 0.457943, size * 0.518691, size * 0.471962, size * 0.537383, size * 0.490654, size * 0.542056);\n                ptrCtx.bezierCurveTo(size * 0.490654, size * 0.542056, size * 0.490654, size * 0.542056, size * 0.490654, size * 0.542056);\n                if (ptrType.type === 'type15') {\n                    ptrCtx.lineTo(size * 0.490654, size * 0.57);\n                    ptrCtx.bezierCurveTo(size * 0.46, size * 0.58, size * 0.46, size * 0.62, size * 0.490654, size * 0.63);\n                    ptrCtx.bezierCurveTo(size * 0.47, size * 0.62, size * 0.48, size * 0.59, size * 0.5, size * 0.59);\n                    ptrCtx.bezierCurveTo(size * 0.53, size * 0.59, size * 0.52, size * 0.62, size * 0.509345, size * 0.63);\n                    ptrCtx.bezierCurveTo(size * 0.54, size * 0.62, size * 0.54, size * 0.58, size * 0.509345, size * 0.57);\n                    ptrCtx.lineTo(size * 0.509345, size * 0.57);\n                } else {\n                    ptrCtx.lineTo(size * 0.490654, size * 0.621495);\n                    ptrCtx.lineTo(size * 0.509345, size * 0.621495);\n                }\n                ptrCtx.lineTo(size * 0.509345, size * 0.542056);\n                ptrCtx.bezierCurveTo(size * 0.509345, size * 0.542056, size * 0.509345, size * 0.542056, size * 0.509345, size * 0.542056);\n                ptrCtx.bezierCurveTo(size * 0.528037, size * 0.537383, size * 0.542056, size * 0.518691, size * 0.542056, size * 0.5);\n                ptrCtx.bezierCurveTo(size * 0.542056, size * 0.481308, size * 0.528037, size * 0.462616, size * 0.509345, size * 0.457943);\n                ptrCtx.bezierCurveTo(size * 0.509345, size * 0.457943, size * 0.509345, size * 0.457943, size * 0.509345, size * 0.457943);\n                ptrCtx.closePath();\n                if (ptrType.type === 'type15') {\n                    grad = ptrCtx.createLinearGradient(0, 0, 0, size * 0.63);\n                } else {\n                    grad = ptrCtx.createLinearGradient(0, 0, 0, size * 0.621495);\n                }\n                grad.addColorStop(0, ptrColor.medium.getRgbaColor());\n                grad.addColorStop(0.388888, ptrColor.medium.getRgbaColor());\n                grad.addColorStop(0.5, ptrColor.light.getRgbaColor());\n                grad.addColorStop(0.611111, ptrColor.medium.getRgbaColor());\n                grad.addColorStop(1, ptrColor.medium.getRgbaColor());\n                ptrCtx.fillStyle = grad;\n                ptrCtx.strokeStyle = ptrColor.dark.getRgbaColor();\n                ptrCtx.fill();\n                ptrCtx.stroke();\n                // Draw the rings\n                ptrCtx.beginPath();\n                radius = size * 0.065420 / 2;\n                ptrCtx.arc(size * 0.5, size * 0.5, radius, 0, TWO_PI);\n                grad = ptrCtx.createLinearGradient(size * 0.5 - radius, size * 0.5 + radius, 0, size * 0.5 + radius);\n                grad.addColorStop(0, '#e6b35c');\n                grad.addColorStop(0.01, '#e6b35c');\n                grad.addColorStop(0.99, '#c48200');\n                grad.addColorStop(1, '#c48200');\n                ptrCtx.fillStyle = grad;\n                ptrCtx.closePath();\n                ptrCtx.fill();\n                ptrCtx.beginPath();\n                radius = size * 0.046728 / 2;\n                ptrCtx.arc(size * 0.5, size * 0.5, radius, 0, TWO_PI);\n                grad = ptrCtx.createRadialGradient(size * 0.5, size * 0.5, 0, size * 0.5, size * 0.5, radius);\n                grad.addColorStop(0, '#c5c5c5');\n                grad.addColorStop(0.19, '#c5c5c5');\n                grad.addColorStop(0.22, '#000000');\n                grad.addColorStop(0.8, '#000000');\n                grad.addColorStop(0.99, '#707070');\n                grad.addColorStop(1, '#707070');\n                ptrCtx.fillStyle = grad;\n                ptrCtx.closePath();\n                ptrCtx.fill();\n                break;\n\n            case 'type1':\n            /* falls through */\n            default:\n                grad = ptrCtx.createLinearGradient(0, size * 0.471962, 0, size * 0.130841);\n                grad.addColorStop(0, ptrColor.veryDark.getRgbaColor());\n                grad.addColorStop(0.3, ptrColor.medium.getRgbaColor());\n                grad.addColorStop(0.59, ptrColor.medium.getRgbaColor());\n                grad.addColorStop(1, ptrColor.veryDark.getRgbaColor());\n                ptrCtx.fillStyle = grad;\n                ptrCtx.beginPath();\n                ptrCtx.moveTo(size * 0.518691, size * 0.471962);\n                ptrCtx.bezierCurveTo(size * 0.514018, size * 0.457943, size * 0.509345, size * 0.415887, size * 0.509345, size * 0.401869);\n                ptrCtx.bezierCurveTo(size * 0.504672, size * 0.383177, size * 0.5, size * 0.130841, size * 0.5, size * 0.130841);\n                ptrCtx.bezierCurveTo(size * 0.5, size * 0.130841, size * 0.490654, size * 0.383177, size * 0.490654, size * 0.397196);\n                ptrCtx.bezierCurveTo(size * 0.490654, size * 0.415887, size * 0.485981, size * 0.457943, size * 0.481308, size * 0.471962);\n                ptrCtx.bezierCurveTo(size * 0.471962, size * 0.481308, size * 0.467289, size * 0.490654, size * 0.467289, size * 0.5);\n                ptrCtx.bezierCurveTo(size * 0.467289, size * 0.518691, size * 0.481308, size * 0.532710, size * 0.5, size * 0.532710);\n                ptrCtx.bezierCurveTo(size * 0.518691, size * 0.532710, size * 0.532710, size * 0.518691, size * 0.532710, size * 0.5);\n                ptrCtx.bezierCurveTo(size * 0.532710, size * 0.490654, size * 0.528037, size * 0.481308, size * 0.518691, size * 0.471962);\n                ptrCtx.closePath();\n                ptrCtx.fill();\n                break;\n            }\n            // cache buffer\n            drawPointerImage.cache[cacheKey] = ptrBuffer;\n        }\n        ctx.drawImage(drawPointerImage.cache[cacheKey], 0, 0);\n        return this;\n    };\n    drawPointerImage.cache = {};\n\n    var drawRadialFrameImage = function (ctx, frameDesign, centerX, centerY, imageWidth, imageHeight) {\n        var radFBuffer, radFCtx,\n            grad, outerX, innerX, fractions, colors,\n            cacheKey = imageWidth.toString() + imageHeight + frameDesign.design;\n\n        // check if we have already created and cached this buffer, if not create it\n        if (!drawRadialFrameImage.cache[cacheKey]) {\n            // Setup buffer\n            radFBuffer = createBuffer(imageWidth, imageHeight);\n            radFCtx = radFBuffer.getContext('2d');\n\n            // outer gray frame\n            radFCtx.fillStyle = '#848484';\n            radFCtx.strokeStyle = 'rgba(132, 132, 132, 0.5)';\n            radFCtx.beginPath();\n            radFCtx.arc(centerX, centerY, imageWidth / 2, 0, TWO_PI, true);\n            radFCtx.closePath();\n            radFCtx.fill();\n            radFCtx.stroke();\n\n            radFCtx.beginPath();\n            radFCtx.arc(centerX, centerY, imageWidth * 0.990654 / 2, 0, TWO_PI, true);\n            radFCtx.closePath();\n\n            // main gradient frame\n            switch (frameDesign.design) {\n            case 'metal':\n                grad = radFCtx.createLinearGradient(0, imageWidth * 0.004672, 0, imageHeight * 0.990654);\n                grad.addColorStop(0, '#fefefe');\n                grad.addColorStop(0.07, 'rgb(210, 210, 210)');\n                grad.addColorStop(0.12, 'rgb(179, 179, 179)');\n                grad.addColorStop(1, 'rgb(213, 213, 213)');\n                radFCtx.fillStyle = grad;\n                radFCtx.fill();\n                break;\n\n            case 'brass':\n                grad = radFCtx.createLinearGradient(0, imageWidth * 0.004672, 0, imageHeight * 0.990654);\n                grad.addColorStop(0, 'rgb(249, 243, 155)');\n                grad.addColorStop(0.05, 'rgb(246, 226, 101)');\n                grad.addColorStop(0.10, 'rgb(240, 225, 132)');\n                grad.addColorStop(0.50, 'rgb(90, 57, 22)');\n                grad.addColorStop(0.90, 'rgb(249, 237, 139)');\n                grad.addColorStop(0.95, 'rgb(243, 226, 108)');\n                grad.addColorStop(1, 'rgb(202, 182, 113)');\n                radFCtx.fillStyle = grad;\n                radFCtx.fill();\n                break;\n\n            case 'steel':\n                grad = radFCtx.createLinearGradient(0, imageWidth * 0.004672, 0, imageHeight * 0.990654);\n                grad.addColorStop(0, 'rgb(231, 237, 237)');\n                grad.addColorStop(0.05, 'rgb(189, 199, 198)');\n                grad.addColorStop(0.10, 'rgb(192, 201, 200)');\n                grad.addColorStop(0.50, 'rgb(23, 31, 33)');\n                grad.addColorStop(0.90, 'rgb(196, 205, 204)');\n                grad.addColorStop(0.95, 'rgb(194, 204, 203)');\n                grad.addColorStop(1, 'rgb(189, 201, 199)');\n                radFCtx.fillStyle = grad;\n                radFCtx.fill();\n                break;\n\n            case 'gold':\n                grad = radFCtx.createLinearGradient(0, imageWidth * 0.004672, 0, imageHeight * 0.990654);\n                grad.addColorStop(0, 'rgb(255, 255, 207)');\n                grad.addColorStop(0.15, 'rgb(255, 237, 96)');\n                grad.addColorStop(0.22, 'rgb(254, 199, 57)');\n                grad.addColorStop(0.3, 'rgb(255, 249, 203)');\n                grad.addColorStop(0.38, 'rgb(255, 199, 64)');\n                grad.addColorStop(0.44, 'rgb(252, 194, 60)');\n                grad.addColorStop(0.51, 'rgb(255, 204, 59)');\n                grad.addColorStop(0.6, 'rgb(213, 134, 29)');\n                grad.addColorStop(0.68, 'rgb(255, 201, 56)');\n                grad.addColorStop(0.75, 'rgb(212, 135, 29)');\n                grad.addColorStop(1, 'rgb(247, 238, 101)');\n                radFCtx.fillStyle = grad;\n                radFCtx.fill();\n                break;\n\n            case 'anthracite':\n                grad = radFCtx.createLinearGradient(0, 0.004672 * imageHeight, 0, 0.995326 * imageHeight);\n                grad.addColorStop(0, 'rgb(118, 117, 135)');\n                grad.addColorStop(0.06, 'rgb(74, 74, 82)');\n                grad.addColorStop(0.12, 'rgb(50, 50, 54)');\n                grad.addColorStop(1, 'rgb(79, 79, 87)');\n                radFCtx.fillStyle = grad;\n                radFCtx.fill();\n                break;\n\n            case 'tiltedGray':\n                grad = radFCtx.createLinearGradient(0.233644 * imageWidth, 0.084112 * imageHeight, 0.81258 * imageWidth, 0.910919 * imageHeight);\n                grad.addColorStop(0, '#ffffff');\n                grad.addColorStop(0.07, 'rgb(210, 210, 210)');\n                grad.addColorStop(0.16, 'rgb(179, 179, 179)');\n                grad.addColorStop(0.33, '#ffffff');\n                grad.addColorStop(0.55, '#c5c5c5');\n                grad.addColorStop(0.79, '#ffffff');\n                grad.addColorStop(1, '#666666');\n                radFCtx.fillStyle = grad;\n                radFCtx.fill();\n                break;\n\n            case 'tiltedBlack':\n                grad = radFCtx.createLinearGradient(0.228971 * imageWidth, 0.079439 * imageHeight, 0.802547 * imageWidth, 0.898591 * imageHeight);\n                grad.addColorStop(0, '#666666');\n                grad.addColorStop(0.21, '#000000');\n                grad.addColorStop(0.47, '#666666');\n                grad.addColorStop(0.99, '#000000');\n                grad.addColorStop(1, '#000000');\n                radFCtx.fillStyle = grad;\n                radFCtx.fill();\n                break;\n\n            case 'glossyMetal':\n                grad = radFCtx.createRadialGradient(0.5 * imageWidth, 0.5 * imageHeight, 0, 0.5 * imageWidth, 0.5 * imageWidth, 0.5 * imageWidth);\n                grad.addColorStop(0, 'rgb(207, 207, 207)');\n                grad.addColorStop(0.96, 'rgb(205, 204, 205)');\n                grad.addColorStop(1, 'rgb(244, 244, 244)');\n                radFCtx.fillStyle = grad;\n                radFCtx.fill();\n                radFCtx.beginPath();\n                radFCtx.arc(0.5 * imageWidth, 0.5 * imageHeight, 0.973962 * imageWidth / 2, 0, TWO_PI);\n                radFCtx.closePath();\n                grad = radFCtx.createLinearGradient(0, imageHeight - 0.971962 * imageHeight, 0, 0.971962 * imageHeight);\n                grad.addColorStop(0, 'rgb(249, 249, 249)');\n                grad.addColorStop(0.23, 'rgb(200, 195, 191)');\n                grad.addColorStop(0.36, '#ffffff');\n                grad.addColorStop(0.59, 'rgb(29, 29, 29)');\n                grad.addColorStop(0.76, 'rgb(200, 194, 192)');\n                grad.addColorStop(1, 'rgb(209, 209, 209)');\n                radFCtx.fillStyle = grad;\n                radFCtx.fill();\n\n                radFCtx.beginPath();\n                radFCtx.arc(0.5 * imageWidth, 0.5 * imageHeight, 0.869158 * imageWidth / 2, 0, TWO_PI);\n                radFCtx.closePath();\n                radFCtx.fillStyle = '#f6f6f6';\n                radFCtx.fill();\n\n                radFCtx.beginPath();\n                radFCtx.arc(0.5 * imageWidth, 0.5 * imageHeight, 0.85 * imageWidth / 2, 0, TWO_PI);\n                radFCtx.closePath();\n                radFCtx.fillStyle = '#333333';\n                radFCtx.fill();\n                break;\n\n            case 'blackMetal':\n                fractions = [0,\n                             0.125,\n                             0.347222,\n                             0.5,\n                             0.680555,\n                             0.875,\n                             1];\n\n                colors = [ new RgbaColor(254, 254, 254, 1),\n                           new RgbaColor(0, 0, 0, 1),\n                           new RgbaColor(153, 153, 153, 1),\n                           new RgbaColor(0, 0, 0, 1),\n                           new RgbaColor(153, 153, 153, 1),\n                           new RgbaColor(0, 0, 0, 1),\n                           new RgbaColor(254, 254, 254, 1)];\n\n                radFCtx.save();\n                radFCtx.arc(centerX, centerY, imageWidth * 0.990654 / 2, 0, TWO_PI, true);\n                radFCtx.clip();\n                outerX = imageWidth * 0.495327;\n                innerX = imageWidth * 0.420560;\n                grad = new ConicalGradient(fractions, colors);\n                grad.fillCircle(radFCtx, centerX, centerY, innerX, outerX);\n                // fade outer edge\n                radFCtx.strokeStyle = '#848484';\n                radFCtx.strokeStyle = 'rgba(132, 132, 132, 0.8)';\n                radFCtx.beginPath();\n                radFCtx.lineWidth = imageWidth / 90;\n                radFCtx.arc(centerX, centerY, imageWidth / 2, 0, TWO_PI, true);\n                radFCtx.closePath();\n                radFCtx.stroke();\n                radFCtx.restore();\n                break;\n\n            case 'shinyMetal':\n                fractions = [0,\n                             0.125,\n                             0.25,\n                             0.347222,\n                             0.5,\n                             0.652777,\n                             0.75,\n                             0.875,\n                             1];\n\n                colors = [ new RgbaColor(254, 254, 254, 1),\n                           new RgbaColor(210, 210, 210, 1),\n                           new RgbaColor(179, 179, 179, 1),\n                           new RgbaColor(238, 238, 238, 1),\n                           new RgbaColor(160, 160, 160, 1),\n                           new RgbaColor(238, 238, 238, 1),\n                           new RgbaColor(179, 179, 179, 1),\n                           new RgbaColor(210, 210, 210, 1),\n                           new RgbaColor(254, 254, 254, 1)];\n\n                radFCtx.save();\n                radFCtx.arc(centerX, centerY, imageWidth * 0.990654 / 2, 0, TWO_PI, true);\n                radFCtx.clip();\n                outerX = imageWidth * 0.495327;\n                innerX = imageWidth * 0.420560;\n                grad = new ConicalGradient(fractions, colors);\n                grad.fillCircle(radFCtx, centerX, centerY, innerX, outerX);\n                // fade outer edge\n                radFCtx.strokeStyle = '#848484';\n                radFCtx.strokeStyle = 'rgba(132, 132, 132, 0.8)';\n                radFCtx.beginPath();\n                radFCtx.lineWidth = imageWidth / 90;\n                radFCtx.arc(centerX, centerY, imageWidth / 2, 0, TWO_PI, true);\n                radFCtx.closePath();\n                radFCtx.stroke();\n                radFCtx.restore();\n                break;\n\n            case 'chrome':\n                fractions = [0,\n                             0.09,\n                             0.12,\n                             0.16,\n                             0.25,\n                             0.29,\n                             0.33,\n                             0.38,\n                             0.48,\n                             0.52,\n                             0.63,\n                             0.68,\n                             0.8,\n                             0.83,\n                             0.87,\n                             0.97,\n                             1];\n\n                colors = [ new RgbaColor(255, 255, 255, 1),\n                           new RgbaColor(255, 255, 255, 1),\n                           new RgbaColor(136, 136, 138, 1),\n                           new RgbaColor(164, 185, 190, 1),\n                           new RgbaColor(158, 179, 182, 1),\n                           new RgbaColor(112, 112, 112, 1),\n                           new RgbaColor(221, 227, 227, 1),\n                           new RgbaColor(155, 176, 179, 1),\n                           new RgbaColor(156, 176, 177, 1),\n                           new RgbaColor(254, 255, 255, 1),\n                           new RgbaColor(255, 255, 255, 1),\n                           new RgbaColor(156, 180, 180, 1),\n                           new RgbaColor(198, 209, 211, 1),\n                           new RgbaColor(246, 248, 247, 1),\n                           new RgbaColor(204, 216, 216, 1),\n                           new RgbaColor(164, 188, 190, 1),\n                           new RgbaColor(255, 255, 255, 1)];\n\n                radFCtx.save();\n                radFCtx.arc(centerX, centerY, imageWidth * 0.990654 / 2, 0, TWO_PI, true);\n                radFCtx.clip();\n                outerX = imageWidth * 0.495327;\n                innerX = imageWidth * 0.420560;\n                grad = new ConicalGradient(fractions, colors);\n                grad.fillCircle(radFCtx, centerX, centerY, innerX, outerX);\n                // fade outer edge\n                radFCtx.strokeStyle = '#848484';\n                radFCtx.strokeStyle = 'rgba(132, 132, 132, 0.8)';\n                radFCtx.beginPath();\n                radFCtx.lineWidth = imageWidth / 90;\n                radFCtx.arc(centerX, centerY, imageWidth / 2, 0, TWO_PI, true);\n                radFCtx.closePath();\n                radFCtx.stroke();\n                radFCtx.restore();\n\n                break;\n            }\n\n            // inner bright frame\n            radFCtx.fillStyle = 'rgb(191, 191, 191)';\n            radFCtx.beginPath();\n            radFCtx.arc(centerX, centerY, imageWidth * 0.841121 / 2, 0, TWO_PI, true);\n            radFCtx.closePath();\n            radFCtx.fill();\n\n            // clip out center so it is transparent if the background is not visible\n            radFCtx.globalCompositeOperation = 'destination-out';\n            // Background ellipse\n            radFCtx.beginPath();\n            radFCtx.arc(centerX, centerY, imageWidth * 0.83 / 2, 0, TWO_PI, true);\n            radFCtx.closePath();\n            radFCtx.fill();\n\n            // cache the buffer\n            drawRadialFrameImage.cache[cacheKey] = radFBuffer;\n        }\n        ctx.drawImage(drawRadialFrameImage.cache[cacheKey], 0, 0);\n        return this;\n    };\n    drawRadialFrameImage.cache = {};\n\n    var drawLinearFrameImage = function (ctx, frameDesign, imageWidth, imageHeight, vertical) {\n        var frameWidth,\n            linFBuffer, linFCtx,\n            OUTER_FRAME_CORNER_RADIUS,\n            FRAME_MAIN_CORNER_RADIUS,\n            SUBTRACT_CORNER_RADIUS,\n            grad,\n            fractions = [],\n            colors = [],\n            cacheKey = imageWidth.toString() + imageHeight + frameDesign.design + vertical;\n\n        // check if we have already created and cached this buffer, if not create it\n        if (!drawLinearFrameImage.cache[cacheKey]) {\n            frameWidth = Math.sqrt(imageWidth * imageWidth + imageHeight * imageHeight) * 0.04;\n            frameWidth = Math.min(frameWidth, (vertical ? imageWidth : imageHeight) * 0.1);\n\n            // Setup buffer\n            linFBuffer = createBuffer(imageWidth, imageHeight);\n            linFCtx = linFBuffer.getContext('2d');\n\n            // Calculate corner radii\n            if (vertical) {\n                OUTER_FRAME_CORNER_RADIUS = imageWidth * 0.05;\n                FRAME_MAIN_CORNER_RADIUS = OUTER_FRAME_CORNER_RADIUS - 1;\n                SUBTRACT_CORNER_RADIUS = imageWidth * 0.028571;\n            } else {\n                OUTER_FRAME_CORNER_RADIUS = imageHeight * 0.05;\n                FRAME_MAIN_CORNER_RADIUS = OUTER_FRAME_CORNER_RADIUS - 1;\n                SUBTRACT_CORNER_RADIUS = imageHeight * 0.028571;\n            }\n\n            roundedRectangle(linFCtx, 0, 0, imageWidth, imageHeight, OUTER_FRAME_CORNER_RADIUS);\n            linFCtx.fillStyle = '#838383';\n            linFCtx.fill();\n\n            roundedRectangle(linFCtx, 1, 1, imageWidth - 2, imageHeight - 2, FRAME_MAIN_CORNER_RADIUS);\n\n            // main gradient frame\n            switch (frameDesign.design) {\n            case 'metal':\n                grad = linFCtx.createLinearGradient(0, imageWidth * 0.004672, 0, imageHeight * 0.990654);\n                grad.addColorStop(0, '#fefefe');\n                grad.addColorStop(0.07, 'rgb(210, 210, 210)');\n                grad.addColorStop(0.12, 'rgb(179, 179, 179)');\n                grad.addColorStop(1, 'rgb(213, 213, 213)');\n                linFCtx.fillStyle = grad;\n                linFCtx.fill();\n                break;\n\n            case 'brass':\n                grad = linFCtx.createLinearGradient(0, imageWidth * 0.004672, 0, imageHeight * 0.990654);\n                grad.addColorStop(0, 'rgb(249, 243, 155)');\n                grad.addColorStop(0.05, 'rgb(246, 226, 101)');\n                grad.addColorStop(0.10, 'rgb(240, 225, 132)');\n                grad.addColorStop(0.50, 'rgb(90, 57, 22)');\n                grad.addColorStop(0.90, 'rgb(249, 237, 139)');\n                grad.addColorStop(0.95, 'rgb(243, 226, 108)');\n                grad.addColorStop(1, 'rgb(202, 182, 113)');\n                linFCtx.fillStyle = grad;\n                linFCtx.fill();\n                break;\n\n            case 'steel':\n                grad = linFCtx.createLinearGradient(0, imageWidth * 0.004672, 0, imageHeight * 0.990654);\n                grad.addColorStop(0, 'rgb(231, 237, 237)');\n                grad.addColorStop(0.05, 'rgb(189, 199, 198)');\n                grad.addColorStop(0.10, 'rgb(192, 201, 200)');\n                grad.addColorStop(0.50, 'rgb(23, 31, 33)');\n                grad.addColorStop(0.90, 'rgb(196, 205, 204)');\n                grad.addColorStop(0.95, 'rgb(194, 204, 203)');\n                grad.addColorStop(1, 'rgb(189, 201, 199)');\n                linFCtx.fillStyle = grad;\n                linFCtx.fill();\n                break;\n\n            case 'gold':\n                grad = linFCtx.createLinearGradient(0, imageWidth * 0.004672, 0, imageHeight * 0.990654);\n                grad.addColorStop(0, 'rgb(255, 255, 207)');\n                grad.addColorStop(0.15, 'rgb(255, 237, 96)');\n                grad.addColorStop(0.22, 'rgb(254, 199, 57)');\n                grad.addColorStop(0.3, 'rgb(255, 249, 203)');\n                grad.addColorStop(0.38, 'rgb(255, 199, 64)');\n                grad.addColorStop(0.44, 'rgb(252, 194, 60)');\n                grad.addColorStop(0.51, 'rgb(255, 204, 59)');\n                grad.addColorStop(0.6, 'rgb(213, 134, 29)');\n                grad.addColorStop(0.68, 'rgb(255, 201, 56)');\n                grad.addColorStop(0.75, 'rgb(212, 135, 29)');\n                grad.addColorStop(1, 'rgb(247, 238, 101)');\n                linFCtx.fillStyle = grad;\n                linFCtx.fill();\n                break;\n\n            case 'anthracite':\n                grad = linFCtx.createLinearGradient(0, 0.004672 * imageHeight, 0, 0.995326 * imageHeight);\n                grad.addColorStop(0, 'rgb(118, 117, 135)');\n                grad.addColorStop(0.06, 'rgb(74, 74, 82)');\n                grad.addColorStop(0.12, 'rgb(50, 50, 54)');\n                grad.addColorStop(1, 'rgb(79, 79, 87)');\n                linFCtx.fillStyle = grad;\n                linFCtx.fill();\n                break;\n\n            case 'tiltedGray':\n                grad = linFCtx.createLinearGradient(0.233644 * imageWidth, 0.084112 * imageHeight, 0.81258 * imageWidth, 0.910919 * imageHeight);\n                grad.addColorStop(0, '#ffffff');\n                grad.addColorStop(0.07, 'rgb(210, 210, 210)');\n                grad.addColorStop(0.16, 'rgb(179, 179, 179)');\n                grad.addColorStop(0.33, '#ffffff');\n                grad.addColorStop(0.55, '#c5c5c5');\n                grad.addColorStop(0.79, '#ffffff');\n                grad.addColorStop(1, '#666666');\n                linFCtx.fillStyle = grad;\n                linFCtx.fill();\n                break;\n\n            case 'tiltedBlack':\n                grad = linFCtx.createLinearGradient(0.228971 * imageWidth, 0.079439 * imageHeight, 0.802547 * imageWidth, 0.898591 * imageHeight);\n                grad.addColorStop(0, '#666666');\n                grad.addColorStop(0.21, '#000000');\n                grad.addColorStop(0.47, '#666666');\n                grad.addColorStop(0.99, '#000000');\n                grad.addColorStop(1, '#000000');\n                linFCtx.fillStyle = grad;\n                linFCtx.fill();\n                break;\n\n            case 'glossyMetal':\n                // The smaller side is important for the contour gradient\n    // Java version uses a contour gradient for the outer frame rim\n    // but this is only 1 pixel wide, so a plain color fill is essentially\n    // the same.\n    /*\n                var frameMainFractions4 = [\n                                            0,\n                                            (imageWidth >= imageHeight ? 32 / imageHeight : 32 / imageWidth) * 0.04,\n                                            1\n                                            ];\n                var frameMainColors4 = [\n                                        new RgbaColor(244, 244, 244, 1),\n                                        new RgbaColor(207, 207, 207, 1),\n                                        new RgbaColor(207, 207, 207, 1)\n                                        ];\n                var frameMainGradient4 = new contourGradient(linFCtx, 0, 0, imageWidth,  imageHeight, frameMainFractions4, frameMainColors4);\n                // Outer frame rim\n                roundedRectangle(linFCtx, 1, 1, imageWidth-2, imageHeight-2, OUTER_FRAME_CORNER_RADIUS);\n                linFCtx.clip();\n                frameMainGradient4.paintContext();\n    */\n                // Outer frame rim\n    //                roundedRectangle(linFCtx, 1, 1, imageWidth-2, imageHeight-2, OUTER_FRAME_CORNER_RADIUS);\n    //                linFCtx.clip();\n    //                linFCtx.fillStyle = '#cfcfcf';\n    //                linFCtx.fill();\n\n                // Main frame\n    //                roundedRectangle(linFCtx, 2, 2, imageWidth - 4, imageHeight - 4, FRAME_MAIN_CORNER_RADIUS);\n    //                linFCtx.clip();\n                roundedRectangle(linFCtx, 1, 1, imageWidth - 2, imageHeight - 2, OUTER_FRAME_CORNER_RADIUS);\n                linFCtx.clip();\n                grad = linFCtx.createLinearGradient(0, 1, 0, imageHeight - 2);\n    // The fractions from the Java version of linear gauge\n    /*\n                grad.addColorStop(0, 'rgb(249, 249, 249)');\n                grad.addColorStop(0.1, 'rgb(200, 195, 191)');\n                grad.addColorStop(0.26, '#ffffff');\n                grad.addColorStop(0.73, 'rgb(29, 29, 29)');\n                grad.addColorStop(1, 'rgb(209, 209, 209)');\n    */\n    // Modified fractions from the radial gauge - looks better imho\n                grad.addColorStop(0, 'rgb(249, 249, 249)');\n                grad.addColorStop(0.2, 'rgb(200, 195, 191)');\n                grad.addColorStop(0.3, '#ffffff');\n                grad.addColorStop(0.6, 'rgb(29, 29, 29)');\n                grad.addColorStop(0.8, 'rgb(200, 194, 192)');\n                grad.addColorStop(1, 'rgb(209, 209, 209)');\n                linFCtx.fillStyle = grad;\n                linFCtx.fill();\n\n                // Inner frame bright\n                roundedRectangle(linFCtx, frameWidth - 2, frameWidth - 2, imageWidth - (frameWidth - 2) * 2, imageHeight - (frameWidth - 2) * 2, SUBTRACT_CORNER_RADIUS);\n                linFCtx.clip();\n                linFCtx.fillStyle = '#f6f6f6';\n                linFCtx.fill();\n\n                // Inner frame dark\n                roundedRectangle(linFCtx, frameWidth - 1, frameWidth - 1, imageWidth - (frameWidth - 1) * 2, imageHeight - (frameWidth - 1) * 2, SUBTRACT_CORNER_RADIUS);\n                linFCtx.clip();\n                linFCtx.fillStyle = '#333333';\n                linFCtx.fill();\n                break;\n\n            case 'blackMetal':\n                fractions = [0,\n                             0.125,\n                             0.347222,\n                             0.5,\n                             0.680555,\n                             0.875,\n                             1];\n\n                colors = [ new RgbaColor('#FFFFFF'),\n                           new RgbaColor('#000000'),\n                           new RgbaColor('#999999'),\n                           new RgbaColor('#000000'),\n                           new RgbaColor('#999999'),\n                           new RgbaColor('#000000'),\n                           new RgbaColor('#FFFFFF')];\n                // Set the clip\n                linFCtx.beginPath();\n                roundedRectangle(linFCtx, 1, 1, imageWidth - 2, imageHeight - 2, OUTER_FRAME_CORNER_RADIUS);\n                linFCtx.closePath();\n                linFCtx.clip();\n                grad = new ConicalGradient(fractions, colors);\n                grad.fillRect(linFCtx, imageWidth / 2, imageHeight / 2, imageWidth, imageHeight, frameWidth, frameWidth);\n                break;\n\n            case 'shinyMetal':\n                fractions = [0,\n                             0.125,\n                             0.25,\n                             0.347222,\n                             0.5,\n                             0.652777,\n                             0.75,\n                             0.875,\n                             1];\n\n                colors = [ new RgbaColor('#FFFFFF'),\n                           new RgbaColor('#D2D2D2'),\n                           new RgbaColor('#B3B3B3'),\n                           new RgbaColor('#EEEEEE'),\n                           new RgbaColor('#A0A0A0'),\n                           new RgbaColor('#EEEEEE'),\n                           new RgbaColor('#B3B3B3'),\n                           new RgbaColor('#D2D2D2'),\n                           new RgbaColor('#FFFFFF')];\n                // Set the clip\n                linFCtx.beginPath();\n                roundedRectangle(linFCtx, 1, 1, imageWidth - 2, imageHeight - 2, OUTER_FRAME_CORNER_RADIUS);\n                linFCtx.closePath();\n                linFCtx.clip();\n                grad = new ConicalGradient(fractions, colors);\n                grad.fillRect(linFCtx, imageWidth / 2, imageHeight / 2, imageWidth, imageHeight, frameWidth, frameWidth);\n                break;\n\n            case 'chrome':\n                fractions = [0,\n                             0.09,\n                             0.12,\n                             0.16,\n                             0.25,\n                             0.29,\n                             0.33,\n                             0.38,\n                             0.48,\n                             0.52,\n                             0.63,\n                             0.68,\n                             0.8,\n                             0.83,\n                             0.87,\n                             0.97,\n                             1];\n\n                colors = [ new RgbaColor('#FFFFFF'),\n                           new RgbaColor('#FFFFFF'),\n                           new RgbaColor('#888890'),\n                           new RgbaColor('#A4B9BE'),\n                           new RgbaColor('#9EB3B6'),\n                           new RgbaColor('#707070'),\n                           new RgbaColor('#DDE3E3'),\n                           new RgbaColor('#9BB0B3'),\n                           new RgbaColor('#9CB0B1'),\n                           new RgbaColor('#FEFFFF'),\n                           new RgbaColor('#FFFFFF'),\n                           new RgbaColor('#9CB4B4'),\n                           new RgbaColor('#C6D1D3'),\n                           new RgbaColor('#F6F8F7'),\n                           new RgbaColor('#CCD8D8'),\n                           new RgbaColor('#A4BCBE'),\n                           new RgbaColor('#FFFFFF')];\n                // Set the clip\n                linFCtx.beginPath();\n                roundedRectangle(linFCtx, 1, 1, imageWidth - 2, imageHeight - 2, OUTER_FRAME_CORNER_RADIUS);\n                linFCtx.closePath();\n                linFCtx.clip();\n                grad = new ConicalGradient(fractions, colors);\n                grad.fillRect(linFCtx, imageWidth / 2, imageHeight / 2, imageWidth, imageHeight, frameWidth, frameWidth);\n                break;\n            }\n\n            roundedRectangle(linFCtx, frameWidth - 1, frameWidth - 1, imageWidth - (frameWidth - 1) * 2, imageHeight - (frameWidth - 1) * 2, SUBTRACT_CORNER_RADIUS - 1);\n            linFCtx.fillStyle = 'rgb(192, 192, 192)';\n\n            // clip out the center of the frame for transparent backgrounds\n            linFCtx.globalCompositeOperation = 'destination-out';\n            roundedRectangle(linFCtx, frameWidth, frameWidth, imageWidth - frameWidth * 2, imageHeight - frameWidth * 2, 4);\n            linFCtx.fill();\n\n            // cache the buffer\n            drawLinearFrameImage.cache[cacheKey] = linFBuffer;\n        }\n        ctx.drawImage(drawLinearFrameImage.cache[cacheKey], 0, 0);\n        return this;\n    };\n    drawLinearFrameImage.cache = {};\n\n    var drawRadialBackgroundImage = function (ctx, backgroundColor, centerX, centerY, imageWidth, imageHeight) {\n        var radBBuffer, radBCtx,\n            grad, fractions, colors,\n            backgroundOffsetX = imageWidth * 0.831775 / 2,\n            mono, textureColor, texture,\n            radius, turnRadius, stepSize,\n            end, i,\n            cacheKey = imageWidth.toString() + imageHeight + backgroundColor.name;\n\n        // check if we have already created and cached this buffer, if not create it\n        if (!drawRadialBackgroundImage.cache[cacheKey]) {\n            // Setup buffer\n            radBBuffer = createBuffer(imageWidth, imageHeight);\n            radBCtx = radBBuffer.getContext('2d');\n\n            // Background ellipse\n            radBCtx.beginPath();\n            radBCtx.arc(centerX, centerY, backgroundOffsetX, 0, TWO_PI, true);\n            radBCtx.closePath();\n\n            // If the backgroundColor is a texture fill it with the texture instead of the gradient\n            if (backgroundColor.name === 'CARBON' || backgroundColor.name === 'PUNCHED_SHEET' ||\n                backgroundColor.name === 'BRUSHED_METAL' || backgroundColor.name === 'BRUSHED_STAINLESS') {\n\n                if (backgroundColor.name === 'CARBON') {\n                    radBCtx.fillStyle = radBCtx.createPattern(carbonBuffer, 'repeat');\n                    radBCtx.fill();\n                }\n\n                if (backgroundColor.name === 'PUNCHED_SHEET') {\n                    radBCtx.fillStyle = radBCtx.createPattern(punchedSheetBuffer, 'repeat');\n                    radBCtx.fill();\n                }\n\n                // Add another inner shadow to make the look more realistic\n                grad = radBCtx.createLinearGradient(backgroundOffsetX, 0, imageWidth - backgroundOffsetX, 0);\n                grad.addColorStop(0, 'rgba(0, 0, 0, 0.25)');\n                grad.addColorStop(0.5, 'rgba(0, 0, 0, 0)');\n                grad.addColorStop(1, 'rgba(0, 0, 0, 0.25)');\n                radBCtx.fillStyle = grad;\n                radBCtx.beginPath();\n                radBCtx.arc(centerX, centerY, backgroundOffsetX, 0, TWO_PI, true);\n                radBCtx.closePath();\n                radBCtx.fill();\n\n                if (backgroundColor.name === 'BRUSHED_METAL' || backgroundColor.name === 'BRUSHED_STAINLESS') {\n                    mono = (backgroundColor.name === 'BRUSHED_METAL' ? true : false);\n                    textureColor = parseInt(backgroundColor.gradientStop.getHexColor().substr(-6), 16);\n                    texture = brushedMetalTexture(textureColor, 5, 0.1, mono, 0.5);\n                    radBCtx.fillStyle = radBCtx.createPattern(texture.fill(0, 0, imageWidth, imageHeight), 'no-repeat');\n                    radBCtx.fill();\n                }\n            } else if (backgroundColor.name === 'STAINLESS' || backgroundColor.name === 'TURNED') {\n                // Define the fractions of the conical gradient paint\n                fractions = [0,\n                             0.03,\n                             0.10,\n                             0.14,\n                             0.24,\n                             0.33,\n                             0.38,\n                             0.5,\n                             0.62,\n                             0.67,\n                             0.76,\n                             0.81,\n                             0.85,\n                             0.97,\n                             1];\n\n                // Define the colors of the conical gradient paint\n                colors = [new RgbaColor('#FDFDFD'),\n                          new RgbaColor('#FDFDFD'),\n                          new RgbaColor('#B2B2B4'),\n                          new RgbaColor('#ACACAE'),\n                          new RgbaColor('#FDFDFD'),\n                          new RgbaColor('#8E8E8E'),\n                          new RgbaColor('#8E8E8E'),\n                          new RgbaColor('#FDFDFD'),\n                          new RgbaColor('#8E8E8E'),\n                          new RgbaColor('#8E8E8E'),\n                          new RgbaColor('#FDFDFD'),\n                          new RgbaColor('#ACACAE'),\n                          new RgbaColor('#B2B2B4'),\n                          new RgbaColor('#FDFDFD'),\n                          new RgbaColor('#FDFDFD')];\n\n                grad = new ConicalGradient(fractions, colors);\n                grad.fillCircle(radBCtx, centerX, centerY, 0, backgroundOffsetX);\n\n                if (backgroundColor.name === 'TURNED') {\n                    // Define the turning radius\n                    radius = backgroundOffsetX;\n                    turnRadius = radius * 0.55;\n                    // Step size proporational to radius\n                    stepSize = RAD_FACTOR * (500 / radius);\n                    // Save before we start\n                    radBCtx.save();\n                    // restrict the turnings to the desired area\n                    radBCtx.beginPath();\n                    radBCtx.arc(centerX, centerY, radius, 0, TWO_PI);\n                    radBCtx.closePath();\n                    radBCtx.clip();\n                    // set the style for the turnings\n                    radBCtx.lineWidth = 0.5;\n                    end = TWO_PI - stepSize * 0.3;\n                    // Step the engine round'n'round\n                    for (i = 0 ; i < end; i += stepSize) {\n                        // draw a 'turn'\n                        radBCtx.strokeStyle = 'rgba(240, 240, 255, 0.25)';\n                        radBCtx.beginPath();\n                        radBCtx.arc(centerX + turnRadius, centerY, turnRadius, 0, TWO_PI);\n                        radBCtx.stroke();\n                        // rotate the 'piece' a fraction to draw 'shadow'\n                        radBCtx.translate(centerX, centerY);\n                        radBCtx.rotate(stepSize * 0.3);\n                        radBCtx.translate(-centerX, -centerY);\n                        // draw a 'turn'\n                        radBCtx.strokeStyle = 'rgba(25, 10, 10, 0.1)';\n                        radBCtx.beginPath();\n                        radBCtx.arc(centerX + turnRadius, centerY, turnRadius, 0, TWO_PI);\n                        radBCtx.stroke();\n                        // now rotate on to the next 'scribe' position minus the 'fraction'\n                        radBCtx.translate(centerX, centerY);\n                        radBCtx.rotate(stepSize - stepSize * 0.3);\n                        radBCtx.translate(-centerX, -centerY);\n                    }\n                    // Restore canvas now we are done\n                    radBCtx.restore();\n                }\n            } else {\n                grad = radBCtx.createLinearGradient(0, imageWidth * 0.084112, 0, backgroundOffsetX * 2);\n                grad.addColorStop(0, backgroundColor.gradientStart.getRgbaColor());\n                grad.addColorStop(0.4, backgroundColor.gradientFraction.getRgbaColor());\n                grad.addColorStop(1, backgroundColor.gradientStop.getRgbaColor());\n                radBCtx.fillStyle = grad;\n                radBCtx.fill();\n            }\n            // Inner shadow\n            grad = radBCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, backgroundOffsetX);\n            grad.addColorStop(0, 'rgba(0, 0, 0, 0)');\n            grad.addColorStop(0.7, 'rgba(0, 0, 0, 0)');\n            grad.addColorStop(0.71, 'rgba(0, 0, 0, 0)');\n            grad.addColorStop(0.86, 'rgba(0, 0, 0, 0.03)');\n            grad.addColorStop(0.92, 'rgba(0, 0, 0, 0.07)');\n            grad.addColorStop(0.97, 'rgba(0, 0, 0, 0.15)');\n            grad.addColorStop(1, 'rgba(0, 0, 0, 0.3)');\n            radBCtx.fillStyle = grad;\n\n            radBCtx.beginPath();\n            radBCtx.arc(centerX, centerY, backgroundOffsetX, 0, TWO_PI, true);\n            radBCtx.closePath();\n            radBCtx.fill();\n\n            // cache the buffer\n            drawRadialBackgroundImage.cache[cacheKey] = radBBuffer;\n        }\n        ctx.drawImage(drawRadialBackgroundImage.cache[cacheKey], 0, 0);\n        return this;\n    };\n    drawRadialBackgroundImage.cache = {};\n\n    var drawRadialCustomImage = function (ctx, img, centerX, centerY, imageWidth, imageHeight) {\n        var drawWidth = imageWidth * 0.831775,\n            drawHeight = imageHeight * 0.831775,\n            x = (imageWidth - drawWidth) / 2,\n            y = (imageHeight - drawHeight) / 2;\n\n        if (img !== null && img.height > 0 && img.width > 0) {\n            ctx.save();\n            // Set the clipping area\n            ctx.beginPath();\n            ctx.arc(centerX, centerY, imageWidth * 0.831775 / 2, 0, TWO_PI, true);\n            ctx.clip();\n            // Add the image\n            ctx.drawImage(img, x, y, drawWidth, drawHeight);\n            ctx.restore();\n        }\n        return this;\n    };\n\n    var drawLinearBackgroundImage = function (ctx, backgroundColor, imageWidth, imageHeight, vertical) {\n        var i, end, grad, fractions, colors,\n            frameWidth,\n            linBBuffer, linBCtx, linBColor,\n            radius,\n            turnRadius, centerX, centerY, stepSize,\n            mono, textureColor, texture,\n            cacheKey = imageWidth.toString() + imageHeight + vertical + backgroundColor.name;\n\n        // check if we have already created and cached this buffer, if not create it\n        if (!drawLinearBackgroundImage.cache[cacheKey]) {\n            frameWidth = Math.sqrt(imageWidth * imageWidth + imageHeight * imageHeight) * 0.04;\n            frameWidth = Math.min(frameWidth, (vertical ? imageWidth : imageHeight) * 0.1);\n\n            // Setup buffer\n            linBBuffer = createBuffer(imageWidth, imageHeight);\n            linBCtx = linBBuffer.getContext('2d');\n            linBColor = backgroundColor;\n\n            roundedRectangle(linBCtx, frameWidth, frameWidth, imageWidth - frameWidth * 2, imageHeight - frameWidth * 2, 4);\n\n            // If the backgroundColor is a texture fill it with the texture instead of the gradient\n            if (backgroundColor.name === 'CARBON' || backgroundColor.name === 'PUNCHED_SHEET' ||\n                backgroundColor.name === 'STAINLESS' || backgroundColor.name === 'BRUSHED_METAL' ||\n                backgroundColor.name === 'BRUSHED_STAINLESS' || backgroundColor.name === 'TURNED') {\n                if (backgroundColor.name === 'CARBON') {\n                    linBCtx.fillStyle = linBCtx.createPattern(carbonBuffer, 'repeat');\n                    linBCtx.fill();\n                }\n\n                if (backgroundColor.name === 'PUNCHED_SHEET') {\n                    linBCtx.fillStyle = linBCtx.createPattern(punchedSheetBuffer, 'repeat');\n                    linBCtx.fill();\n                }\n\n                if (backgroundColor.name === 'STAINLESS' || backgroundColor.name === 'TURNED') {\n                    // Define the fraction of the conical gradient paint\n                    fractions = [0,\n                                 0.03,\n                                 0.10,\n                                 0.14,\n                                 0.24,\n                                 0.33,\n                                 0.38,\n                                 0.5,\n                                 0.62,\n                                 0.67,\n                                 0.76,\n                                 0.81,\n                                 0.85,\n                                 0.97,\n                                 1];\n\n                    // Define the colors of the conical gradient paint\n                    colors = [new RgbaColor('#FDFDFD'),\n                              new RgbaColor('#FDFDFD'),\n                              new RgbaColor('#B2B2B4'),\n                              new RgbaColor('#ACACAE'),\n                              new RgbaColor('#FDFDFD'),\n                              new RgbaColor('#8E8E8E'),\n                              new RgbaColor('#8E8E8E'),\n                              new RgbaColor('#FDFDFD'),\n                              new RgbaColor('#8E8E8E'),\n                              new RgbaColor('#8E8E8E'),\n                              new RgbaColor('#FDFDFD'),\n                              new RgbaColor('#ACACAE'),\n                              new RgbaColor('#B2B2B4'),\n                              new RgbaColor('#FDFDFD'),\n                              new RgbaColor('#FDFDFD')];\n                    grad = new ConicalGradient(fractions, colors);\n                    // Set a clip as we will be drawing outside the required area\n                    roundedRectangle(linBCtx, frameWidth, frameWidth, imageWidth - frameWidth * 2, imageHeight - frameWidth * 2, 4);\n                    linBCtx.clip();\n                    grad.fillRect(linBCtx, imageWidth / 2, imageHeight / 2, imageWidth - frameWidth * 2, imageHeight - frameWidth * 2, imageWidth / 2, imageHeight / 2);\n                    // Add an additional inner shadow to fade out brightness at the top\n                    grad = linBCtx.createLinearGradient(0, frameWidth, 0, imageHeight - frameWidth * 2);\n                    grad.addColorStop(0, 'rgba(0, 0, 0, 0.25)');\n                    grad.addColorStop(0.1, 'rgba(0, 0, 0, 0.05)');\n                    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');\n                    linBCtx.fillStyle = grad;\n                    roundedRectangle(linBCtx, frameWidth, frameWidth, imageWidth - frameWidth * 2, imageHeight - frameWidth * 2, 4);\n                    linBCtx.fill();\n                    linBCtx.restore();\n\n                    if (backgroundColor.name === 'TURNED') {\n                        // Define the turning radius\n                        radius = Math.sqrt((imageWidth - frameWidth * 2) * (imageWidth - frameWidth * 2) + (imageHeight - frameWidth * 2) * (imageHeight - frameWidth * 2)) / 2;\n                        turnRadius = radius * 0.55;\n                        centerX = imageWidth / 2;\n                        centerY = imageHeight / 2;\n                        // Step size proporational to radius\n                        stepSize = TWO_PI / 360 * (400 / radius);\n\n                        // Save before we start\n                        linBCtx.save();\n\n                        // Set a clip as we will be drawing outside the required area\n                        linBCtx.beginPath();\n                        roundedRectangle(linBCtx, frameWidth, frameWidth, imageWidth - frameWidth * 2, imageHeight - frameWidth * 2, 4);\n                        linBCtx.clip();\n\n                        // set the style for the turnings\n                        linBCtx.lineWidth = 0.5;\n                        end = TWO_PI - stepSize * 0.3;\n                        // Step the engine round'n'round\n                        for (i = 0; i < end; i += stepSize) {\n                            // draw a 'turn'\n                            linBCtx.strokeStyle = 'rgba(240, 240, 255, 0.25)';\n                            linBCtx.beginPath();\n                            linBCtx.arc(centerX + turnRadius, centerY, turnRadius, 0, TWO_PI);\n                            linBCtx.stroke();\n                            // rotate the 'piece'\n                            linBCtx.translate(centerX, centerY);\n                            linBCtx.rotate(stepSize * 0.3);\n                            linBCtx.translate(-centerX, -centerY);\n                            // draw a 'turn'\n                            linBCtx.strokeStyle = 'rgba(25, 10, 10, 0.1)';\n                            linBCtx.beginPath();\n                            linBCtx.arc(centerX + turnRadius, centerY, turnRadius, 0, TWO_PI);\n                            linBCtx.stroke();\n                            linBCtx.translate(centerX, centerY);\n                            linBCtx.rotate(-stepSize * 0.3);\n                            linBCtx.translate(-centerX, -centerY);\n\n                            // rotate the 'piece'\n                            linBCtx.translate(centerX, centerY);\n                            linBCtx.rotate(stepSize);\n                            linBCtx.translate(-centerX, -centerY);\n                        }\n                        // Restore canvas now we are done\n                        linBCtx.restore();\n                    }\n                }\n                // Add an additional inner shadow to make the look more realistic\n                grad = linBCtx.createLinearGradient(frameWidth, frameWidth, imageWidth - frameWidth * 2, imageHeight - frameWidth * 2);\n                grad.addColorStop(0, 'rgba(0, 0, 0, 0.25)');\n                grad.addColorStop(0.5, 'rgba(0, 0, 0, 0)');\n                grad.addColorStop(1, 'rgba(0, 0, 0, 0.25)');\n                linBCtx.fillStyle = grad;\n                roundedRectangle(linBCtx, frameWidth, frameWidth, imageWidth - frameWidth * 2, imageHeight - frameWidth * 2, 4);\n                linBCtx.fill();\n\n                if (backgroundColor.name === 'BRUSHED_METAL' || backgroundColor.name === 'BRUSHED_STAINLESS') {\n                    mono = (backgroundColor.name === 'BRUSHED_METAL' ? true : false);\n                    textureColor = parseInt(backgroundColor.gradientStop.getHexColor().substr(-6), 16);\n                    texture = brushedMetalTexture(textureColor, 5, 0.1, mono, 0.5);\n                    linBCtx.fillStyle = linBCtx.createPattern(texture.fill(0, 0, imageWidth, imageHeight), 'no-repeat');\n                    linBCtx.fill();\n                }\n            } else {\n                grad = linBCtx.createLinearGradient(0, frameWidth, 0, imageHeight - frameWidth * 2);\n                grad.addColorStop(0, backgroundColor.gradientStart.getRgbaColor());\n                grad.addColorStop(0.4, backgroundColor.gradientFraction.getRgbaColor());\n                grad.addColorStop(1, backgroundColor.gradientStop.getRgbaColor());\n                linBCtx.fillStyle = grad;\n                linBCtx.fill();\n            }\n            // Add a simple inner shadow\n            colors = [ 'rgba(0, 0, 0, 0.3)',\n                       'rgba(0, 0, 0, 0.15)',\n                       'rgba(0, 0, 0, 0.07)',\n                       'rgba(0, 0, 0, 0.03)',\n                       'rgba(0, 0, 0, 0)',\n                       'rgba(0, 0, 0, 0)',\n                       'rgba(0, 0, 0, 0)'\n                     ];\n\n            for (i = 0 ; i < 7 ; i++) {\n                roundedRectangle(linBCtx, frameWidth + i, frameWidth + i, imageWidth - frameWidth * 2 - (2 * i), imageHeight - frameWidth * 2 - (2 * i), 4);\n                linBCtx.strokeStyle = colors[i];\n                linBCtx.stroke();\n            }\n            // cache the buffer\n            drawLinearBackgroundImage.cache[cacheKey] = linBBuffer;\n        }\n        ctx.drawImage(drawLinearBackgroundImage.cache[cacheKey], 0, 0);\n        return this;\n    };\n    drawLinearBackgroundImage.cache = {};\n\n    var drawRadialForegroundImage = function (ctx, foregroundType, imageWidth, imageHeight, withCenterKnob, knob, style, gaugeType, orientation) {\n        var radFgBuffer, radFgCtx,\n            knobSize = Math.ceil(imageHeight * 0.084112),\n            knobX = imageWidth * 0.5 - knobSize / 2,\n            knobY = imageHeight * 0.5 - knobSize / 2,\n            shadowOffset = imageWidth * 0.008,\n            gradHighlight, gradHighlight2,\n            cacheKey = foregroundType.type + imageWidth + imageHeight + withCenterKnob + (knob !== undefined ? knob.type : '-') +\n                       (style !== undefined ? style.style : '-') + (orientation !== undefined ? orientation.type : '-');\n\n        // check if we have already created and cached this buffer, if so return it and exit\n        if (!drawRadialForegroundImage.cache[cacheKey]) {\n            // Setup buffer\n            radFgBuffer = createBuffer(imageWidth, imageHeight);\n            radFgCtx = radFgBuffer.getContext('2d');\n\n            // center post\n            if (withCenterKnob) {\n                // Set the pointer shadow params\n                radFgCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';\n                radFgCtx.shadowOffsetX = radFgCtx.shadowOffsetY = shadowOffset;\n                radFgCtx.shadowBlur = shadowOffset * 2;\n\n                if (gaugeType === steelseries.GaugeType.TYPE5) {\n                    if (steelseries.Orientation.WEST === orientation) {\n                        knobX = imageWidth * 0.733644 - knobSize / 2;\n                        radFgCtx.drawImage(createKnobImage(knobSize, knob, style), knobX, knobY);\n                    } else if (steelseries.Orientation.EAST === orientation) {\n                        knobX = imageWidth * (1 - 0.733644) - knobSize / 2;\n                        radFgCtx.drawImage(createKnobImage(knobSize, knob, style), knobX, knobY);\n                    } else {\n                        knobY = imageHeight * 0.733644 - knobSize / 2;\n                        radFgCtx.drawImage(createKnobImage(knobSize, knob, style), knobX, imageHeight * 0.6857);\n                    }\n                } else {\n                    radFgCtx.drawImage(createKnobImage(knobSize, knob, style), knobX, knobY);\n                }\n                // Undo shadow drawing\n                radFgCtx.shadowOffsetX = radFgCtx.shadowOffsetY = 0;\n                radFgCtx.shadowBlur = 0;\n            }\n\n            // highlight\n            switch (foregroundType.type) {\n            case 'type2':\n                radFgCtx.beginPath();\n                radFgCtx.moveTo(imageWidth * 0.135514, imageHeight * 0.696261);\n                radFgCtx.bezierCurveTo(imageWidth * 0.214953, imageHeight * 0.588785, imageWidth * 0.317757, imageHeight * 0.5, imageWidth * 0.462616, imageHeight * 0.425233);\n                radFgCtx.bezierCurveTo(imageWidth * 0.612149, imageHeight * 0.345794, imageWidth * 0.733644, imageHeight * 0.317757, imageWidth * 0.873831, imageHeight * 0.322429);\n                radFgCtx.bezierCurveTo(imageWidth * 0.766355, imageHeight * 0.112149, imageWidth * 0.528037, imageHeight * 0.023364, imageWidth * 0.313084, imageHeight * 0.130841);\n                radFgCtx.bezierCurveTo(imageWidth * 0.098130, imageHeight * 0.238317, imageWidth * 0.028037, imageHeight * 0.485981, imageWidth * 0.135514, imageHeight * 0.696261);\n                radFgCtx.closePath();\n                gradHighlight = radFgCtx.createLinearGradient(0.313084 * imageWidth, 0.135514 * imageHeight, 0.495528 * imageWidth, 0.493582 * imageHeight);\n                gradHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.275)');\n                gradHighlight.addColorStop(1, 'rgba(255, 255, 255, 0.015)');\n                break;\n\n            case 'type3':\n                radFgCtx.beginPath();\n                radFgCtx.moveTo(imageWidth * 0.084112, imageHeight * 0.509345);\n                radFgCtx.bezierCurveTo(imageWidth * 0.210280, imageHeight * 0.556074, imageWidth * 0.462616, imageHeight * 0.560747, imageWidth * 0.5, imageHeight * 0.560747);\n                radFgCtx.bezierCurveTo(imageWidth * 0.537383, imageHeight * 0.560747, imageWidth * 0.794392, imageHeight * 0.560747, imageWidth * 0.915887, imageHeight * 0.509345);\n                radFgCtx.bezierCurveTo(imageWidth * 0.915887, imageHeight * 0.275700, imageWidth * 0.738317, imageHeight * 0.084112, imageWidth * 0.5, imageHeight * 0.084112);\n                radFgCtx.bezierCurveTo(imageWidth * 0.261682, imageHeight * 0.084112, imageWidth * 0.084112, imageHeight * 0.275700, imageWidth * 0.084112, imageHeight * 0.509345);\n                radFgCtx.closePath();\n                gradHighlight = radFgCtx.createLinearGradient(0, 0.093457 * imageHeight, 0, 0.556073 * imageHeight);\n                gradHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.275)');\n                gradHighlight.addColorStop(1, 'rgba(255, 255, 255, 0.015)');\n                break;\n\n            case 'type4':\n                radFgCtx.beginPath();\n                radFgCtx.moveTo(imageWidth * 0.677570, imageHeight * 0.242990);\n                radFgCtx.bezierCurveTo(imageWidth * 0.771028, imageHeight * 0.308411, imageWidth * 0.822429, imageHeight * 0.411214, imageWidth * 0.813084, imageHeight * 0.528037);\n                radFgCtx.bezierCurveTo(imageWidth * 0.799065, imageHeight * 0.654205, imageWidth * 0.719626, imageHeight * 0.757009, imageWidth * 0.593457, imageHeight * 0.799065);\n                radFgCtx.bezierCurveTo(imageWidth * 0.485981, imageHeight * 0.831775, imageWidth * 0.369158, imageHeight * 0.808411, imageWidth * 0.285046, imageHeight * 0.728971);\n                radFgCtx.bezierCurveTo(imageWidth * 0.275700, imageHeight * 0.719626, imageWidth * 0.252336, imageHeight * 0.714953, imageWidth * 0.233644, imageHeight * 0.728971);\n                radFgCtx.bezierCurveTo(imageWidth * 0.214953, imageHeight * 0.747663, imageWidth * 0.219626, imageHeight * 0.771028, imageWidth * 0.228971, imageHeight * 0.775700);\n                radFgCtx.bezierCurveTo(imageWidth * 0.331775, imageHeight * 0.878504, imageWidth * 0.476635, imageHeight * 0.915887, imageWidth * 0.616822, imageHeight * 0.869158);\n                radFgCtx.bezierCurveTo(imageWidth * 0.771028, imageHeight * 0.822429, imageWidth * 0.873831, imageHeight * 0.691588, imageWidth * 0.887850, imageHeight * 0.532710);\n                radFgCtx.bezierCurveTo(imageWidth * 0.897196, imageHeight * 0.387850, imageWidth * 0.836448, imageHeight * 0.257009, imageWidth * 0.719626, imageHeight * 0.182242);\n                radFgCtx.bezierCurveTo(imageWidth * 0.705607, imageHeight * 0.172897, imageWidth * 0.682242, imageHeight * 0.163551, imageWidth * 0.663551, imageHeight * 0.186915);\n                radFgCtx.bezierCurveTo(imageWidth * 0.654205, imageHeight * 0.205607, imageWidth * 0.668224, imageHeight * 0.238317, imageWidth * 0.677570, imageHeight * 0.242990);\n                radFgCtx.closePath();\n                gradHighlight = radFgCtx.createRadialGradient((0.5) * imageWidth, ((0.5) * imageHeight), 0, ((0.5) * imageWidth), ((0.5) * imageHeight), 0.387850 * imageWidth);\n                gradHighlight.addColorStop(0, 'rgba(255, 255, 255, 0)');\n                gradHighlight.addColorStop(0.82, 'rgba(255, 255, 255, 0)');\n                gradHighlight.addColorStop(0.83, 'rgba(255, 255, 255, 0)');\n                gradHighlight.addColorStop(1, 'rgba(255, 255, 255, 0.15)');\n\n                radFgCtx.beginPath();\n                radFgCtx.moveTo(imageWidth * 0.261682, imageHeight * 0.224299);\n                radFgCtx.bezierCurveTo(imageWidth * 0.285046, imageHeight * 0.238317, imageWidth * 0.252336, imageHeight * 0.285046, imageWidth * 0.242990, imageHeight * 0.317757);\n                radFgCtx.bezierCurveTo(imageWidth * 0.242990, imageHeight * 0.350467, imageWidth * 0.271028, imageHeight * 0.383177, imageWidth * 0.271028, imageHeight * 0.397196);\n                radFgCtx.bezierCurveTo(imageWidth * 0.275700, imageHeight * 0.415887, imageWidth * 0.261682, imageHeight * 0.457943, imageWidth * 0.238317, imageHeight * 0.509345);\n                radFgCtx.bezierCurveTo(imageWidth * 0.224299, imageHeight * 0.542056, imageWidth * 0.177570, imageHeight * 0.612149, imageWidth * 0.158878, imageHeight * 0.612149);\n                radFgCtx.bezierCurveTo(imageWidth * 0.144859, imageHeight * 0.612149, imageWidth * 0.088785, imageHeight * 0.546728, imageWidth * 0.130841, imageHeight * 0.369158);\n                radFgCtx.bezierCurveTo(imageWidth * 0.140186, imageHeight * 0.336448, imageWidth * 0.214953, imageHeight * 0.200934, imageWidth * 0.261682, imageHeight * 0.224299);\n                radFgCtx.closePath();\n                gradHighlight2 = radFgCtx.createLinearGradient(0.130841 * imageWidth, 0.369158 * imageHeight, 0.273839 * imageWidth, 0.412877 * imageHeight);\n                gradHighlight2.addColorStop(0, 'rgba(255, 255, 255, 0.275)');\n                gradHighlight2.addColorStop(1, 'rgba(255, 255, 255, 0.015)');\n                radFgCtx.fillStyle = gradHighlight2;\n                radFgCtx.fill();\n                break;\n\n            case 'type5':\n                radFgCtx.beginPath();\n                radFgCtx.moveTo(imageWidth * 0.084112, imageHeight * 0.5);\n                radFgCtx.bezierCurveTo(imageWidth * 0.084112, imageHeight * 0.271028, imageWidth * 0.271028, imageHeight * 0.084112, imageWidth * 0.5, imageHeight * 0.084112);\n                radFgCtx.bezierCurveTo(imageWidth * 0.700934, imageHeight * 0.084112, imageWidth * 0.864485, imageHeight * 0.224299, imageWidth * 0.906542, imageHeight * 0.411214);\n                radFgCtx.bezierCurveTo(imageWidth * 0.911214, imageHeight * 0.439252, imageWidth * 0.911214, imageHeight * 0.518691, imageWidth * 0.845794, imageHeight * 0.537383);\n                radFgCtx.bezierCurveTo(imageWidth * 0.794392, imageHeight * 0.546728, imageWidth * 0.551401, imageHeight * 0.411214, imageWidth * 0.392523, imageHeight * 0.457943);\n                radFgCtx.bezierCurveTo(imageWidth * 0.168224, imageHeight * 0.509345, imageWidth * 0.135514, imageHeight * 0.775700, imageWidth * 0.093457, imageHeight * 0.593457);\n                radFgCtx.bezierCurveTo(imageWidth * 0.088785, imageHeight * 0.560747, imageWidth * 0.084112, imageHeight * 0.532710, imageWidth * 0.084112, imageHeight * 0.5);\n                radFgCtx.closePath();\n                gradHighlight = radFgCtx.createLinearGradient(0, 0.084112 * imageHeight, 0, 0.644859 * imageHeight);\n                gradHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.275)');\n                gradHighlight.addColorStop(1, 'rgba(255, 255, 255, 0.015)');\n                break;\n\n            case 'type1':\n            /* falls through */\n            default:\n                radFgCtx.beginPath();\n                radFgCtx.moveTo(imageWidth * 0.084112, imageHeight * 0.509345);\n                radFgCtx.bezierCurveTo(imageWidth * 0.205607, imageHeight * 0.448598, imageWidth * 0.336448, imageHeight * 0.415887, imageWidth * 0.5, imageHeight * 0.415887);\n                radFgCtx.bezierCurveTo(imageWidth * 0.672897, imageHeight * 0.415887, imageWidth * 0.789719, imageHeight * 0.443925, imageWidth * 0.915887, imageHeight * 0.509345);\n                radFgCtx.bezierCurveTo(imageWidth * 0.915887, imageHeight * 0.275700, imageWidth * 0.738317, imageHeight * 0.084112, imageWidth * 0.5, imageHeight * 0.084112);\n                radFgCtx.bezierCurveTo(imageWidth * 0.261682, imageHeight * 0.084112, imageWidth * 0.084112, imageHeight * 0.275700, imageWidth * 0.084112, imageHeight * 0.509345);\n                radFgCtx.closePath();\n                gradHighlight = radFgCtx.createLinearGradient(0, 0.088785 * imageHeight, 0, 0.490654 * imageHeight);\n                gradHighlight.addColorStop(0, 'rgba(255, 255, 255, 0.275)');\n                gradHighlight.addColorStop(1, 'rgba(255, 255, 255, 0.015)');\n                break;\n            }\n            radFgCtx.fillStyle = gradHighlight;\n            radFgCtx.fill();\n\n            // cache the buffer\n            drawRadialForegroundImage.cache[cacheKey] = radFgBuffer;\n        }\n        ctx.drawImage(drawRadialForegroundImage.cache[cacheKey], 0, 0);\n        return this;\n    };\n    drawRadialForegroundImage.cache = {};\n\n    var drawLinearForegroundImage = function (ctx, imageWidth, imageHeight, vertical) {\n        var linFgBuffer, linFgCtx,\n            foregroundGradient,\n            frameWidth, fgOffset, fgOffset2,\n            cacheKey = imageWidth.toString() + imageHeight + vertical;\n\n        // check if we have already created and cached this buffer, if not create it\n        if (!drawLinearForegroundImage.cache[cacheKey]) {\n            // Setup buffer\n            linFgBuffer = createBuffer(imageWidth, imageHeight);\n            linFgCtx = linFgBuffer.getContext('2d');\n\n            frameWidth = Math.sqrt(imageWidth * imageWidth + imageHeight * imageHeight) * 0.04;\n            frameWidth = Math.min(frameWidth, (vertical ? imageWidth : imageHeight) * 0.1);\n            fgOffset = frameWidth * 1.3;\n            fgOffset2 = fgOffset * 1.33;\n\n            linFgCtx.beginPath();\n            linFgCtx.moveTo(fgOffset, imageHeight - fgOffset);\n            linFgCtx.lineTo(imageWidth - fgOffset, imageHeight - fgOffset);\n            linFgCtx.bezierCurveTo(imageWidth - fgOffset, imageHeight - fgOffset, imageWidth - fgOffset2, imageHeight * 0.7, imageWidth - fgOffset2, imageHeight * 0.5);\n            linFgCtx.bezierCurveTo(imageWidth - fgOffset2, fgOffset2, imageWidth - fgOffset, fgOffset, imageWidth - frameWidth, fgOffset);\n            linFgCtx.lineTo(fgOffset, fgOffset);\n            linFgCtx.bezierCurveTo(fgOffset, fgOffset, fgOffset2, imageHeight * 0.285714, fgOffset2, imageHeight * 0.5);\n            linFgCtx.bezierCurveTo(fgOffset2, imageHeight * 0.7, fgOffset, imageHeight - fgOffset, frameWidth, imageHeight - fgOffset);\n            linFgCtx.closePath();\n\n            foregroundGradient = linFgCtx.createLinearGradient(0, (imageHeight - frameWidth), 0, frameWidth);\n            foregroundGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');\n            foregroundGradient.addColorStop(0.06, 'rgba(255, 255, 255, 0)');\n            foregroundGradient.addColorStop(0.07, 'rgba(255, 255, 255, 0)');\n            foregroundGradient.addColorStop(0.12, 'rgba(255, 255, 255, 0)');\n            foregroundGradient.addColorStop(0.17, 'rgba(255, 255, 255, 0.013546)');\n            foregroundGradient.addColorStop(0.1701, 'rgba(255, 255, 255, 0)');\n            foregroundGradient.addColorStop(0.79, 'rgba(255, 255, 255, 0)');\n            foregroundGradient.addColorStop(0.8, 'rgba(255, 255, 255, 0)');\n            foregroundGradient.addColorStop(0.84, 'rgba(255, 255, 255, 0.082217)');\n            foregroundGradient.addColorStop(0.93, 'rgba(255, 255, 255, 0.288702)');\n            foregroundGradient.addColorStop(0.94, 'rgba(255, 255, 255, 0.298039)');\n            foregroundGradient.addColorStop(0.96, 'rgba(255, 255, 255, 0.119213)');\n            foregroundGradient.addColorStop(0.97, 'rgba(255, 255, 255, 0)');\n            foregroundGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n            linFgCtx.fillStyle = foregroundGradient;\n            linFgCtx.fill();\n\n            // cache the buffer\n            drawLinearForegroundImage.cache[cacheKey] = linFgBuffer;\n        }\n        ctx.drawImage(drawLinearForegroundImage.cache[cacheKey], 0, 0);\n        return this;\n    };\n    drawLinearForegroundImage.cache = {};\n\n    var createKnobImage = function (size, knob, style) {\n        var knobBuffer, knobCtx,\n            maxPostCenterX = size / 2,\n            maxPostCenterY = size / 2,\n            grad,\n            cacheKey = size.toString() + knob.type + style.style;\n\n        // check if we have already created and cached this buffer, if not create it\n        if (!createKnobImage.cache[cacheKey]) {\n            knobBuffer = createBuffer(size * 1.18889, size * 1.18889);\n            knobCtx = knobBuffer.getContext('2d');\n\n            switch (knob.type) {\n            case 'metalKnob':\n                // METALKNOB_FRAME\n                knobCtx.beginPath();\n                knobCtx.moveTo(0, size * 0.5);\n                knobCtx.bezierCurveTo(0, size * 0.222222, size * 0.222222, 0, size * 0.5, 0);\n                knobCtx.bezierCurveTo(size * 0.777777, 0, size, size * 0.222222, size, size * 0.5);\n                knobCtx.bezierCurveTo(size, size * 0.777777, size * 0.777777, size, size * 0.5, size);\n                knobCtx.bezierCurveTo(size * 0.222222, size, 0, size * 0.777777, 0, size * 0.5);\n                knobCtx.closePath();\n                grad = knobCtx.createLinearGradient(0, 0, 0, size);\n                grad.addColorStop(0, 'rgb(92, 95, 101)');\n                grad.addColorStop(0.47, 'rgb(46, 49, 53)');\n                grad.addColorStop(1, 'rgb(22, 23, 26)');\n                knobCtx.fillStyle = grad;\n                knobCtx.fill();\n\n                // METALKNOB_MAIN\n                knobCtx.beginPath();\n                knobCtx.moveTo(size * 0.055555, size * 0.5);\n                knobCtx.bezierCurveTo(size * 0.055555, size * 0.277777, size * 0.277777, size * 0.055555, size * 0.5, size * 0.055555);\n                knobCtx.bezierCurveTo(size * 0.722222, size * 0.055555, size * 0.944444, size * 0.277777, size * 0.944444, size * 0.5);\n                knobCtx.bezierCurveTo(size * 0.944444, size * 0.722222, size * 0.722222, size * 0.944444, size * 0.5, size * 0.944444);\n                knobCtx.bezierCurveTo(size * 0.277777, size * 0.944444, size * 0.055555, size * 0.722222, size * 0.055555, size * 0.5);\n                knobCtx.closePath();\n                grad = knobCtx.createLinearGradient(0, 0.055555 * size, 0, 0.944443 * size);\n                switch (style.style) {\n                case 'black':\n                    grad.addColorStop(0, 'rgb(43, 42, 47)');\n                    grad.addColorStop(1, 'rgb(26, 27, 32)');\n                    break;\n\n                case 'brass':\n                    grad.addColorStop(0, 'rgb(150, 110, 54)');\n                    grad.addColorStop(1, 'rgb(124, 95, 61)');\n                    break;\n\n                case 'silver':\n                /* falls through */\n                default:\n                    grad.addColorStop(0, 'rgb(204, 204, 204)');\n                    grad.addColorStop(1, 'rgb(87, 92, 98)');\n                    break;\n                }\n                knobCtx.fillStyle = grad;\n                knobCtx.fill();\n\n                // METALKNOB_LOWERHL\n                knobCtx.beginPath();\n                knobCtx.moveTo(size * 0.777777, size * 0.833333);\n                knobCtx.bezierCurveTo(size * 0.722222, size * 0.722222, size * 0.611111, size * 0.666666, size * 0.5, size * 0.666666);\n                knobCtx.bezierCurveTo(size * 0.388888, size * 0.666666, size * 0.277777, size * 0.722222, size * 0.222222, size * 0.833333);\n                knobCtx.bezierCurveTo(size * 0.277777, size * 0.888888, size * 0.388888, size * 0.944444, size * 0.5, size * 0.944444);\n                knobCtx.bezierCurveTo(size * 0.611111, size * 0.944444, size * 0.722222, size * 0.888888, size * 0.777777, size * 0.833333);\n                knobCtx.closePath();\n                grad = knobCtx.createRadialGradient((0.555555) * size, ((0.944444) * size), 0, ((0.555555) * size), ((0.944444) * size), 0.388888 * size);\n                grad.addColorStop(0, 'rgba(255, 255, 255, 0.6)');\n                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');\n                knobCtx.fillStyle = grad;\n                knobCtx.fill();\n\n                // METALKNOB_UPPERHL\n                knobCtx.beginPath();\n                knobCtx.moveTo(size * 0.944444, size * 0.277777);\n                knobCtx.bezierCurveTo(size * 0.833333, size * 0.111111, size * 0.666666, 0, size * 0.5, 0);\n                knobCtx.bezierCurveTo(size * 0.333333, 0, size * 0.166666, size * 0.111111, size * 0.055555, size * 0.277777);\n                knobCtx.bezierCurveTo(size * 0.166666, size * 0.333333, size * 0.333333, size * 0.388888, size * 0.5, size * 0.388888);\n                knobCtx.bezierCurveTo(size * 0.666666, size * 0.388888, size * 0.833333, size * 0.333333, size * 0.944444, size * 0.277777);\n                knobCtx.closePath();\n                grad = knobCtx.createRadialGradient(0.5 * size, 0, 0, ((0.5) * size), 0, 0.583333 * size);\n                grad.addColorStop(0, 'rgba(255, 255, 255, 0.749019)');\n                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');\n                knobCtx.fillStyle = grad;\n                knobCtx.fill();\n\n                // METALKNOB_INNERFRAME\n                knobCtx.beginPath();\n                knobCtx.moveTo(size * 0.277777, size * 0.555555);\n                knobCtx.bezierCurveTo(size * 0.277777, size * 0.388888, size * 0.388888, size * 0.277777, size * 0.5, size * 0.277777);\n                knobCtx.bezierCurveTo(size * 0.611111, size * 0.277777, size * 0.777777, size * 0.388888, size * 0.777777, size * 0.555555);\n                knobCtx.bezierCurveTo(size * 0.777777, size * 0.666666, size * 0.611111, size * 0.777777, size * 0.5, size * 0.777777);\n                knobCtx.bezierCurveTo(size * 0.388888, size * 0.777777, size * 0.277777, size * 0.666666, size * 0.277777, size * 0.555555);\n                knobCtx.closePath();\n                grad = knobCtx.createLinearGradient(0, 0.277777 * size, 0, 0.722221 * size);\n                grad.addColorStop(0, '#000000');\n                grad.addColorStop(1, 'rgb(204, 204, 204)');\n                knobCtx.fillStyle = grad;\n                knobCtx.fill();\n\n                // METALKNOB_INNERBACKGROUND\n                knobCtx.beginPath();\n                knobCtx.moveTo(size * 0.333333, size * 0.555555);\n                knobCtx.bezierCurveTo(size * 0.333333, size * 0.444444, size * 0.388888, size * 0.333333, size * 0.5, size * 0.333333);\n                knobCtx.bezierCurveTo(size * 0.611111, size * 0.333333, size * 0.722222, size * 0.444444, size * 0.722222, size * 0.555555);\n                knobCtx.bezierCurveTo(size * 0.722222, size * 0.611111, size * 0.611111, size * 0.722222, size * 0.5, size * 0.722222);\n                knobCtx.bezierCurveTo(size * 0.388888, size * 0.722222, size * 0.333333, size * 0.611111, size * 0.333333, size * 0.555555);\n                knobCtx.closePath();\n                grad = knobCtx.createLinearGradient(0, 0.333333 * size, 0, 0.666666 * size);\n                grad.addColorStop(0, 'rgb(10, 9, 1)');\n                grad.addColorStop(1, 'rgb(42, 41, 37)');\n                knobCtx.fillStyle = grad;\n                knobCtx.fill();\n                break;\n\n            case 'standardKnob':\n                grad = knobCtx.createLinearGradient(0, 0, 0, size);\n                grad.addColorStop(0, 'rgb(180, 180, 180)');\n                grad.addColorStop(0.46, 'rgb(63, 63, 63)');\n                grad.addColorStop(1, 'rgb(40, 40, 40)');\n                knobCtx.fillStyle = grad;\n                knobCtx.beginPath();\n                knobCtx.arc(maxPostCenterX, maxPostCenterY, size / 2, 0, TWO_PI, true);\n                knobCtx.closePath();\n                knobCtx.fill();\n                grad = knobCtx.createLinearGradient(0, size - size * 0.77, 0, size - size * 0.77 + size * 0.77);\n                switch (style.style) {\n                case 'black':\n                    grad.addColorStop(0, 'rgb(191, 191, 191)');\n                    grad.addColorStop(0.5, 'rgb(45, 44, 49)');\n                    grad.addColorStop(1, 'rgb(125, 126, 128)');\n                    break;\n\n                case 'brass':\n                    grad.addColorStop(0, 'rgb(223, 208, 174)');\n                    grad.addColorStop(0.5, 'rgb(123, 95, 63)');\n                    grad.addColorStop(1, 'rgb(207, 190, 157)');\n                    break;\n\n                case 'silver':\n                /* falls through */\n                default:\n                    grad.addColorStop(0, 'rgb(215, 215, 215)');\n                    grad.addColorStop(0.5, 'rgb(116, 116, 116)');\n                    grad.addColorStop(1, 'rgb(215, 215, 215)');\n                    break;\n                }\n                knobCtx.fillStyle = grad;\n                knobCtx.beginPath();\n                knobCtx.arc(maxPostCenterX, maxPostCenterY, size * 0.77 / 2, 0, TWO_PI, true);\n                knobCtx.closePath();\n                knobCtx.fill();\n\n                grad = knobCtx.createRadialGradient(maxPostCenterX, maxPostCenterY, 0, maxPostCenterX, maxPostCenterY, size * 0.77 / 2);\n                grad.addColorStop(0, 'rgba(0, 0, 0, 0)');\n                grad.addColorStop(0.75, 'rgba(0, 0, 0, 0)');\n                grad.addColorStop(0.76, 'rgba(0, 0, 0, 0.01)');\n                grad.addColorStop(1, 'rgba(0, 0, 0, 0.2)');\n                knobCtx.fillStyle = grad;\n                knobCtx.beginPath();\n                knobCtx.arc(maxPostCenterX, maxPostCenterY, size * 0.77 / 2, 0, TWO_PI, true);\n                knobCtx.closePath();\n                knobCtx.fill();\n                break;\n            }\n\n            // cache the buffer\n            createKnobImage.cache[cacheKey] = knobBuffer;\n        }\n        return createKnobImage.cache[cacheKey];\n    };\n    createKnobImage.cache = {};\n\n    var createLedImage = function (size, state, ledColor) {\n        var ledBuffer, ledCtx,\n            ledCenterX = size / 2,\n            ledCenterY = size / 2,\n            grad,\n            cacheKey = size.toString() + state + ledColor.outerColor_ON;\n\n        // check if we have already created and cached this buffer, if not create it\n        if (!createLedImage.cache[cacheKey]) {\n            ledBuffer = createBuffer(size, size);\n            ledCtx = ledBuffer.getContext('2d');\n\n            switch (state) {\n            case 0: // LED OFF\n                // OFF Gradient\n                grad = ledCtx.createRadialGradient(ledCenterX, ledCenterY, 0, ledCenterX, ledCenterY, size * 0.5 / 2);\n                grad.addColorStop(0, ledColor.innerColor1_OFF);\n                grad.addColorStop(0.2, ledColor.innerColor2_OFF);\n                grad.addColorStop(1, ledColor.outerColor_OFF);\n                ledCtx.fillStyle = grad;\n\n                ledCtx.beginPath();\n                ledCtx.arc(ledCenterX, ledCenterY, size * 0.5 / 2, 0, TWO_PI, true);\n                ledCtx.closePath();\n                ledCtx.fill();\n\n                // InnerShadow\n                grad = ledCtx.createRadialGradient(ledCenterX, ledCenterY, 0, ledCenterX, ledCenterY, size * 0.5 / 2);\n                grad.addColorStop(0, 'rgba(0, 0, 0, 0)');\n                grad.addColorStop(0.8, 'rgba(0, 0, 0, 0)');\n                grad.addColorStop(1, 'rgba(0, 0, 0, 0.4)');\n                ledCtx.fillStyle = grad;\n\n                ledCtx.beginPath();\n                ledCtx.arc(ledCenterX, ledCenterY, size * 0.5 / 2, 0, TWO_PI, true);\n                ledCtx.closePath();\n                ledCtx.fill();\n\n                // LightReflex\n                grad = ledCtx.createLinearGradient(0, 0.35 * size, 0, 0.35 * size + 0.15 * size);\n                grad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');\n                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');\n                ledCtx.fillStyle = grad;\n\n                ledCtx.beginPath();\n                ledCtx.arc(ledCenterX, 0.35 * size + 0.2 * size / 2, size * 0.2, 0, TWO_PI, true);\n                ledCtx.closePath();\n                ledCtx.fill();\n                break;\n\n            case 1: // LED ON\n                // ON Gradient\n                grad = ledCtx.createRadialGradient(ledCenterX, ledCenterY, 0, ledCenterX, ledCenterY, size * 0.5 / 2);\n                grad.addColorStop(0, ledColor.innerColor1_ON);\n                grad.addColorStop(0.2, ledColor.innerColor2_ON);\n                grad.addColorStop(1, ledColor.outerColor_ON);\n                ledCtx.fillStyle = grad;\n\n                ledCtx.beginPath();\n                ledCtx.arc(ledCenterX, ledCenterY, size * 0.5 / 2, 0, TWO_PI, true);\n                ledCtx.closePath();\n                ledCtx.fill();\n\n                // InnerShadow\n                grad = ledCtx.createRadialGradient(ledCenterX, ledCenterY, 0, ledCenterX, ledCenterY, size * 0.5 / 2);\n                grad.addColorStop(0, 'rgba(0, 0, 0, 0)');\n                grad.addColorStop(0.8, 'rgba(0, 0, 0, 0)');\n                grad.addColorStop(1, 'rgba(0, 0, 0, 0.4)');\n                ledCtx.fillStyle = grad;\n\n                ledCtx.beginPath();\n                ledCtx.arc(ledCenterX, ledCenterY, size * 0.5 / 2, 0, TWO_PI, true);\n                ledCtx.closePath();\n                ledCtx.fill();\n\n                // LightReflex\n                grad = ledCtx.createLinearGradient(0, 0.35 * size, 0, 0.35 * size + 0.15 * size);\n                grad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');\n                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');\n                ledCtx.fillStyle = grad;\n\n                ledCtx.beginPath();\n                ledCtx.arc(ledCenterX, 0.35 * size + 0.2 * size / 2, size * 0.2, 0, TWO_PI, true);\n                ledCtx.closePath();\n                ledCtx.fill();\n\n                // Corona\n                grad = ledCtx.createRadialGradient(ledCenterX, ledCenterY, 0, ledCenterX, ledCenterY, size / 2);\n                grad.addColorStop(0, setAlpha(ledColor.coronaColor, 0).color);\n                grad.addColorStop(0.6, setAlpha(ledColor.coronaColor, 0.4).color);\n                grad.addColorStop(0.7, setAlpha(ledColor.coronaColor, 0.25).color);\n                grad.addColorStop(0.8, setAlpha(ledColor.coronaColor, 0.15).color);\n                grad.addColorStop(0.85, setAlpha(ledColor.coronaColor, 0.05).color);\n                grad.addColorStop(1, setAlpha(ledColor.coronaColor, 0).color);\n                ledCtx.fillStyle = grad;\n\n                ledCtx.beginPath();\n                ledCtx.arc(ledCenterX, ledCenterY, size / 2, 0, TWO_PI, true);\n                ledCtx.closePath();\n                ledCtx.fill();\n                break;\n            }\n            // cache the buffer\n            createLedImage.cache[cacheKey] = ledBuffer;\n        }\n        return createLedImage.cache[cacheKey];\n    };\n    createLedImage.cache = {};\n\n    var createLcdBackgroundImage = function (width, height, lcdColor) {\n        var lcdBuffer, lcdCtx,\n            xB = 0,\n            yB = 0,\n            wB = width,\n            hB = height,\n            rB = Math.min(width, height) * 0.095,\n            grad,\n            xF = 1,\n            yF = 1,\n            wF = width - 2,\n            hF = height - 2,\n            rF = rB - 1,\n            cacheKey = width.toString() + height + JSON.stringify(lcdColor);\n\n        // check if we have already created and cached this buffer, if not create it\n        if (!createLcdBackgroundImage.cache[cacheKey]) {\n            lcdBuffer = createBuffer(width, height);\n            lcdCtx = lcdBuffer.getContext('2d');\n            // background\n            grad = lcdCtx.createLinearGradient(0, yB, 0, yB + hB);\n            grad.addColorStop(0, '#4c4c4c');\n            grad.addColorStop(0.08, '#666666');\n            grad.addColorStop(0.92, '#666666');\n            grad.addColorStop(1, '#e6e6e6');\n            lcdCtx.fillStyle = grad;\n            roundedRectangle(lcdCtx, xB, yB, wB, hB, rB);\n            lcdCtx.fill();\n\n            // foreground\n            grad = lcdCtx.createLinearGradient(0, yF, 0, yF + hF);\n            grad.addColorStop(0, lcdColor.gradientStartColor);\n            grad.addColorStop(0.03, lcdColor.gradientFraction1Color);\n            grad.addColorStop(0.49, lcdColor.gradientFraction2Color);\n            grad.addColorStop(0.5, lcdColor.gradientFraction3Color);\n            grad.addColorStop(1, lcdColor.gradientStopColor);\n            lcdCtx.fillStyle = grad;\n            roundedRectangle(lcdCtx, xF, yF, wF, hF, rF);\n            lcdCtx.fill();\n            // cache the buffer\n            createLcdBackgroundImage.cache[cacheKey] = lcdBuffer;\n        }\n        return createLcdBackgroundImage.cache[cacheKey];\n    };\n    createLcdBackgroundImage.cache = {};\n\n    var createMeasuredValueImage = function (size, indicatorColor, radial, vertical) {\n        var indicatorBuffer, indicatorCtx,\n            cacheKey = size.toString() + indicatorColor + radial + vertical;\n\n        // check if we have already created and cached this buffer, if so return it and exit\n        if (!createMeasuredValueImage.cache[cacheKey]) {\n            indicatorBuffer = doc.createElement('canvas');\n            indicatorCtx = indicatorBuffer.getContext('2d');\n            indicatorBuffer.width = size;\n            indicatorBuffer.height = size;\n            indicatorCtx.fillStyle = indicatorColor;\n            if (radial) {\n                indicatorCtx.beginPath();\n                indicatorCtx.moveTo(size * 0.5, size);\n                indicatorCtx.lineTo(0, 0);\n                indicatorCtx.lineTo(size, 0);\n                indicatorCtx.closePath();\n                indicatorCtx.fill();\n            } else {\n                if (vertical) {\n                    indicatorCtx.beginPath();\n                    indicatorCtx.moveTo(size, size * 0.5);\n                    indicatorCtx.lineTo(0, 0);\n                    indicatorCtx.lineTo(0, size);\n                    indicatorCtx.closePath();\n                    indicatorCtx.fill();\n                } else {\n                    indicatorCtx.beginPath();\n                    indicatorCtx.moveTo(size * 0.5, 0);\n                    indicatorCtx.lineTo(size, size);\n                    indicatorCtx.lineTo(0, size);\n                    indicatorCtx.closePath();\n                    indicatorCtx.fill();\n                }\n            }\n            // cache the buffer\n            createMeasuredValueImage.cache[cacheKey] = indicatorBuffer;\n        }\n        return createMeasuredValueImage.cache[cacheKey];\n    };\n    createMeasuredValueImage.cache = {};\n\n    var createTrendIndicator = function (width, onSection, colors) {\n        var height = width * 2,\n            trendBuffer, trendCtx,\n            fill,\n            cacheKey = onSection.state + width + JSON.stringify(colors),\n\n            drawUpArrow = function () {\n                // draw up arrow (red)\n                var ledColor = colors[0];\n\n                if (onSection.state === 'up') {\n                    fill = trendCtx.createRadialGradient(0.5 * width, 0.2 * height, 0, 0.5 * width, 0.2 * height, 0.5 * width);\n                    fill.addColorStop(0, ledColor.innerColor1_ON);\n                    fill.addColorStop(0.2, ledColor.innerColor2_ON);\n                    fill.addColorStop(1, ledColor.outerColor_ON);\n                } else {\n                    fill = trendCtx.createLinearGradient(0, 0, 0, 0.5 * height);\n                    fill.addColorStop(0, '#323232');\n                    fill.addColorStop(1, '#5c5c5c');\n                }\n                trendCtx.fillStyle = fill;\n                trendCtx.beginPath();\n                trendCtx.moveTo(0.5 * width, 0);\n                trendCtx.lineTo(width, 0.2 * height);\n                trendCtx.lineTo(0.752 * width, 0.2 * height);\n                trendCtx.lineTo(0.752 * width, 0.37 * height);\n                trendCtx.lineTo(0.252 * width, 0.37 * height);\n                trendCtx.lineTo(0.252 * width, 0.2 * height);\n                trendCtx.lineTo(0, 0.2 * height);\n                trendCtx.closePath();\n                trendCtx.fill();\n                if (onSection.state !== 'up') {\n                    // Inner shadow\n                    trendCtx.strokeStyle = 'rgba(0, 0, 0, 0.4)';\n                    trendCtx.beginPath();\n                    trendCtx.moveTo(0, 0.2 * height);\n                    trendCtx.lineTo(0.5 * width, 0);\n                    trendCtx.lineTo(width, 0.2 * height);\n                    trendCtx.moveTo(0.252 * width, 0.2 * height);\n                    trendCtx.lineTo(0.252 * width, 0.37 * height);\n                    trendCtx.stroke();\n                    // Inner highlight\n                    trendCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\n                    trendCtx.beginPath();\n                    trendCtx.moveTo(0.252 * width, 0.37 * height);\n                    trendCtx.lineTo(0.752 * width, 0.37 * height);\n                    trendCtx.lineTo(0.752 * width, 0.2 * height);\n                    trendCtx.lineTo(width, 0.2 * height);\n                    trendCtx.stroke();\n                } else {\n                    // draw halo\n                    fill = trendCtx.createRadialGradient(0.5 * width, 0.2 * height, 0, 0.5 * width, 0.2 * height, 0.7 * width);\n                    fill.addColorStop(0, setAlpha(ledColor.coronaColor, 0).color);\n                    fill.addColorStop(0.5, setAlpha(ledColor.coronaColor, 0.3).color);\n                    fill.addColorStop(0.7, setAlpha(ledColor.coronaColor, 0.2).color);\n                    fill.addColorStop(0.8, setAlpha(ledColor.coronaColor, 0.1).color);\n                    fill.addColorStop(0.85, setAlpha(ledColor.coronaColor, 0.05).color);\n                    fill.addColorStop(1, setAlpha(ledColor.coronaColor, 0).color);\n                    trendCtx.fillStyle = fill;\n\n                    trendCtx.beginPath();\n                    trendCtx.arc(0.5 * width, 0.2 * height, 0.7 * width, 0, TWO_PI, true);\n                    trendCtx.closePath();\n                    trendCtx.fill();\n                }\n            },\n\n            drawEquals = function () {\n                // draw equal symbol\n                var ledColor = colors[1];\n\n                trendCtx.beginPath();\n                if (onSection.state === 'steady') {\n                    fill = ledColor.outerColor_ON;\n                    trendCtx.fillStyle = fill;\n                    trendCtx.rect(0.128 * width, 0.41 * height, 0.744 * width, 0.074 * height);\n                    trendCtx.rect(0.128 * width, 0.516 * height, 0.744 * width, 0.074 * height);\n                    trendCtx.closePath();\n                    trendCtx.fill();\n                } else {\n                    fill = trendCtx.createLinearGradient(0, 0.41 * height, 0, 0.41 * height + 0.074 * height);\n                    fill.addColorStop(0, '#323232');\n                    fill.addColorStop(1, '#5c5c5c');\n                    trendCtx.fillStyle = fill;\n                    trendCtx.rect(0.128 * width, 0.41 * height, 0.744 * width, 0.074 * height);\n                    trendCtx.closePath();\n                    trendCtx.fill();\n                    fill = trendCtx.createLinearGradient(0, 0.516 * height, 0, 0.516 * height + 0.074 * height);\n                    fill.addColorStop(0, '#323232');\n                    fill.addColorStop(1, '#5c5c5c');\n                    trendCtx.fillStyle = fill;\n                    trendCtx.rect(0.128 * width, 0.516 * height, 0.744 * width, 0.074 * height);\n                    trendCtx.closePath();\n                    trendCtx.fill();\n                }\n                if (onSection.state !== 'steady') {\n                    // inner shadow\n                    trendCtx.strokeStyle = 'rgba(0, 0, 0, 0.4)';\n                    trendCtx.beginPath();\n                    trendCtx.moveTo(0.128 * width, 0.41 * height + 0.074 * height);\n                    trendCtx.lineTo(0.128 * width, 0.41 * height);\n                    trendCtx.lineTo(0.128 * width + 0.744 * width, 0.41 * height);\n                    trendCtx.stroke();\n                    trendCtx.beginPath();\n                    trendCtx.moveTo(0.128 * width, 0.516 * height + 0.074 * height);\n                    trendCtx.lineTo(0.128 * width, 0.516 * height);\n                    trendCtx.lineTo(0.128 * width + 0.744 * width, 0.516 * height);\n                    trendCtx.stroke();\n                    // inner highlight\n                    trendCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\n                    trendCtx.beginPath();\n                    trendCtx.moveTo(0.128 * width + 0.744 * width, 0.41 * height);\n                    trendCtx.lineTo(0.128 * width + 0.744 * width, 0.41 * height + 0.074 * height);\n                    trendCtx.lineTo(0.128 * width, 0.41 * height + 0.074 * height);\n                    trendCtx.stroke();\n                    trendCtx.beginPath();\n                    trendCtx.moveTo(0.128 * width + 0.744 * width, 0.516 * height);\n                    trendCtx.lineTo(0.128 * width + 0.744 * width, 0.516 * height + 0.074 * height);\n                    trendCtx.lineTo(0.128 * width, 0.516 * height + 0.074 * height);\n                    trendCtx.stroke();\n                } else {\n                    // draw halo\n                    fill = trendCtx.createRadialGradient(0.5 * width, 0.5 * height, 0, 0.5 * width, 0.5 * height, 0.7 * width);\n                    fill.addColorStop(0, setAlpha(ledColor.coronaColor, 0).color);\n                    fill.addColorStop(0.5, setAlpha(ledColor.coronaColor, 0.3).color);\n                    fill.addColorStop(0.7, setAlpha(ledColor.coronaColor, 0.2).color);\n                    fill.addColorStop(0.8, setAlpha(ledColor.coronaColor, 0.1).color);\n                    fill.addColorStop(0.85, setAlpha(ledColor.coronaColor, 0.05).color);\n                    fill.addColorStop(1, setAlpha(ledColor.coronaColor, 0).color);\n                    trendCtx.fillStyle = fill;\n                    trendCtx.beginPath();\n                    trendCtx.arc(0.5 * width, 0.5 * height, 0.7 * width, 0, TWO_PI, true);\n                    trendCtx.closePath();\n                    trendCtx.fill();\n                }\n            },\n\n            drawDownArrow = function () {\n                // draw down arrow\n                var ledColor = colors[2];\n                if (onSection.state === 'down') {\n                    fill = trendCtx.createRadialGradient(0.5 * width, 0.8 * height, 0, 0.5 * width, 0.8 * height, 0.5 * width);\n                    fill.addColorStop(0, ledColor.innerColor1_ON);\n                    fill.addColorStop(0.2, ledColor.innerColor2_ON);\n                    fill.addColorStop(1, ledColor.outerColor_ON);\n                } else {\n                    fill = trendCtx.createLinearGradient(0, 0.63 * height, 0, height);\n                    fill.addColorStop(0, '#323232');\n                    fill.addColorStop(1, '#5c5c5c');\n                }\n                trendCtx.beginPath();\n                trendCtx.fillStyle = fill;\n                trendCtx.moveTo(0.5 * width, height);\n                trendCtx.lineTo(width, 0.8 * height);\n                trendCtx.lineTo(0.725 * width, 0.8 * height);\n                trendCtx.lineTo(0.725 * width, 0.63 * height);\n                trendCtx.lineTo(0.252 * width, 0.63 * height);\n                trendCtx.lineTo(0.252 * width, 0.8 * height);\n                trendCtx.lineTo(0, 0.8 * height);\n                trendCtx.closePath();\n                trendCtx.fill();\n                if (onSection.state !== 'down') {\n                    // Inner shadow\n                    trendCtx.strokeStyle = 'rgba(0, 0, 0, 0.4)';\n                    trendCtx.beginPath();\n                    trendCtx.moveTo(0, 0.8 * height);\n                    trendCtx.lineTo(0.252 * width, 0.8 * height);\n                    trendCtx.moveTo(0.252 * width, 0.63 * height);\n                    trendCtx.lineTo(0.752 * width, 0.63 * height);\n                    trendCtx.stroke();\n                    trendCtx.beginPath();\n                    trendCtx.moveTo(0.752 * width, 0.8 * height);\n                    trendCtx.lineTo(width, 0.8 * height);\n                    trendCtx.stroke();\n                    // Inner highlight\n                    trendCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\n                    trendCtx.beginPath();\n                    trendCtx.moveTo(0, 0.8 * height);\n                    trendCtx.lineTo(0.5 * width, height);\n                    trendCtx.lineTo(width, 0.8 * height);\n                    trendCtx.stroke();\n                    trendCtx.beginPath();\n                    trendCtx.moveTo(0.752 * width, 0.8 * height);\n                    trendCtx.lineTo(0.752 * width, 0.63 * height);\n                    trendCtx.stroke();\n                } else {\n                    // draw halo\n                    fill = trendCtx.createRadialGradient(0.5 * width, 0.8 * height, 0, 0.5 * width, 0.8 * height, 0.7 * width);\n                    fill.addColorStop(0, setAlpha(ledColor.coronaColor, 0).color);\n                    fill.addColorStop(0.5, setAlpha(ledColor.coronaColor, 0.3).color);\n                    fill.addColorStop(0.7, setAlpha(ledColor.coronaColor, 0.2).color);\n                    fill.addColorStop(0.8, setAlpha(ledColor.coronaColor, 0.1).color);\n                    fill.addColorStop(0.85, setAlpha(ledColor.coronaColor, 0.05).color);\n                    fill.addColorStop(1, setAlpha(ledColor.coronaColor, 0).color);\n                    trendCtx.fillStyle = fill;\n                    trendCtx.beginPath();\n                    trendCtx.arc(0.5 * width, 0.8 * height, 0.7 * width, 0, TWO_PI, true);\n                    trendCtx.closePath();\n                    trendCtx.fill();\n                }\n            };\n\n        // Check if we have already cached this indicator, if not create it\n        if (!createTrendIndicator.cache[cacheKey]) {\n            // create oversized buffer for the glow\n            trendBuffer = createBuffer(width * 2, width * 4);\n            trendCtx = trendBuffer.getContext('2d');\n            trendCtx.translate(width * 0.5, width * 0.5);\n            // Must draw the active section last so the 'glow' is on top\n            switch (onSection.state) {\n            case 'up':\n                drawDownArrow();\n                drawEquals();\n                drawUpArrow();\n                break;\n            case 'steady':\n                drawDownArrow();\n                drawUpArrow();\n                drawEquals();\n                break;\n            case 'down':\n            /* falls through */\n            default:\n                drawUpArrow();\n                drawEquals();\n                drawDownArrow();\n                break;\n            }\n            // cache the buffer\n            createTrendIndicator.cache[cacheKey] = trendBuffer;\n        }\n        return createTrendIndicator.cache[cacheKey];\n    };\n    createTrendIndicator.cache = {};\n\n    var drawTitleImage = function (ctx, imageWidth, imageHeight, titleString, unitString, backgroundColor, vertical, radial, altPos, gaugeType) {\n        gaugeType = (undefined === gaugeType ? gaugeType = steelseries.GaugeType.TYPE1 : gaugeType);\n        ctx.save();\n        ctx.textAlign = (radial ? 'center' : 'left');\n        ctx.textBaseline = 'middle';\n        ctx.strokeStyle = backgroundColor.labelColor.getRgbaColor();\n        ctx.fillStyle = backgroundColor.labelColor.getRgbaColor();\n\n        if (radial) {\n            ctx.font = 0.046728 * imageWidth + 'px ' + stdFontName;\n            ctx.fillText(titleString, imageWidth / 2, imageHeight * 0.3, imageWidth * 0.3);\n            ctx.fillText(unitString, imageWidth / 2, imageHeight * 0.38, imageWidth * 0.3);\n        } else {\n            // linear\n            if (vertical) {\n                ctx.font = 0.1 * imageWidth + 'px ' + stdFontName;\n                ctx.save();\n                ctx.translate(0.671428 * imageWidth, 0.1375 * imageHeight);\n                ctx.rotate(1.570796);\n                ctx.fillText(titleString, 0, 0);\n                ctx.translate(-0.671428 * imageWidth, -0.1375 * imageHeight);\n                ctx.restore();\n                ctx.font = 0.071428 * imageWidth + 'px ' + stdFontName;\n                if (altPos) {\n                    // LCD visible\n                    if (gaugeType.type === 'type2') {\n                        ctx.textAlign = 'right';\n                        ctx.fillText(unitString, 0.36 * imageWidth, imageHeight * 0.79, imageWidth * 0.25);\n                    } else {\n                        ctx.fillText(unitString, 0.63 * imageWidth, imageHeight * 0.85, imageWidth * 0.2);\n                    }\n                } else {\n                    // LCD hidden\n                    ctx.textAlign = 'center';\n                    if (gaugeType.type === 'type2') {\n                        ctx.fillText(unitString, imageWidth / 2, imageHeight * 0.92, imageWidth * 0.2);\n                    } else {\n                        ctx.fillText(unitString, imageWidth / 2, imageHeight * 0.89, imageWidth * 0.2);\n                    }\n                }\n            } else { //linear horizontal\n                ctx.font = 0.035 * imageWidth + 'px ' + stdFontName;\n                ctx.fillText(titleString, imageWidth * 0.15, imageHeight * 0.25, imageWidth * 0.3);\n                ctx.font = 0.025 * imageWidth + 'px ' + stdFontName;\n                ctx.fillText(unitString, imageWidth * 0.0625, imageHeight * 0.7, imageWidth * 0.07);\n            }\n        }\n        ctx.restore();\n    };\n\n    //*****************************************   T E X T U R E S   ****************************************************\n    var carbonBuffer = drawToBuffer(12, 12, function (ctx) {\n            var imageWidth = ctx.canvas.width,\n                imageHeight = ctx.canvas.height,\n                offsetX = 0,\n                offsetY = 0,\n                grad;\n\n            ctx.save();\n\n            // RULB\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(0, 0, imageWidth * 0.5, imageHeight * 0.5);\n            ctx.closePath();\n            ctx.restore();\n\n            grad = ctx.createLinearGradient(0, offsetY * imageHeight, 0, 0.5 * imageHeight + offsetY * imageHeight);\n            grad.addColorStop(0, 'rgb(35, 35, 35)');\n            grad.addColorStop(1, 'rgb(23, 23, 23)');\n            ctx.fillStyle = grad;\n            ctx.fill();\n\n            // RULF\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(imageWidth * 0.083333, 0, imageWidth * 0.333333, imageHeight * 0.416666);\n            ctx.closePath();\n            ctx.restore();\n            offsetX = 0.083333;\n            offsetY = 0;\n            grad = ctx.createLinearGradient(0, offsetY * imageHeight, 0, 0.416666 * imageHeight + offsetY * imageHeight);\n            grad.addColorStop(0, 'rgb(38, 38, 38)');\n            grad.addColorStop(1, 'rgb(30, 30, 30)');\n            ctx.fillStyle = grad;\n            ctx.fill();\n\n            // RLRB\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(imageWidth * 0.5, imageHeight * 0.5, imageWidth * 0.5, imageHeight * 0.5);\n            ctx.closePath();\n            ctx.restore();\n            offsetX = 0.5;\n            offsetY = 0.5;\n            grad = ctx.createLinearGradient(0, offsetY * imageHeight, 0, 0.5 * imageHeight + offsetY * imageHeight);\n            grad.addColorStop(0, 'rgb(35, 35, 35)');\n            grad.addColorStop(1, 'rgb(23, 23, 23)');\n            ctx.fillStyle = grad;\n            ctx.fill();\n\n            // RLRF\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(imageWidth * 0.583333, imageHeight * 0.5, imageWidth * 0.333333, imageHeight * 0.416666);\n            ctx.closePath();\n            ctx.restore();\n            offsetX = 0.583333;\n            offsetY = 0.5;\n            grad = ctx.createLinearGradient(0, offsetY * imageHeight, 0, 0.416666 * imageHeight + offsetY * imageHeight);\n            grad.addColorStop(0, 'rgb(38, 38, 38)');\n            grad.addColorStop(1, 'rgb(30, 30, 30)');\n            ctx.fillStyle = grad;\n            ctx.fill();\n\n            // RURB\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(imageWidth * 0.5, 0, imageWidth * 0.5, imageHeight * 0.5);\n            ctx.closePath();\n            ctx.restore();\n            offsetX = 0.5;\n            offsetY = 0;\n            grad = ctx.createLinearGradient(0, offsetY * imageHeight, 0, 0.5 * imageHeight + offsetY * imageHeight);\n            grad.addColorStop(0, '#303030');\n            grad.addColorStop(1, 'rgb(40, 40, 40)');\n            ctx.fillStyle = grad;\n            ctx.fill();\n\n            // RURF\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(imageWidth * 0.583333, imageHeight * 0.083333, imageWidth * 0.333333, imageHeight * 0.416666);\n            ctx.closePath();\n            ctx.restore();\n            offsetX = 0.583333;\n            offsetY = 0.083333;\n            grad = ctx.createLinearGradient(0, offsetY * imageHeight, 0, 0.416666 * imageHeight + offsetY * imageHeight);\n            grad.addColorStop(0, 'rgb(53, 53, 53)');\n            grad.addColorStop(1, 'rgb(45, 45, 45)');\n            ctx.fillStyle = grad;\n            ctx.fill();\n\n            // RLLB\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(0, imageHeight * 0.5, imageWidth * 0.5, imageHeight * 0.5);\n            ctx.closePath();\n            ctx.restore();\n            offsetX = 0;\n            offsetY = 0.5;\n            grad = ctx.createLinearGradient(0, offsetY * imageHeight, 0, 0.5 * imageHeight + offsetY * imageHeight);\n            grad.addColorStop(0, '#303030');\n            grad.addColorStop(1, '#282828');\n            ctx.fillStyle = grad;\n            ctx.fill();\n\n            // RLLF\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(imageWidth * 0.083333, imageHeight * 0.583333, imageWidth * 0.333333, imageHeight * 0.416666);\n            ctx.closePath();\n            ctx.restore();\n            offsetX = 0.083333;\n            offsetY = 0.583333;\n            grad = ctx.createLinearGradient(0, offsetY * imageHeight, 0, 0.416666 * imageHeight + offsetY * imageHeight);\n            grad.addColorStop(0, '#353535');\n            grad.addColorStop(1, '#2d2d2d');\n            ctx.fillStyle = grad;\n            ctx.fill();\n\n            ctx.restore();\n        });\n\n    var punchedSheetBuffer = drawToBuffer(15, 15, function (ctx) {\n        var imageWidth = ctx.canvas.width,\n            imageHeight = ctx.canvas.height,\n            grad;\n\n        ctx.save();\n\n        // BACK\n        ctx.save();\n        ctx.beginPath();\n        ctx.rect(0, 0, imageWidth, imageHeight);\n        ctx.closePath();\n        ctx.restore();\n        ctx.fillStyle = '#1D2123';\n        ctx.fill();\n\n        // ULB\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(0, imageHeight * 0.266666);\n        ctx.bezierCurveTo(0, imageHeight * 0.4, imageWidth * 0.066666, imageHeight * 0.466666, imageWidth * 0.2, imageHeight * 0.466666);\n        ctx.bezierCurveTo(imageWidth * 0.333333, imageHeight * 0.466666, imageWidth * 0.4, imageHeight * 0.4, imageWidth * 0.4, imageHeight * 0.266666);\n        ctx.bezierCurveTo(imageWidth * 0.4, imageHeight * 0.133333, imageWidth * 0.333333, imageHeight * 0.066666, imageWidth * 0.2, imageHeight * 0.066666);\n        ctx.bezierCurveTo(imageWidth * 0.066666, imageHeight * 0.066666, 0, imageHeight * 0.133333, 0, imageHeight * 0.266666);\n        ctx.closePath();\n        grad = ctx.createLinearGradient(0, 0.066666 * imageHeight, 0, 0.466666 * imageHeight);\n        grad.addColorStop(0, '#000000');\n        grad.addColorStop(1, '#444444');\n        ctx.fillStyle = grad;\n        ctx.fill();\n\n        // ULF\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(0, imageHeight * 0.2);\n        ctx.bezierCurveTo(0, imageHeight * 0.333333, imageWidth * 0.066666, imageHeight * 0.4, imageWidth * 0.2, imageHeight * 0.4);\n        ctx.bezierCurveTo(imageWidth * 0.333333, imageHeight * 0.4, imageWidth * 0.4, imageHeight * 0.333333, imageWidth * 0.4, imageHeight * 0.2);\n        ctx.bezierCurveTo(imageWidth * 0.4, imageHeight * 0.066666, imageWidth * 0.333333, 0, imageWidth * 0.2, 0);\n        ctx.bezierCurveTo(imageWidth * 0.066666, 0, 0, imageHeight * 0.066666, 0, imageHeight * 0.2);\n        ctx.closePath();\n        ctx.fillStyle = '#050506';\n        ctx.fill();\n\n        // LRB\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(imageWidth * 0.466666, imageHeight * 0.733333);\n        ctx.bezierCurveTo(imageWidth * 0.466666, imageHeight * 0.866666, imageWidth * 0.533333, imageHeight * 0.933333, imageWidth * 0.666666, imageHeight * 0.933333);\n        ctx.bezierCurveTo(imageWidth * 0.8, imageHeight * 0.933333, imageWidth * 0.866666, imageHeight * 0.866666, imageWidth * 0.866666, imageHeight * 0.733333);\n        ctx.bezierCurveTo(imageWidth * 0.866666, imageHeight * 0.6, imageWidth * 0.8, imageHeight * 0.533333, imageWidth * 0.666666, imageHeight * 0.533333);\n        ctx.bezierCurveTo(imageWidth * 0.533333, imageHeight * 0.533333, imageWidth * 0.466666, imageHeight * 0.6, imageWidth * 0.466666, imageHeight * 0.733333);\n        ctx.closePath();\n        grad = ctx.createLinearGradient(0, 0.533333 * imageHeight, 0, 0.933333 * imageHeight);\n        grad.addColorStop(0, '#000000');\n        grad.addColorStop(1, '#444444');\n        ctx.fillStyle = grad;\n        ctx.fill();\n\n        // LRF\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(imageWidth * 0.466666, imageHeight * 0.666666);\n        ctx.bezierCurveTo(imageWidth * 0.466666, imageHeight * 0.8, imageWidth * 0.533333, imageHeight * 0.866666, imageWidth * 0.666666, imageHeight * 0.866666);\n        ctx.bezierCurveTo(imageWidth * 0.8, imageHeight * 0.866666, imageWidth * 0.866666, imageHeight * 0.8, imageWidth * 0.866666, imageHeight * 0.666666);\n        ctx.bezierCurveTo(imageWidth * 0.866666, imageHeight * 0.533333, imageWidth * 0.8, imageHeight * 0.466666, imageWidth * 0.666666, imageHeight * 0.466666);\n        ctx.bezierCurveTo(imageWidth * 0.533333, imageHeight * 0.466666, imageWidth * 0.466666, imageHeight * 0.533333, imageWidth * 0.466666, imageHeight * 0.666666);\n        ctx.closePath();\n        ctx.fillStyle = '#050506';\n        ctx.fill();\n\n        ctx.restore();\n    });\n\n    var brushedMetalTexture = function (color, radius, amount, monochrome, shine) {\n\n        this.fill = function (startX, startY, endX, endY) {\n            var i, x, y,                        // loop counters\n                sinArr,\n                width, height,\n                outCanvas, outCanvasContext,    // output canvas\n                inPixels, outPixels,            // pixel arrays\n                //alpha = color & 0xff000000;\n                alpha = 255,\n                red = (color >> 16) & 0xff,\n                green = (color >> 8) & 0xff,\n                blue = color & 0xff,\n                n = 0,\n                variation = 255 * amount,\n                totR, totG, totB,\n                indx, tr, tg, tb, f;\n\n            startX = Math.floor(startX);\n            startY = Math.floor(startY);\n            endX = Math.ceil(endX);\n            endY = Math.ceil(endY);\n\n            width = endX - startX;\n            height = endY - startY;\n\n            // Create output canvas\n            outCanvas = createBuffer(width, height);\n            outCanvasContext = outCanvas.getContext('2d');\n\n            // Create pixel arrays\n            inPixels = outCanvasContext.createImageData(width, height);\n            outPixels = outCanvasContext.createImageData(width, height);\n\n            // Precreate sin() values\n            if (shine !== 0) {\n                sinArr = [];\n                for (i = 0; i < width; i++) {\n                    sinArr[i] = (255 * shine * Math.sin(i / width * PI)) | 0;\n                }\n            }\n\n            for (y = 0; y < height; y++) {\n                // The pixel array is addressed as 4 elements per pixel [r,g,b,a]\n                if (radius !== 0) {\n                    totR = totG = totB = 0;\n                }\n                for (x = 0; x < width; x ++) {\n                    indx = (y * width * 4) + (x * 4);\n                    tr = red;\n                    tg = green;\n                    tb = blue;\n                    if (shine !== 0) {\n                        f = sinArr[x];\n                        tr += f;\n                        tg += f;\n                        tb += f;\n                    }\n\n                    if (monochrome) {\n                        n = ((2 * Math.random() - 1) * variation) | 0;\n                        inPixels.data[indx]   = clamp(tr + n);\n                        inPixels.data[indx + 1] = clamp(tg + n);\n                        inPixels.data[indx + 2] = clamp(tb + n);\n                        inPixels.data[indx + 3] = alpha;\n                    } else {\n                        inPixels.data[indx]   = random(tr, variation);\n                        inPixels.data[indx + 1] = random(tg, variation);\n                        inPixels.data[indx + 2] = random(tb, variation);\n                        inPixels.data[indx + 3] = alpha;\n                    }\n                }\n            }\n\n            if (radius > 0) {\n                horizontalBlur(inPixels, outPixels, width, height, radius, alpha);\n                outCanvasContext.putImageData(outPixels, startX, startY);\n            } else {\n                outCanvasContext.putImageData(inPixels, startX, startY);\n            }\n            return outCanvas;\n        };\n\n        function random(x, vari) {\n            x += ((2 * Math.random() - 1) * vari) | 0;\n            return (x < 0 ? 0 : (x > 255 ? 255 : x));\n        }\n\n        function clamp(C) {\n            return (C < 0 ? 0 : (C > 255 ? 255 : C));\n        }\n\n        function horizontalBlur(inPix, outPix, width, height, radius, alpha) {\n            var x, y,       // loop counters\n                i, mul, indx,\n                totR, totG, totB;\n\n            if (radius >= width) {\n                radius = width - 1;\n            }\n            mul = 1 / (radius * 2 + 1);\n            indx = 0;\n            for (y = 0; y < height; y++) {\n                totR = totG = totB = 0;\n                for (x = 0; x < radius ; x++) {\n                    i = (indx + x) * 4;\n                    totR += inPix.data[i];\n                    totG += inPix.data[i + 1];\n                    totB += inPix.data[i + 2];\n                }\n                for (x = 0; x < width; x++) {\n                    if (x > radius) {\n                        i = (indx - radius - 1) * 4;\n                        totR -= inPix.data[i];\n                        totG -= inPix.data[i + 1];\n                        totB -= inPix.data[i + 2];\n                    }\n                    if (x + radius < width) {\n                        i = (indx + radius) * 4;\n                        totR += inPix.data[i];\n                        totG += inPix.data[i + 1];\n                        totB += inPix.data[i + 2];\n                    }\n                    i = indx * 4;\n                    outPix.data[i] = (totR * mul) | 0;\n                    outPix.data[i + 1] = (totG * mul) | 0;\n                    outPix.data[i + 2] = (totB * mul) | 0;\n                    outPix.data[i + 3] = alpha;\n                    indx++;\n                }\n            }\n        }\n\n        return this;\n    };\n\n    //********************************************   T O O L S   *******************************************************\n    var RgbaColor = function (r, g, b, a) {\n        var red, green, blue, alpha;\n\n        if (arguments.length === 1) {\n            // hexadecimal input #112233\n            b = parseInt(r.substr(5, 2), 16);\n            g = parseInt(r.substr(3, 2), 16);\n            r = parseInt(r.substr(1, 2), 16);\n            a = 1;\n        } else if (arguments.length === 3) {\n            a = 1;\n        }\n\n        function validateColors() {\n            red = range(r, 255);\n            green = range(g, 255);\n            blue = range(b, 255);\n            alpha = range(a, 1);\n        }\n\n        validateColors();\n\n        this.getRed = function () {\n            return red;\n        };\n\n        this.setRed = function (r) {\n            red = range(r, 255);\n        };\n\n        this.getGreen = function () {\n            return green;\n        };\n\n        this.setGreen = function (g) {\n            green = range(g, 255);\n        };\n\n        this.getBlue = function () {\n            return blue;\n        };\n\n        this.setBlue = function (b) {\n            blue = range(b, 255);\n        };\n\n        this.getAlpha = function () {\n            return alpha;\n        };\n\n        this.setAlpha = function (a) {\n            alpha = range(a, 1);\n        };\n\n        this.getRgbaColor = function () {\n            return 'rgba(' + red + ', ' + green + ', ' + blue + ', ' + alpha + ')';\n        };\n\n        this.getRgbColor = function () {\n            return 'rgb(' + red + ', ' + green + ', ' + blue + ')';\n        };\n\n        this.getHexColor = function () {\n            return '#' + red.toString(16) + green.toString(16) + blue.toString(16);\n        };\n    };\n\n    var ConicalGradient = function (fractions, colors) {\n        var limit = fractions.length - 1,\n            i;\n\n        // Pre-multipy fractions array into range -PI to PI\n        for (i = 0; i <= limit; i++) {\n            fractions[i] = TWO_PI * fractions[i] - PI;\n        }\n\n        this.fillCircle = function (ctx, centerX, centerY, innerX, outerX) {\n            var angle,\n                radius = Math.ceil(outerX),\n                diameter = radius * 2,\n                pixels, alpha,\n                x, y, dx, dy, dy2, distance,\n                indx, pixColor,\n                buffer, bufferCtx;\n\n// Original Version using rotated lines\n/*\n            ctx.save();\n            ctx.lineWidth = 1.5;\n            ctx.translate(centerX, centerY);\n            ctx.rotate(rotationOffset);\n            ctx.translate(-centerX, -centerY);\n            for (i = 0, size = fractions.length - 1; i < size; i++) {\n                startAngle = TWO_PI * fractions[i];\n                stopAngle = TWO_PI * fractions[i + 1];\n                range = stopAngle - startAngle;\n                startColor = colors[i];\n                stopColor = colors[i + 1];\n                for (angle = startAngle; angle < stopAngle; angle += angleStep) {\n                    ctx.beginPath();\n                    ctx.fillStyle = getColorFromFraction(startColor, stopColor, range, (angle - startAngle)).getRgbaColor();\n                    ctx.strokeStyle = ctx.fillStyle;\n                    if (innerX > 0) {\n                        ctx.arc(centerX, centerY, innerX, angle + angleStep, angle, true);\n                    } else {\n                        ctx.moveTo(centerX, centerY);\n                    }\n                    ctx.arc(centerX, centerY, outerX, angle, angle + angleStep);\n                    ctx.fill();\n                    ctx.stroke();\n                }\n            }\n*/\n// End - Original Version\n\n            // Create pixel array\n            pixels = ctx.createImageData(diameter, diameter);\n            alpha = 255;\n\n            for (y = 0; y < diameter; y++) {\n                dy = radius - y;\n                dy2 = dy * dy;\n                for (x = 0; x < diameter; x++) {\n                    dx = x - radius;\n                    distance = Math.sqrt((dx * dx) + dy2);\n                    if (distance <= radius && distance >= innerX) { // pixels are transparent by default, so only paint the ones we need\n                        angle = Math.atan2(dx, dy);\n                        for (i = 0; i < limit; i++) {\n                            if (angle >= fractions[i] && angle < fractions[i + 1]) {\n                                pixColor = getColorFromFraction(colors[i], colors[i + 1], fractions[i + 1] - fractions[i], angle - fractions[i], true);\n                            }\n                        }\n                        // The pixel array is addressed as 4 elements per pixel [r,g,b,a]\n                        indx = ((diameter - y) * diameter * 4) + (x * 4);  // plot is 180 rotated from orginal method, so apply a simple invert (diameter - y)\n                        pixels.data[indx]     = pixColor[0];\n                        pixels.data[indx + 1] = pixColor[1];\n                        pixels.data[indx + 2] = pixColor[2];\n                        pixels.data[indx + 3] = alpha;\n                    }\n                }\n            }\n\n            // Create a new buffer to apply the raw data so we can rotate it\n            buffer = createBuffer(diameter, diameter);\n            bufferCtx = buffer.getContext('2d');\n            bufferCtx.putImageData(pixels, 0, 0);\n            // Apply the image buffer\n            ctx.drawImage(buffer, centerX - radius, centerY - radius);\n        };\n\n        this.fillRect = function (ctx, centerX, centerY, width, height, thicknessX, thicknessY) {\n            var angle,\n                width2,\n                height2,\n                pixels, alpha,\n                x, y, dx, dy,\n                indx,\n                pixColor,\n                buffer, bufferCtx;\n\n            width = Math.ceil(width);\n            height = Math.ceil(height);\n            width2 = width / 2;\n            height2 = height / 2;\n            thicknessX = Math.ceil(thicknessX);\n            thicknessY = Math.ceil(thicknessY);\n\n            // Create pixel array\n            pixels = ctx.createImageData(width, height);\n            alpha = 255;\n\n            for (y = 0; y < height; y++) {\n                dy = height2 - y;\n                for (x = 0; x < width; x++) {\n                    if (y > thicknessY && y < height - thicknessY) {\n                        // we are in the range where we only draw the sides\n                        if (x > thicknessX && x < width - thicknessX) {\n                            // we are in the empty 'middle', jump to the next edge\n                            x = width - thicknessX;\n                        }\n                    }\n                    dx = x - width2;\n                    angle = Math.atan2(dx, dy);\n                    for (i = 0; i < limit; i++) {\n                        if (angle >= fractions[i] && angle < fractions[i + 1]) {\n                            pixColor = getColorFromFraction(colors[i], colors[i + 1], fractions[i + 1] - fractions[i], angle - fractions[i], true);\n                        }\n                    }\n                    // The pixel array is addressed as 4 elements per pixel [r,g,b,a]\n                    indx = ((height - y) * width * 4) + (x * 4); // plot is 180 rotated from orginal method, so apply a simple invert (height - y)\n                    pixels.data[indx]     = pixColor[0];\n                    pixels.data[indx + 1] = pixColor[0];\n                    pixels.data[indx + 2] = pixColor[0];\n                    pixels.data[indx + 3] = alpha;\n                }\n            }\n            // Create a new buffer to apply the raw data so we can clip it when drawing to canvas\n            buffer = createBuffer(width, height);\n            bufferCtx = buffer.getContext('2d');\n            bufferCtx.putImageData(pixels, 0, 0);\n\n            // draw the buffer back to the canvas\n            ctx.drawImage(buffer, centerX - width2, centerY - height2);\n        };\n\n    };\n\n    var GradientWrapper = function (start, end, fractions, colors) {\n\n        this.getColorAt = function (fraction) {\n            var lowerLimit = 0,\n                lowerIndex = 0,\n                upperLimit = 1,\n                upperIndex = 1,\n                i,\n                interpolationFraction;\n\n            fraction = (fraction < 0 ? 0 : (fraction > 1 ? 1 : fraction));\n\n            for (i = 0; i < fractions.length; i++) {\n                if (fractions[i] < fraction && lowerLimit < fractions[i]) {\n                    lowerLimit = fractions[i];\n                    lowerIndex = i;\n                }\n                if (fractions[i] === fraction) {\n                    return colors[i];\n                }\n                if (fractions[i] > fraction && upperLimit >= fractions[i]) {\n                    upperLimit = fractions[i];\n                    upperIndex = i;\n                }\n            }\n            interpolationFraction = (fraction - lowerLimit) / (upperLimit - lowerLimit);\n            return getColorFromFraction(colors[lowerIndex], colors[upperIndex], 1, interpolationFraction);\n        };\n\n        this.getStart = function () {\n            return start;\n        };\n\n        this.getEnd = function () {\n            return end;\n        };\n    };\n\n    function setAlpha(hex, alpha) {\n        var hexColor = ('#' === hex.charAt(0)) ? hex.substring(1, 7) : hex,\n            red = parseInt((hexColor).substring(0, 2), 16),\n            green = parseInt((hexColor).substring(2, 4), 16),\n            blue = parseInt((hexColor).substring(4, 6), 16);\n\n        this.color = 'rgba(' + red + ',' + green + ',' + blue + ',' + alpha + ')';\n\n        return this;\n    }\n\n    function getColorFromFraction(sourceColor, destinationColor, range, fraction, returnRawData) {\n        var INT_TO_FLOAT = 1 / 255,\n            sourceRed = sourceColor.getRed(),\n            sourceGreen = sourceColor.getGreen(),\n            sourceBlue = sourceColor.getBlue(),\n            sourceAlpha = sourceColor.getAlpha(),\n\n            deltaRed = destinationColor.getRed() - sourceRed,\n            deltaGreen = destinationColor.getGreen() - sourceGreen,\n            deltaBlue = destinationColor.getBlue() - sourceBlue,\n            deltaAlpha = destinationColor.getAlpha() * INT_TO_FLOAT - sourceAlpha * INT_TO_FLOAT,\n\n            fractionRed = deltaRed / range * fraction,\n            fractionGreen = deltaGreen / range * fraction,\n            fractionBlue = deltaBlue / range * fraction,\n            fractionAlpha = deltaAlpha / range * fraction;\n\n        returnRawData = returnRawData || false;\n        if (returnRawData) {\n            return [(sourceRed + fractionRed).toFixed(0), (sourceGreen + fractionGreen).toFixed(0), (sourceBlue + fractionBlue).toFixed(0), sourceAlpha + fractionAlpha];\n        } else {\n            return new RgbaColor((sourceRed + fractionRed).toFixed(0), (sourceGreen + fractionGreen).toFixed(0), (sourceBlue + fractionBlue).toFixed(0), sourceAlpha + fractionAlpha);\n        }\n    }\n\n    function section(start, stop, color) {\n        return {start : start,\n                stop : stop,\n                color : color};\n    }\n\n    Math.log10 = function (value) {\n        return (Math.log(value) / Math.LN10);\n    };\n\n    function calcNiceNumber(range, round) {\n        var exponent = Math.floor(Math.log10(range)),   // exponent of range\n            fraction = range / Math.pow(10, exponent),  // fractional part of range\n            niceFraction;                               // nice, rounded fraction\n\n        if (round) {\n            if (1.5 > fraction) {\n                niceFraction = 1;\n            } else if (3 > fraction) {\n                niceFraction = 2;\n            } else if (7 > fraction) {\n                niceFraction = 5;\n            } else {\n                niceFraction = 10;\n            }\n        } else {\n            if (1 >= fraction) {\n                niceFraction = 1;\n            } else if (2 >= fraction) {\n                niceFraction = 2;\n            } else if (5 >= fraction) {\n                niceFraction = 5;\n            } else {\n                niceFraction = 10;\n            }\n        }\n        return niceFraction * Math.pow(10, exponent);\n    }\n\n    function roundedRectangle(ctx, x, y, w, h, radius) {\n        var r = x + w,\n            b = y + h;\n        ctx.beginPath();\n        ctx.moveTo(x + radius, y);\n        ctx.lineTo(r - radius, y);\n        ctx.quadraticCurveTo(r, y, r, y + radius);\n        ctx.lineTo(r, y + h - radius);\n        ctx.quadraticCurveTo(r, b, r - radius, b);\n        ctx.lineTo(x + radius, b);\n        ctx.quadraticCurveTo(x, b, x, b - radius);\n        ctx.lineTo(x, y + radius);\n        ctx.quadraticCurveTo(x, y, x + radius, y);\n        ctx.closePath();\n        ctx.stroke();\n    }\n\n    function createBuffer(width, height) {\n        var buffer = doc.createElement('canvas');\n        buffer.width = width;\n        buffer.height = height;\n        return buffer;\n    }\n\n    function drawToBuffer(width, height, drawFunction) {\n        var buffer = doc.createElement('canvas');\n        buffer.width = width;\n        buffer.height = height;\n        drawFunction(buffer.getContext('2d'));\n        return buffer;\n    }\n\n    function getColorValues(color) {\n        var colorData,\n            lookupBuffer = drawToBuffer(1, 1, function (ctx) {\n                ctx.fillStyle = color;\n                ctx.beginPath();\n                ctx.rect(0, 0, 1, 1);\n                ctx.fill();\n            });\n        colorData = lookupBuffer.getContext('2d').getImageData(0, 0, 2, 2).data;\n\n        /*\n        for (var i = 0; i < data.length; i += 4) {\n            var red = data[i];       // red\n            var green = data[i + 1]; // green\n            var blue = data[i + 2];  // blue\n            //var alpha = data[i + 3]; // alpha\n            console.log(red + ', ' + green + ', ' + blue);\n        }\n        */\n\n        return [colorData[0], colorData[1], colorData[2], colorData[3]];\n    }\n\n    function customColorDef(color) {\n        var VERY_DARK,\n            DARK,\n            LIGHT,\n            LIGHTER,\n            VERY_LIGHT,\n            values = getColorValues(color),\n            rgbaCol = new RgbaColor(values[0], values[1], values[2], values[3]);\n\n        VERY_DARK = darker(rgbaCol, 0.32);\n        DARK = darker(rgbaCol, 0.62);\n        LIGHT = lighter(rgbaCol, 0.84);\n        LIGHTER = lighter(rgbaCol, 0.94);\n        VERY_LIGHT = lighter(rgbaCol, 1);\n\n        return new ColorDef(VERY_DARK, DARK, rgbaCol, LIGHT, LIGHTER, VERY_LIGHT);\n    }\n\n    function rgbToHsl(red, green, blue) {\n        var min, max, hue, saturation, lightness, delta;\n\n        red /= 255;\n        green /= 255;\n        blue /= 255;\n\n        max = Math.max(red, green, blue);\n        min = Math.min(red, green, blue);\n        lightness = (max + min) / 2;\n\n        if (max === min) {\n            hue = saturation = 0; // achromatic\n        } else {\n            delta = max - min;\n            saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n            switch (max) {\n            case red:\n                hue = (green - blue) / delta + (green < blue ? 6 : 0);\n                break;\n            case green:\n                hue = (blue - red) / delta + 2;\n                break;\n            case blue:\n                hue = (red - green) / delta + 4;\n                break;\n            }\n            hue /= 6;\n        }\n        return [hue, saturation, lightness];\n    }\n\n/* These functions are not currently used\n    function hslToRgb(hue, saturation, lightness) {\n        var red, green, blue, p, q;\n\n        function hue2rgb(p, q, t) {\n            if (t < 0) {\n                t += 1;\n            }\n            if (t > 1) {\n                t -= 1;\n            }\n            if (t < 1 / 6) {\n                return p + (q - p) * 6 * t;\n            }\n            if (t < 1 / 2) {\n                return q;\n            }\n            if (t < 2 / 3) {\n                return p + (q - p) * (2 / 3 - t) * 6;\n            }\n            return p;\n        }\n\n        if (saturation === 0) {\n            red = green = blue = lightness; // achromatic\n        } else {\n            q = (lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation);\n            p = 2 * lightness - q;\n            red = hue2rgb(p, q, hue + 1 / 3);\n            green = hue2rgb(p, q, hue);\n            blue = hue2rgb(p, q, hue - 1 / 3);\n        }\n\n        return [Math.floor(red * 255), Math.floor(green * 255), Math.floor(blue * 255)];\n    }\n\n    function hsbToHsl(hue, saturation, brightness) {\n        var lightness = (brightness - saturation) / 2;\n        lightness = range(lightness, 1);\n        return [hue, saturation, lightness];\n    }\n\n    function hslToHsb(hue, saturation, lightness) {\n        var brightness = (lightness * 2) + saturation;\n        return [hue, saturation, brightness];\n    }\n*/\n\n    function hsbToRgb(hue, saturation, brightness) {\n        var r, g, b,\n            i = Math.floor(hue * 6),\n            f = hue * 6 - i,\n            p = brightness * (1 - saturation),\n            q = brightness * (1 - f * saturation),\n            t = brightness * (1 - (1 - f) * saturation);\n\n        switch (i % 6) {\n        case 0:\n            r = brightness;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = brightness;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = brightness;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = brightness;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = brightness;\n            break;\n        case 5:\n            r = brightness;\n            g = p;\n            b = q;\n            break;\n        }\n\n        return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];\n    }\n\n    function rgbToHsb(r, g, b) {\n        var min, max, hue, saturation, brightness, delta;\n\n        r = r / 255;\n        g = g / 255;\n        b = b / 255;\n        max = Math.max(r, g, b);\n        min = Math.min(r, g, b);\n        brightness = max;\n        delta = max - min;\n        saturation = max === 0 ? 0 : delta / max;\n\n        if (max === min) {\n            hue = 0; // achromatic\n        } else {\n            switch (max) {\n            case r:\n                hue = (g - b) / delta + (g < b ? 6 : 0);\n                break;\n            case g:\n                hue = (b - r) / delta + 2;\n                break;\n            case b:\n                hue = (r - g) / delta + 4;\n                break;\n            }\n            hue /= 6;\n        }\n        return [hue, saturation, brightness];\n    }\n\n    function range(value, limit) {\n        return (value < 0 ? 0 : (value > limit ? limit : value));\n    }\n\n    function darker(color, fraction) {\n        var red = Math.floor(color.getRed() * (1 - fraction)),\n            green = Math.floor(color.getGreen() * (1 - fraction)),\n            blue = Math.floor(color.getBlue() * (1 - fraction));\n\n        red = range(red, 255);\n        green = range(green, 255);\n        blue = range(blue, 255);\n\n        return new RgbaColor(red, green, blue, color.getAlpha());\n    }\n\n    function lighter(color, fraction) {\n        var red = Math.round(color.getRed() * (1 + fraction)),\n            green = Math.round(color.getGreen() * (1 + fraction)),\n            blue = Math.round(color.getBlue() * (1 + fraction));\n\n        red = range(red, 255);\n        green = range(green, 255);\n        blue = range(blue, 255);\n\n        return new RgbaColor(red, green, blue, color.getAlpha());\n    }\n\n    function wrap(value, lower, upper) {\n        var distance, times;\n        if (upper <= lower) {\n            throw 'Rotary bounds are of negative or zero size';\n        }\n\n        distance = upper - lower;\n        times = Math.floor((value - lower) / distance);\n\n        return value - (times * distance);\n    }\n\n    function getShortestAngle(from, to) {\n        return wrap((to - from), -180, 180);\n    }\n\n    // shim layer\n    var requestAnimFrame = (function () {\n        return  window.requestAnimationFrame   ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame    ||\n            window.oRequestAnimationFrame      ||\n            window.msRequestAnimationFrame     ||\n            function (callback) {\n                window.setTimeout(callback, 1000 / 16);\n            };\n    }());\n\n    function getCanvasContext(elementOrId) {\n        var element = (typeof elementOrId === 'string' || elementOrId instanceof String) ?\n            doc.getElementById(elementOrId) : elementOrId;\n        return element.getContext('2d');\n    }\n\n/*\n    function blur(ctx, width, height, radius) {\n    // This function is too CPU expensive\n    // leave disabled for now :(\n\n        // Cheap'n'cheerful blur filter, just applies horizontal and vertical blurs\n        // Only works for square canvas's at present\n\n        var j, x, y,      // loop counters\n            i,\n            end,\n            totR, totG, totB, totA,\n            // Create a temporary buffer\n            tempBuffer = createBuffer(width, height),\n            tempCtx = tempBuffer.getContext('2d'),\n            // pixel data\n            inPix, outPix,\n            mul,\n            indx;\n\n        ctx.save();\n\n        for (j = 0; j < 2; j++) {\n            // Get access to the pixel data\n            inPix = ctx.getImageData(0, 0, (j === 0 ? width : height), (j === 0 ? height : width));\n            outPix = ctx.createImageData((j === 0 ? width : height), (j === 0 ? height : width));\n\n            if (j === 0) { // Horizontal blur\n                if (radius >= width) {\n                    radius = width - 1;\n                }\n            } else { // Vertical blur\n                if (radius >= height) {\n                    radius = height - 1;\n                }\n            }\n            mul = 1 / (radius * 2 + 1);\n            indx = 0;\n            for (y = 0, end = (j === 0 ? height : width); y < end; y++) {\n                totR = totG = totB = totA = 0;\n                for (x = 0; x < radius ; x++) {\n                    i = (indx + x) * 4;\n                    totR += inPix.data[i];\n                    totG += inPix.data[i + 1];\n                    totB += inPix.data[i + 2];\n                    totA += inPix.data[i + 3];\n                }\n                for (x = 0; x < (j === 0 ? width : height); x++) {\n                    if (x > radius) {\n                        i = (indx - radius - 1) * 4;\n                        totR -= inPix.data[i];\n                        totG -= inPix.data[i + 1];\n                        totB -= inPix.data[i + 2];\n                        totA -= inPix.data[i + 3];\n                    }\n                    if (x + radius < width) {\n                        i = (indx + radius) * 4;\n                        totR += inPix.data[i];\n                        totG += inPix.data[i + 1];\n                        totB += inPix.data[i + 2];\n                        totA += inPix.data[i + 3];\n                    }\n                    i = indx * 4;\n                    outPix.data[i] = (totR * mul) | 0;\n                    outPix.data[i + 1] = (totG * mul) | 0;\n                    outPix.data[i + 2] = (totB * mul) | 0;\n                    outPix.data[i + 3] = (totA * mul) | 0;\n                    indx++;\n                }\n            }\n            // Write the output pixel data back to the temp buffer\n            tempCtx.clearRect(0, 0, width, height);\n            tempCtx.putImageData(outPix, 0, 0);\n            if (j === 0) {\n                // Clear the input canvas\n                ctx.clearRect(0, 0, width, height);\n                // Rotate image by 90 degrees\n                ctx.translate(width / 2, height / 2);\n                ctx.rotate(HALF_PI);\n                ctx.translate(-width / 2, -height / 2);\n                // Write the buffer back\n                ctx.drawImage(tempBuffer, 0, 0);\n            }\n        }\n        ctx.translate(width / 2, height / 2);\n        ctx.rotate(-PI);\n        ctx.translate(-width / 2, -height / 2);\n        // Clear the input canvas\n        ctx.clearRect(0, 0, width, height);\n        ctx.drawImage(tempBuffer, 0, 0);\n        ctx.restore();\n\n    }\n*/\n    //****************************************   C O N S T A N T S   ***************************************************\n    var BackgroundColorDef;\n    (function () {\n        BackgroundColorDef = function (gradientStart, gradientFraction, gradientStop, labelColor, symbolColor, name) {\n            this.gradientStart = gradientStart;\n            this.gradientFraction = gradientFraction;\n            this.gradientStop = gradientStop;\n            this.labelColor = labelColor;\n            this.symbolColor = symbolColor;\n            this.name = name;\n        };\n    }());\n\n    var LcdColorDef;\n    (function () {\n        LcdColorDef = function (gradientStartColor, gradientFraction1Color, gradientFraction2Color, gradientFraction3Color, gradientStopColor, textColor) {\n            this.gradientStartColor = gradientStartColor;\n            this.gradientFraction1Color = gradientFraction1Color;\n            this.gradientFraction2Color = gradientFraction2Color;\n            this.gradientFraction3Color = gradientFraction3Color;\n            this.gradientStopColor = gradientStopColor;\n            this.textColor = textColor;\n        };\n    }());\n\n    var ColorDef;\n    (function () {\n        ColorDef = function (veryDark, dark, medium, light, lighter, veryLight) {\n            this.veryDark = veryDark;\n            this.dark = dark;\n            this.medium = medium;\n            this.light = light;\n            this.lighter = lighter;\n            this.veryLight = veryLight;\n        };\n    }());\n\n    var LedColorDef;\n    (function () {\n        LedColorDef = function (innerColor1_ON, innerColor2_ON, outerColor_ON, coronaColor, innerColor1_OFF, innerColor2_OFF, outerColor_OFF) {\n            this.innerColor1_ON = innerColor1_ON;\n            this.innerColor2_ON = innerColor2_ON;\n            this.outerColor_ON = outerColor_ON;\n            this.coronaColor = coronaColor;\n            this.innerColor1_OFF = innerColor1_OFF;\n            this.innerColor2_OFF = innerColor2_OFF;\n            this.outerColor_OFF = outerColor_OFF;\n        };\n    }());\n\n    var GaugeTypeDef;\n    (function () {\n        GaugeTypeDef = function (type) {\n            this.type = type;\n        };\n    }());\n\n    var OrientationDef;\n    (function () {\n        OrientationDef = function (type) {\n            this.type = type;\n        };\n    }());\n\n    var KnobTypeDef;\n    (function () {\n        KnobTypeDef = function (type) {\n            this.type = type;\n        };\n    }());\n\n    var KnobStyleDef;\n    (function () {\n        KnobStyleDef = function (style) {\n            this.style = style;\n        };\n    }());\n\n    var FrameDesignDef;\n    (function () {\n        FrameDesignDef = function (design) {\n            this.design = design;\n        };\n    }());\n\n    var PointerTypeDef;\n    (function () {\n        PointerTypeDef = function (type) {\n            this.type = type;\n        };\n    }());\n\n    var ForegroundTypeDef;\n    (function () {\n        ForegroundTypeDef = function (type) {\n            this.type = type;\n        };\n    }());\n\n    var LabelNumberFormatDef;\n    (function () {\n        LabelNumberFormatDef = function (format) {\n            this.format = format;\n        };\n    }());\n\n    var TickLabelOrientationDef;\n    (function () {\n        TickLabelOrientationDef = function (type) {\n            this.type = type;\n        };\n    }());\n\n    var TrendStateDef;\n    (function () {\n        TrendStateDef = function (state) {\n            this.state = state;\n        };\n    }());\n\n    //*************************   I m p l e m e n t a t i o n s   o f   d e f i n i t i o n s   ************************\n    var backgroundColor = {\n        DARK_GRAY: new BackgroundColorDef(new RgbaColor(0, 0, 0, 1), new RgbaColor(51, 51, 51, 1), new RgbaColor(153, 153, 153, 1), new RgbaColor(255, 255, 255, 1), new RgbaColor(180, 180, 180, 1), 'DARK_GRAY'),\n        SATIN_GRAY: new BackgroundColorDef(new RgbaColor(45, 57, 57, 1), new RgbaColor(45, 57, 57, 1), new RgbaColor(45, 57, 57, 1), new RgbaColor(167, 184, 180, 1), new RgbaColor(137, 154, 150, 1), 'SATIN_GRAY'),\n        LIGHT_GRAY: new BackgroundColorDef(new RgbaColor(130, 130, 130, 1), new RgbaColor(181, 181, 181, 1), new RgbaColor(253, 253, 253, 1), new RgbaColor(0, 0, 0, 1), new RgbaColor(80, 80, 80, 1), 'LIGHT_GRAY'),\n        WHITE: new BackgroundColorDef(new RgbaColor(255, 255, 255, 1), new RgbaColor(255, 255, 255, 1), new RgbaColor(255, 255, 255, 1), new RgbaColor(0, 0, 0, 1), new RgbaColor(80, 80, 80, 1), 'WHITE'),\n        BLACK: new BackgroundColorDef(new RgbaColor(0, 0, 0, 1), new RgbaColor(0, 0, 0, 1), new RgbaColor(0, 0, 0, 1), new RgbaColor(255, 255, 255, 1), new RgbaColor(150, 150, 150, 1), 'BLACK'),\n        BEIGE: new BackgroundColorDef(new RgbaColor(178, 172, 150, 1), new RgbaColor(204, 205, 184, 1), new RgbaColor(231, 231, 214, 1), new RgbaColor(0, 0, 0, 1), new RgbaColor(80, 80, 80, 1), 'BEIGE'),\n        BROWN: new BackgroundColorDef(new RgbaColor(245, 225, 193, 1), new RgbaColor(245, 225, 193, 1), new RgbaColor(255, 250, 240, 1), new RgbaColor(109, 73, 47, 1), new RgbaColor(89, 53, 27, 1), 'BROWN'),\n        RED: new BackgroundColorDef(new RgbaColor(198, 93, 95, 1), new RgbaColor(212, 132, 134, 1), new RgbaColor(242, 218, 218, 1), new RgbaColor(0, 0, 0, 1), new RgbaColor(90, 0, 0, 1), 'RED'),\n        GREEN: new BackgroundColorDef(new RgbaColor(65, 120, 40, 1), new RgbaColor(129, 171, 95, 1), new RgbaColor(218, 237, 202, 1), new RgbaColor(0, 0, 0, 1), new RgbaColor(0, 90, 0, 1), 'GREEN'),\n        BLUE: new BackgroundColorDef(new RgbaColor(45, 83, 122, 1), new RgbaColor(115, 144, 170, 1), new RgbaColor(227, 234, 238, 1), new RgbaColor(0, 0, 0, 1), new RgbaColor(0, 0, 90, 1), 'BLUE'),\n        ANTHRACITE: new BackgroundColorDef(new RgbaColor(50, 50, 54, 1), new RgbaColor(47, 47, 51, 1), new RgbaColor(69, 69, 74, 1), new RgbaColor(250, 250, 250, 1), new RgbaColor(180, 180, 180, 1), 'ANTHRACITE'),\n        MUD: new BackgroundColorDef(new RgbaColor(80, 86, 82, 1), new RgbaColor(70, 76, 72, 1), new RgbaColor(57, 62, 58, 1), new RgbaColor(255, 255, 240, 1), new RgbaColor(225, 225, 210, 1), 'MUD'),\n        PUNCHED_SHEET: new BackgroundColorDef(new RgbaColor(50, 50, 54, 1), new RgbaColor(47, 47, 51, 1), new RgbaColor(69, 69, 74, 1), new RgbaColor(255, 255, 255, 1), new RgbaColor(180, 180, 180, 1), 'PUNCHED_SHEET'),\n        CARBON: new BackgroundColorDef(new RgbaColor(50, 50, 54, 1), new RgbaColor(47, 47, 51, 1), new RgbaColor(69, 69, 74, 1), new RgbaColor(255, 255, 255, 1), new RgbaColor(180, 180, 180, 1), 'CARBON'),\n        STAINLESS: new BackgroundColorDef(new RgbaColor(130, 130, 130, 1), new RgbaColor(181, 181, 181, 1), new RgbaColor(253, 253, 253, 1), new RgbaColor(0, 0, 0, 1), new RgbaColor(80, 80, 80, 1), 'STAINLESS'),\n        BRUSHED_METAL: new BackgroundColorDef(new RgbaColor(50, 50, 54, 1), new RgbaColor(47, 47, 51, 1), new RgbaColor(69, 69, 74, 1), new RgbaColor(0, 0, 0, 1), new RgbaColor(80, 80, 80, 1), 'BRUSHED_METAL'),\n        BRUSHED_STAINLESS: new BackgroundColorDef(new RgbaColor(50, 50, 54, 1), new RgbaColor(47, 47, 51, 1), new RgbaColor(110, 110, 112, 1), new RgbaColor(0, 0, 0, 1), new RgbaColor(80, 80, 80, 1), 'BRUSHED_STAINLESS'),\n        TURNED: new BackgroundColorDef(new RgbaColor(130, 130, 130, 1), new RgbaColor(181, 181, 181, 1), new RgbaColor(253, 253, 253, 1), new RgbaColor(0, 0, 0, 1), new RgbaColor(80, 80, 80, 1), 'TURNED')\n    };\n\n    var lcdColor = {\n        BEIGE: new LcdColorDef('#c8c8b1', 'rgb(241, 237, 207)', 'rgb(234, 230, 194)', 'rgb(225, 220, 183)', 'rgb(237, 232, 191)', '#000000'),\n        BLUE: new LcdColorDef('#ffffff', 'rgb(231, 246, 255)', 'rgb(170, 224, 255)', 'rgb(136, 212, 255)', 'rgb(192, 232, 255)', '#124564'),\n        ORANGE: new LcdColorDef('#ffffff', 'rgb(255, 245, 225)', 'rgb(255, 217, 147)', 'rgb(255, 201, 104)', 'rgb(255, 227, 173)', '#503700'),\n        RED: new LcdColorDef('#ffffff', 'rgb(255, 225, 225)', 'rgb(253, 152, 152)', 'rgb(252, 114, 115)', 'rgb(254, 178, 178)', '#4f0c0e'),\n        YELLOW: new LcdColorDef('#ffffff', 'rgb(245, 255, 186)', 'rgb(210, 255, 0)', 'rgb(158, 205, 0)', 'rgb(210, 255, 0)', '#405300'),\n        WHITE: new LcdColorDef('#ffffff', '#ffffff', 'rgb(241, 246, 242)', 'rgb(229, 239, 244)', '#ffffff', '#000000'),\n        GRAY: new LcdColorDef('#414141', 'rgb(117, 117, 117)', 'rgb(87, 87, 87)', '#414141', 'rgb(81, 81, 81)', '#ffffff'),\n        BLACK: new LcdColorDef('#414141', '#666666', '#333333', '#000000', '#333333', '#cccccc'),\n        GREEN: new LcdColorDef('rgb(33, 67, 67)', 'rgb(33, 67, 67)', 'rgb(29, 58, 58)', 'rgb(28, 57, 57)', 'rgb(23, 46, 46)', 'rgba(0, 185, 165, 255)'),\n        BLUE2: new LcdColorDef('rgb(0, 68, 103)', 'rgb(8, 109, 165)', 'rgb(0, 72, 117)', 'rgb(0, 72, 117)', 'rgb(0, 68, 103)', 'rgb(111, 182, 228)'),\n        BLUE_BLACK: new LcdColorDef('rgb(22, 125, 212)', 'rgb(3, 162, 254)', 'rgb(3, 162, 254)', 'rgb(3, 162, 254)', 'rgb(11, 172, 244)', '#000000'),\n        BLUE_DARKBLUE: new LcdColorDef('rgb(18, 33, 88)', 'rgb(18, 33, 88)', 'rgb(19, 30, 90)', 'rgb(17, 31, 94)', 'rgb(21, 25, 90)', 'rgb(23, 99, 221)'),\n        BLUE_GRAY: new LcdColorDef('rgb(135, 174, 255)', 'rgb(101, 159, 255)', 'rgb(44, 93, 255)', 'rgb(27, 65, 254)', 'rgb(12, 50, 255)', '#b2b4ed'),\n        STANDARD: new LcdColorDef('rgb(131, 133, 119)', 'rgb(176, 183, 167)', 'rgb(165, 174, 153)', 'rgb(166, 175, 156)', 'rgb(175, 184, 165)', 'rgb(35, 42, 52)'),\n        STANDARD_GREEN: new LcdColorDef('#ffffff', 'rgb(219, 230, 220)', 'rgb(179, 194, 178)', 'rgb(153, 176, 151)', 'rgb(114, 138, 109)', '#080C06'),\n        BLUE_BLUE: new LcdColorDef('rgb(100, 168, 253)', 'rgb(100, 168, 253)', 'rgb(95, 160, 250)', 'rgb(80, 144, 252)', 'rgb(74, 134, 255)', '#002cbb'),\n        RED_DARKRED: new LcdColorDef('rgb(72, 36, 50)', 'rgb(185, 111, 110)', 'rgb(148, 66, 72)', 'rgb(83, 19, 20)', 'rgb(7, 6, 14)', '#FE8B92'),\n        DARKBLUE: new LcdColorDef('rgb(14, 24, 31)', 'rgb(46, 105, 144)', 'rgb(19, 64, 96)', 'rgb(6, 20, 29)', 'rgb(8, 9, 10)', '#3DB3FF'),\n        LILA: new LcdColorDef('rgb(175, 164, 255)', 'rgb(188, 168, 253)', 'rgb(176, 159, 255)', 'rgb(174, 147, 252)', 'rgb(168, 136, 233)', '#076148'),\n        BLACKRED: new LcdColorDef('rgb(8, 12, 11)', 'rgb(10, 11, 13)', 'rgb(11, 10, 15)', 'rgb(7, 13, 9)', 'rgb(9, 13, 14)', '#B50026'),\n        DARKGREEN: new LcdColorDef('rgb(25, 85, 0)', 'rgb(47, 154, 0)', 'rgb(30, 101, 0)', 'rgb(30, 101, 0)', 'rgb(25, 85, 0)', '#233123'),\n        AMBER: new LcdColorDef('rgb(182, 71, 0)', 'rgb(236, 155, 25)', 'rgb(212, 93, 5)', 'rgb(212, 93, 5)', 'rgb(182, 71, 0)', '#593A0A'),\n        LIGHTBLUE: new LcdColorDef('rgb(125, 146, 184)', 'rgb(197, 212, 231)', 'rgb(138, 155, 194)', 'rgb(138, 155, 194)', 'rgb(125, 146, 184)', '#090051'),\n        SECTIONS: new LcdColorDef('#b2b2b2', '#ffffff', '#c4c4c4', '#c4c4c4', '#b2b2b2', '#000000')\n    };\n\n    var color = {\n        RED: new ColorDef(new RgbaColor(82, 0, 0, 1), new RgbaColor(158, 0, 19, 1), new RgbaColor(213, 0, 25, 1), new RgbaColor(240, 82, 88, 1), new RgbaColor(255, 171, 173, 1), new RgbaColor(255, 217, 218, 1)),\n        GREEN: new ColorDef(new RgbaColor(8, 54, 4, 1), new RgbaColor(0, 107, 14, 1), new RgbaColor(15, 148, 0, 1), new RgbaColor(121, 186, 37, 1), new RgbaColor(190, 231, 141, 1), new RgbaColor(234, 247, 218, 1)),\n        BLUE: new ColorDef(new RgbaColor(0, 11, 68, 1), new RgbaColor(0, 73, 135, 1), new RgbaColor(0, 108, 201, 1), new RgbaColor(0, 141, 242, 1), new RgbaColor(122, 200, 255, 1), new RgbaColor(204, 236, 255, 1)),\n        ORANGE: new ColorDef(new RgbaColor(118, 83, 30, 1), new RgbaColor(215, 67, 0, 1), new RgbaColor(240, 117, 0, 1), new RgbaColor(255, 166, 0, 1), new RgbaColor(255, 255, 128, 1), new RgbaColor(255, 247, 194, 1)),\n        YELLOW: new ColorDef(new RgbaColor(41, 41, 0, 1), new RgbaColor(102, 102, 0, 1), new RgbaColor(177, 165, 0, 1), new RgbaColor(255, 242, 0, 1), new RgbaColor(255, 250, 153, 1), new RgbaColor(255, 252, 204, 1)),\n        CYAN: new ColorDef(new RgbaColor(15, 109, 109, 1), new RgbaColor(0, 109, 144, 1), new RgbaColor(0, 144, 191, 1), new RgbaColor(0, 174, 239, 1), new RgbaColor(153, 223, 249, 1), new RgbaColor(204, 239, 252, 1)),\n        MAGENTA: new ColorDef(new RgbaColor(98, 0, 114, 1), new RgbaColor(128, 24, 72, 1), new RgbaColor(191, 36, 107, 1), new RgbaColor(255, 48, 143, 1), new RgbaColor(255, 172, 210, 1), new RgbaColor(255, 214, 23, 1)),\n        WHITE: new ColorDef(new RgbaColor(210, 210, 210, 1), new RgbaColor(220, 220, 220, 1), new RgbaColor(235, 235, 235, 1), new RgbaColor(255, 255, 255, 1), new RgbaColor(255, 255, 255, 1), new RgbaColor(255, 255, 255, 1)),\n        GRAY: new ColorDef(new RgbaColor(25, 25, 25, 1), new RgbaColor(51, 51, 51, 1), new RgbaColor(76, 76, 76, 1), new RgbaColor(128, 128, 128, 1), new RgbaColor(204, 204, 204, 1), new RgbaColor(243, 243, 243, 1)),\n        BLACK: new ColorDef(new RgbaColor(0, 0, 0, 1), new RgbaColor(5, 5, 5, 1), new RgbaColor(10, 10, 10, 1), new RgbaColor(15, 15, 15, 1), new RgbaColor(20, 20, 20, 1), new RgbaColor(25, 25, 25, 1)),\n        RAITH: new ColorDef(new RgbaColor(0, 32, 65, 1), new RgbaColor(0, 65, 125, 1), new RgbaColor(0, 106, 172, 1), new RgbaColor(130, 180, 214, 1), new RgbaColor(148, 203, 242, 1), new RgbaColor(191, 229, 255, 1)),\n        GREEN_LCD: new ColorDef(new RgbaColor(0, 55, 45, 1), new RgbaColor(15, 109, 93, 1), new RgbaColor(0, 185, 165, 1), new RgbaColor(48, 255, 204, 1), new RgbaColor(153, 255, 227, 1), new RgbaColor(204, 255, 241, 1)),\n        JUG_GREEN: new ColorDef(new RgbaColor(0, 56, 0, 1), new RgbaColor(32, 69, 36, 1), new RgbaColor(50, 161, 0, 1), new RgbaColor(129, 206, 0, 1), new RgbaColor(190, 231, 141, 1), new RgbaColor(234, 247, 218, 1))\n    };\n\n    var ledColor = {\n        RED_LED: new LedColorDef('#FF9A89', '#FF9A89', '#FF3300', '#FF8D70', '#7E1C00', '#7E1C00', '#641B00'),\n        GREEN_LED: new LedColorDef('#9AFF89', '#9AFF89', '#59FF2A', '#A5FF00', '#1C7E00', '#1C7E00', '#1B6400'),\n        BLUE_LED: new LedColorDef('#899AFF', '#899AFF', '#0033FF', '#708DFF', '#001C7E', '#001C7E', '#001B64'),\n        ORANGE_LED: new LedColorDef('#FEA23F', '#FEA23F', '#FD6C00', '#FD6C00', '#592800', '#592800', '#421F00'),\n        YELLOW_LED: new LedColorDef('#FFFF62', '#FFFF62', '#FFFF00', '#FFFF00', '#6B6D00', '#6B6D00', '#515300'),\n        CYAN_LED: new LedColorDef('#00FFFF', '#00FFFF', '#1BC3C3', '#00FFFF', '#083B3B', '#083B3B', '#052727'),\n        MAGENTA_LED: new LedColorDef('#D300FF', '#D300FF', '#8600CB', '#C300FF', '#38004B', '#38004B', '#280035')\n    };\n\n    var gaugeType = {\n        TYPE1: new GaugeTypeDef('type1'),\n        TYPE2: new GaugeTypeDef('type2'),\n        TYPE3: new GaugeTypeDef('type3'),\n        TYPE4: new GaugeTypeDef('type4'),\n        TYPE5: new GaugeTypeDef('type5')\n    };\n\n    var orientation = {\n        NORTH: new OrientationDef('north'),\n        SOUTH: new OrientationDef('south'),\n        EAST: new OrientationDef('east'),\n        WEST: new OrientationDef('west')\n    };\n\n    var knobType = {\n        STANDARD_KNOB: new KnobTypeDef('standardKnob'),\n        METAL_KNOB: new KnobTypeDef('metalKnob')\n    };\n\n    var knobStyle = {\n        BLACK: new KnobStyleDef('black'),\n        BRASS: new KnobStyleDef('brass'),\n        SILVER: new KnobStyleDef('silver')\n    };\n\n    var frameDesign = {\n        BLACK_METAL: new FrameDesignDef('blackMetal'),\n        METAL: new FrameDesignDef('metal'),\n        SHINY_METAL: new FrameDesignDef('shinyMetal'),\n        BRASS: new FrameDesignDef('brass'),\n        STEEL: new FrameDesignDef('steel'),\n        CHROME: new FrameDesignDef('chrome'),\n        GOLD: new FrameDesignDef('gold'),\n        ANTHRACITE: new FrameDesignDef('anthracite'),\n        TILTED_GRAY: new FrameDesignDef('tiltedGray'),\n        TILTED_BLACK: new FrameDesignDef('tiltedBlack'),\n        GLOSSY_METAL: new FrameDesignDef('glossyMetal')\n    };\n\n    var pointerType = {\n        TYPE1: new PointerTypeDef('type1'),\n        TYPE2: new PointerTypeDef('type2'),\n        TYPE3: new PointerTypeDef('type3'),\n        TYPE4: new PointerTypeDef('type4'),\n        TYPE5: new PointerTypeDef('type5'),\n        TYPE6: new PointerTypeDef('type6'),\n        TYPE7: new PointerTypeDef('type7'),\n        TYPE8: new PointerTypeDef('type8'),\n        TYPE9: new PointerTypeDef('type9'),\n        TYPE10: new PointerTypeDef('type10'),\n        TYPE11: new PointerTypeDef('type11'),\n        TYPE12: new PointerTypeDef('type12'),\n        TYPE13: new PointerTypeDef('type13'),\n        TYPE14: new PointerTypeDef('type14'),\n        TYPE15: new PointerTypeDef('type15'),\n        TYPE16: new PointerTypeDef('type16')\n    };\n\n    var foregroundType = {\n        TYPE1: new ForegroundTypeDef('type1'),\n        TYPE2: new ForegroundTypeDef('type2'),\n        TYPE3: new ForegroundTypeDef('type3'),\n        TYPE4: new ForegroundTypeDef('type4'),\n        TYPE5: new ForegroundTypeDef('type5')\n    };\n\n    var labelNumberFormat = {\n        STANDARD: new LabelNumberFormatDef('standard'),\n        FRACTIONAL: new LabelNumberFormatDef('fractional'),\n        SCIENTIFIC: new LabelNumberFormatDef('scientific')\n    };\n\n    var tickLabelOrientation = {\n        NORMAL: new TickLabelOrientationDef('normal'),\n        HORIZONTAL: new TickLabelOrientationDef('horizontal'),\n        TANGENT: new TickLabelOrientationDef('tangent')\n    };\n\n    var trendState = {\n        UP: new TrendStateDef('up'),\n        STEADY: new TrendStateDef('steady'),\n        DOWN: new TrendStateDef('down'),\n        OFF: new TrendStateDef('off')\n    };\n\n    //**********************************   E X P O R T   F U N C T I O N S   *******************************************\n    return {\n        // Components EXTERNAL : INTERNAL\n        Radial : radial,\n        RadialBargraph : radialBargraph,\n        RadialVertical : radialVertical,\n        Linear: linear,\n        LinearBargraph: linearBargraph,\n        DisplaySingle: displaySingle,\n        DisplayMulti: displayMulti,\n        Level : level,\n        Compass : compass,\n        WindDirection : windDirection,\n        Horizon : horizon,\n        Led : led,\n        Clock : clock,\n        Battery : battery,\n        StopWatch : stopwatch,\n        Altimeter : altimeter,\n        TrafficLight: trafficlight,\n        LightBulb: lightbulb,\n        Odometer: odometer,\n\n        // Images\n        drawFrame : drawRadialFrameImage,\n        drawBackground : drawRadialBackgroundImage,\n        drawForeground : drawRadialForegroundImage,\n\n        // Tools\n        rgbaColor :  RgbaColor,\n        ConicalGradient : ConicalGradient,\n        setAlpha : setAlpha,\n        getColorFromFraction : getColorFromFraction,\n        gradientWrapper : GradientWrapper,\n\n        // Constants\n        BackgroundColor : backgroundColor,\n        LcdColor : lcdColor,\n        ColorDef : color,\n        LedColor : ledColor,\n        GaugeType : gaugeType,\n        Orientation: orientation,\n        FrameDesign : frameDesign,\n        PointerType : pointerType,\n        ForegroundType : foregroundType,\n        KnobType : knobType,\n        KnobStyle: knobStyle,\n        LabelNumberFormat: labelNumberFormat,\n        TickLabelOrientation: tickLabelOrientation,\n        TrendState: trendState,\n\n        // Other\n        Section : section\n    };\n}());\nmodule.exports = steelseries;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/steelseries.js\n ** module id = 1\n ** module chunks = 0\n **/","function GaugeSet() {\n  this.speed = new steelseries.Radial('speedCanvas', {\n    gaugeType: steelseries.GaugeType.TYPE4,\n    frameDesign: steelseries.FrameDesign.TILTED_BLACK,\n    size: 400,\n    titleString: \"SOG\",\n    unitString: \"knots\",\n    lcdVisible: true,\n    maxValue: 10,\n    maxMeasuredValue: 0,\n    maxMeasuredValueVisible: true,\n    thresholdVisible: false,\n    ledVisible: false,\n    pointerType: steelseries.PointerType.TYPE4\n  });\n\n  this.depth = new steelseries.Radial('depthCanvas', {\n    gaugeType: steelseries.GaugeType.TYPE4,\n    frameDesign: steelseries.FrameDesign.TILTED_BLACK,\n    size: 400,\n    section: [\n      steelseries.Section(0, 4, 'rgba(255, 0, 0, 0.3)'),\n      steelseries.Section(4, 8, 'rgba(220, 220, 0, 0.3)')\n    ],\n    titleString: \"Depth\",\n    unitString: \"m\",\n    lcdVisible: true,\n    maxValue: 20,\n    maxMeasuredValue: 0,\n    maxMeasuredValueVisible: true,\n    thresholdVisible: false,\n    ledVisible: false,\n    pointerType: steelseries.PointerType.TYPE2\n  });\n\n  this.compass = new steelseries.Compass('compassCanvas', {\n    frameDesign: steelseries.FrameDesign.TILTED_BLACK,\n    size: 400,\n    rotateFace: true,\n    pointerType: steelseries.PointerType.TYPE5\n  });\n\n  this.wind = new steelseries.WindDirection('windCanvas', {\n    frameDesign: steelseries.FrameDesign.TILTED_BLACK,\n    size: 400,\n    lcdVisible: true,\n    degreeScaleHalf: true,\n    pointSymbolsVisible: false,\n    pointerType: steelseries.PointerType.TYPE5,\n  });\n\n\n  this.eventHandlers = {\n    \"navigation.speedOverGround\": function(value) {\n      if (value != null) {\n        this.speed.setValue(value);\n      }\n    }.bind(this),\n    \"navigation.courseOverGroundTrue\": function(value) {\n      this.compass.setValue(value);\n    }.bind(this),\n    \"environment.depth.belowTransducer\": function(value) {\n      this.depth.setValue(value);\n    }.bind(this),\n    \"environment.wind.angleApparent\": function(value) {\n      this.wind.setValueLatest(value);\n    }.bind(this)\n  }\n  this.dispatch = this.doDispatch.bind(this);\n};\n\nGaugeSet.prototype = {\n  doDispatch: function dispatch(delta) {\n    if (delta.context === 'vessels.' + this.selfId && delta.updates) {\n      var that  = this;\n      delta.updates.forEach(function(update) {\n        update.values.forEach(function(value) {\n          if (that.eventHandlers[value.path] && typeof that.eventHandlers[value.path] === 'function') {\n            that.eventHandlers[value.path](value.value);\n          }\n        })\n      })\n    }\n  },\n  zero: function() {\n    this.speed.setValue(0);\n    this.compass.setValue(0);\n    this.depth.setValue(0);\n    this.wind.setValueLatest(0);\n    this.wind.setValueAverage(0);\n  },\n  setSelfId: function(selfId) {\n    this.selfId = selfId;\n  }\n}\n\n\n\nmodule.exports.GaugeSet = GaugeSet;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/simplegauges.js\n ** module id = 2\n ** module chunks = 0\n **/","\n/**\n * Module dependencies.\n */\n\nvar global = (function() { return this; })();\n\n/**\n * WebSocket constructor.\n */\n\nvar WebSocket = global.WebSocket || global.MozWebSocket;\n\n/**\n * Module exports.\n */\n\nmodule.exports = WebSocket ? ws : null;\n\n/**\n * WebSocket constructor.\n *\n * The third `opts` options object gets ignored in web browsers, since it's\n * non-standard, and throws a TypeError if passed to the constructor.\n * See: https://github.com/einaros/ws/issues/227\n *\n * @param {String} uri\n * @param {Array} protocols (optional)\n * @param {Object) opts (optional)\n * @api public\n */\n\nfunction ws(uri, protocols, opts) {\n  var instance;\n  if (protocols) {\n    instance = new WebSocket(uri, protocols);\n  } else {\n    instance = new WebSocket(uri);\n  }\n  return instance;\n}\n\nif (WebSocket) ws.prototype = WebSocket.prototype;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ws/lib/browser.js\n ** module id = 3\n ** module chunks = 0\n **/","var EventEmitter = require('eventemitter3');\nvar WebSocket = require('ws');\nvar debug = require('debug')('signalk:client');\n\nvar Promise = require('bluebird');\nvar agent = require('superagent-promise')(require('superagent'), Promise);\n\n\nfunction Client(host, port) {\n  this.host = host;\n  this.port = port;\n}\n\n\nrequire('util').inherits(Client, EventEmitter);\n\n\nClient.prototype.get = function(path) {\n  return agent('GET', 'http://' + this.host + ':' + this.port + '/signalk/v1/api' + path).then(function(result) {\n    return result.res.body;\n  });\n}\n\nClient.prototype.connect = function(options) {\n  debug('connect');\n  var host = this.host;\n  var port = this.port;\n  if (options) {\n    host = options.host || host;\n    port = options.port || port;\n  }\n  if (host && port) {\n    return this.connectDelta(options.host + \":\" + options.port, options.onData, options.onConnect, options.onDisconnect, options.onError)\n  }\n  return this.discoverAndConnect(options);\n}\n\nClient.prototype.discoverAndConnect = function(options) {\n  debug('discoverAndConnect');\n  var that = this;\n  try {\n    var mdns = require('mdns');\n  } catch(ex) {\n    console.log(\"Discovery requires mdns, please install it with 'npm install mdns' or specify host and port\");\n    return\n  }\n  return new Promise(function(resolve, reject) {\n    var browser = mdns.createBrowser(mdns.tcp('signalk-ws'));\n    browser.on('serviceUp', function(service) {\n      debug(\"Discovered signalk-ws with txtRecord:\" + JSON.stringify(service.txtRecord, null, 2));\n      //TODO handle multiple discoveries\n      resolve(service);\n    });\n    debug(\"Starting mdns discovery\");\n    browser.start();\n  }).then(function(service) {\n    that.host = service.host;\n    that.port = service.port;\n    debug(\"Discovered \" + that.host + \":\" + that.port)\n    that.emit('discovery', service);\n    return that.connectDelta(service.host + \":\" + service.port, options.onData, options.onConnect, options.onDisconnect, options.onError);\n  });\n}\n\n\nClient.prototype.connectDelta = function(hostname, callback, onConnect, onDisconnect, onError) {\n  debug(\"Connecting to \" + hostname);\n  var url = \"ws://\" + hostname + \"/signalk/v1/stream?stream=delta&context=self\";\n  if (typeof Primus != 'undefined') {\n    debug(\"Using Primus\");\n    var signalKStream = Primus.connect(url, {\n      reconnect: {\n        maxDelay: 15000,\n        minDelay: 500,\n        retries: Infinity\n      }\n    });\n    signalKStream.on('data', callback);\n    return {\n      disconnect: function() {\n        signalKStream.destroy();\n        debug('Disconnected');\n      }\n    }\n  } else {\n    debug(\"Using ws\");\n    var connection = new WebSocket(url);\n    connection.onopen = function(msg) {\n      debug(\"open\");\n      if (onConnect) {\n        onConnect(connection)\n      } else {\n        var sub = '{\"context\":\"vessels.self\",\"subscribe\":[{\"path\":\"*\"}]}';\n        connection.send(sub);\n      }\n    };\n    connection.onerror = function(error) {\n      debug(\"error:\" + error);\n      if (onError) {\n        onError(error)\n      }\n    };\n    connection.onmessage = function(msg) {\n      callback(JSON.parse(msg.data));\n    };\n    return {\n      disconnect: function() {\n        connection.close();\n        debug('Disconnected');\n      }\n    }\n  }\n}\n\nClient.prototype.getSelf = function (host) {\n  return agent('GET', \"http://\" + (host || this.host + \":\" + this.port) + \"/signalk/v1/api/vessels/self\");\n}\n\nClient.prototype.getSelfMatcher = function(host) {\n  return this.getSelf(host || this.host + \":\" + this.port).then(function(result) {\n    var selfData = result.body;\n    var selfId = selfData.mmsi || selfData.uuid;\n    if (selfId) {\n      var selfContext = 'vessels.' + selfId;\n      return function(delta) {\n        return delta.context === 'self' || delta.context === 'vessels.self' || delta.context === selfContext;\n      }\n    } else {\n      return function(delta) {\n        return true;\n      }\n    }\n  });\n}\n\nfunction convertUpdateToHumanUnits(update) {\n  if (update.values) {\n    update.values.forEach(convertPathValueToHumanUnits)\n  }\n}\n\nfunction convertPathValueToHumanUnits(pathValue) {\n  if (signalkSchema.metadata[pathValue.path] && conversions[signalkSchema.metadata[pathValue.path].units]) {\n    pathValue.value = conversions[signalkSchema.metadata[pathValue.path].units].convert(pathValue.value);\n    pathValue.units = conversions[signalkSchema.metadata[pathValue.path].units].to;\n  }\n}\n\nfunction isDelta(msg) {\n  return typeof msg.context != \"undefined\"\n}\n\nfunction isHello(msg) {\n  return typeof msg.version != \"undefined\"\n}\n\nmodule.exports = {\n  Client: Client,\n  isDelta: isDelta,\n  isHello: isHello\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/signalk-client/index.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/signalk-client/~/eventemitter3/index.js\n ** module id = 5\n ** module chunks = 0\n **/","\n/**\n * Module dependencies.\n */\n\nvar global = (function() { return this; })();\n\n/**\n * WebSocket constructor.\n */\n\nvar WebSocket = global.WebSocket || global.MozWebSocket;\n\n/**\n * Module exports.\n */\n\nmodule.exports = WebSocket ? ws : null;\n\n/**\n * WebSocket constructor.\n *\n * The third `opts` options object gets ignored in web browsers, since it's\n * non-standard, and throws a TypeError if passed to the constructor.\n * See: https://github.com/einaros/ws/issues/227\n *\n * @param {String} uri\n * @param {Array} protocols (optional)\n * @param {Object) opts (optional)\n * @api public\n */\n\nfunction ws(uri, protocols, opts) {\n  var instance;\n  if (protocols) {\n    instance = new WebSocket(uri, protocols);\n  } else {\n    instance = new WebSocket(uri);\n  }\n  return instance;\n}\n\nif (WebSocket) ws.prototype = WebSocket.prototype;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/signalk-client/~/ws/lib/browser.js\n ** module id = 6\n ** module chunks = 0\n **/","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/signalk-client/~/debug/browser.js\n ** module id = 7\n ** module chunks = 0\n **/","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/signalk-client/~/debug/debug.js\n ** module id = 8\n ** module chunks = 0\n **/","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/signalk-client/~/debug/~/ms/index.js\n ** module id = 9\n ** module chunks = 0\n **/","/* @preserve\n * The MIT License (MIT)\n * \n * Copyright (c) 2013-2015 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n/**\n * bluebird build version 2.10.2\n * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, cancel, using, filter, any, each, timers\n*/\n!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_==\"function\"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_==\"function\"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise) {\nvar SomePromiseArray = Promise._SomePromiseArray;\nfunction any(promises) {\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(1);\n    ret.setUnwrap();\n    ret.init();\n    return promise;\n}\n\nPromise.any = function (promises) {\n    return any(promises);\n};\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n};\n\n},{}],2:[function(_dereq_,module,exports){\n\"use strict\";\nvar firstLineError;\ntry {throw new Error(); } catch (e) {firstLineError = e;}\nvar schedule = _dereq_(\"./schedule.js\");\nvar Queue = _dereq_(\"./queue.js\");\nvar util = _dereq_(\"./util.js\");\n\nfunction Async() {\n    this._isTickUsed = false;\n    this._lateQueue = new Queue(16);\n    this._normalQueue = new Queue(16);\n    this._trampolineEnabled = true;\n    var self = this;\n    this.drainQueues = function () {\n        self._drainQueues();\n    };\n    this._schedule =\n        schedule.isStatic ? schedule(this.drainQueues) : schedule;\n}\n\nAsync.prototype.disableTrampolineIfNecessary = function() {\n    if (util.hasDevTools) {\n        this._trampolineEnabled = false;\n    }\n};\n\nAsync.prototype.enableTrampoline = function() {\n    if (!this._trampolineEnabled) {\n        this._trampolineEnabled = true;\n        this._schedule = function(fn) {\n            setTimeout(fn, 0);\n        };\n    }\n};\n\nAsync.prototype.haveItemsQueued = function () {\n    return this._normalQueue.length() > 0;\n};\n\nAsync.prototype.throwLater = function(fn, arg) {\n    if (arguments.length === 1) {\n        arg = fn;\n        fn = function () { throw arg; };\n    }\n    if (typeof setTimeout !== \"undefined\") {\n        setTimeout(function() {\n            fn(arg);\n        }, 0);\n    } else try {\n        this._schedule(function() {\n            fn(arg);\n        });\n    } catch (e) {\n        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/m3OTXk\\u000a\");\n    }\n};\n\nfunction AsyncInvokeLater(fn, receiver, arg) {\n    this._lateQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncInvoke(fn, receiver, arg) {\n    this._normalQueue.push(fn, receiver, arg);\n    this._queueTick();\n}\n\nfunction AsyncSettlePromises(promise) {\n    this._normalQueue._pushOne(promise);\n    this._queueTick();\n}\n\nif (!util.hasDevTools) {\n    Async.prototype.invokeLater = AsyncInvokeLater;\n    Async.prototype.invoke = AsyncInvoke;\n    Async.prototype.settlePromises = AsyncSettlePromises;\n} else {\n    if (schedule.isStatic) {\n        schedule = function(fn) { setTimeout(fn, 0); };\n    }\n    Async.prototype.invokeLater = function (fn, receiver, arg) {\n        if (this._trampolineEnabled) {\n            AsyncInvokeLater.call(this, fn, receiver, arg);\n        } else {\n            this._schedule(function() {\n                setTimeout(function() {\n                    fn.call(receiver, arg);\n                }, 100);\n            });\n        }\n    };\n\n    Async.prototype.invoke = function (fn, receiver, arg) {\n        if (this._trampolineEnabled) {\n            AsyncInvoke.call(this, fn, receiver, arg);\n        } else {\n            this._schedule(function() {\n                fn.call(receiver, arg);\n            });\n        }\n    };\n\n    Async.prototype.settlePromises = function(promise) {\n        if (this._trampolineEnabled) {\n            AsyncSettlePromises.call(this, promise);\n        } else {\n            this._schedule(function() {\n                promise._settlePromises();\n            });\n        }\n    };\n}\n\nAsync.prototype.invokeFirst = function (fn, receiver, arg) {\n    this._normalQueue.unshift(fn, receiver, arg);\n    this._queueTick();\n};\n\nAsync.prototype._drainQueue = function(queue) {\n    while (queue.length() > 0) {\n        var fn = queue.shift();\n        if (typeof fn !== \"function\") {\n            fn._settlePromises();\n            continue;\n        }\n        var receiver = queue.shift();\n        var arg = queue.shift();\n        fn.call(receiver, arg);\n    }\n};\n\nAsync.prototype._drainQueues = function () {\n    this._drainQueue(this._normalQueue);\n    this._reset();\n    this._drainQueue(this._lateQueue);\n};\n\nAsync.prototype._queueTick = function () {\n    if (!this._isTickUsed) {\n        this._isTickUsed = true;\n        this._schedule(this.drainQueues);\n    }\n};\n\nAsync.prototype._reset = function () {\n    this._isTickUsed = false;\n};\n\nmodule.exports = new Async();\nmodule.exports.firstLineError = firstLineError;\n\n},{\"./queue.js\":28,\"./schedule.js\":31,\"./util.js\":38}],3:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise) {\nvar rejectThis = function(_, e) {\n    this._reject(e);\n};\n\nvar targetRejected = function(e, context) {\n    context.promiseRejectionQueued = true;\n    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n};\n\nvar bindingResolved = function(thisArg, context) {\n    if (this._isPending()) {\n        this._resolveCallback(context.target);\n    }\n};\n\nvar bindingRejected = function(e, context) {\n    if (!context.promiseRejectionQueued) this._reject(e);\n};\n\nPromise.prototype.bind = function (thisArg) {\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n    ret._propagateFrom(this, 1);\n    var target = this._target();\n\n    ret._setBoundTo(maybePromise);\n    if (maybePromise instanceof Promise) {\n        var context = {\n            promiseRejectionQueued: false,\n            promise: ret,\n            target: target,\n            bindingPromise: maybePromise\n        };\n        target._then(INTERNAL, targetRejected, ret._progress, ret, context);\n        maybePromise._then(\n            bindingResolved, bindingRejected, ret._progress, ret, context);\n    } else {\n        ret._resolveCallback(target);\n    }\n    return ret;\n};\n\nPromise.prototype._setBoundTo = function (obj) {\n    if (obj !== undefined) {\n        this._bitField = this._bitField | 131072;\n        this._boundTo = obj;\n    } else {\n        this._bitField = this._bitField & (~131072);\n    }\n};\n\nPromise.prototype._isBound = function () {\n    return (this._bitField & 131072) === 131072;\n};\n\nPromise.bind = function (thisArg, value) {\n    var maybePromise = tryConvertToPromise(thisArg);\n    var ret = new Promise(INTERNAL);\n\n    ret._setBoundTo(maybePromise);\n    if (maybePromise instanceof Promise) {\n        maybePromise._then(function() {\n            ret._resolveCallback(value);\n        }, ret._reject, ret._progress, ret, null);\n    } else {\n        ret._resolveCallback(value);\n    }\n    return ret;\n};\n};\n\n},{}],4:[function(_dereq_,module,exports){\n\"use strict\";\nvar old;\nif (typeof Promise !== \"undefined\") old = Promise;\nfunction noConflict() {\n    try { if (Promise === bluebird) Promise = old; }\n    catch (e) {}\n    return bluebird;\n}\nvar bluebird = _dereq_(\"./promise.js\")();\nbluebird.noConflict = noConflict;\nmodule.exports = bluebird;\n\n},{\"./promise.js\":23}],5:[function(_dereq_,module,exports){\n\"use strict\";\nvar cr = Object.create;\nif (cr) {\n    var callerCache = cr(null);\n    var getterCache = cr(null);\n    callerCache[\" size\"] = getterCache[\" size\"] = 0;\n}\n\nmodule.exports = function(Promise) {\nvar util = _dereq_(\"./util.js\");\nvar canEvaluate = util.canEvaluate;\nvar isIdentifier = util.isIdentifier;\n\nvar getMethodCaller;\nvar getGetter;\nif (!true) {\nvar makeMethodCaller = function (methodName) {\n    return new Function(\"ensureMethod\", \"                                    \\n\\\n        return function(obj) {                                               \\n\\\n            'use strict'                                                     \\n\\\n            var len = this.length;                                           \\n\\\n            ensureMethod(obj, 'methodName');                                 \\n\\\n            switch(len) {                                                    \\n\\\n                case 1: return obj.methodName(this[0]);                      \\n\\\n                case 2: return obj.methodName(this[0], this[1]);             \\n\\\n                case 3: return obj.methodName(this[0], this[1], this[2]);    \\n\\\n                case 0: return obj.methodName();                             \\n\\\n                default:                                                     \\n\\\n                    return obj.methodName.apply(obj, this);                  \\n\\\n            }                                                                \\n\\\n        };                                                                   \\n\\\n        \".replace(/methodName/g, methodName))(ensureMethod);\n};\n\nvar makeGetter = function (propertyName) {\n    return new Function(\"obj\", \"                                             \\n\\\n        'use strict';                                                        \\n\\\n        return obj.propertyName;                                             \\n\\\n        \".replace(\"propertyName\", propertyName));\n};\n\nvar getCompiled = function(name, compiler, cache) {\n    var ret = cache[name];\n    if (typeof ret !== \"function\") {\n        if (!isIdentifier(name)) {\n            return null;\n        }\n        ret = compiler(name);\n        cache[name] = ret;\n        cache[\" size\"]++;\n        if (cache[\" size\"] > 512) {\n            var keys = Object.keys(cache);\n            for (var i = 0; i < 256; ++i) delete cache[keys[i]];\n            cache[\" size\"] = keys.length - 256;\n        }\n    }\n    return ret;\n};\n\ngetMethodCaller = function(name) {\n    return getCompiled(name, makeMethodCaller, callerCache);\n};\n\ngetGetter = function(name) {\n    return getCompiled(name, makeGetter, getterCache);\n};\n}\n\nfunction ensureMethod(obj, methodName) {\n    var fn;\n    if (obj != null) fn = obj[methodName];\n    if (typeof fn !== \"function\") {\n        var message = \"Object \" + util.classString(obj) + \" has no method '\" +\n            util.toString(methodName) + \"'\";\n        throw new Promise.TypeError(message);\n    }\n    return fn;\n}\n\nfunction caller(obj) {\n    var methodName = this.pop();\n    var fn = ensureMethod(obj, methodName);\n    return fn.apply(obj, this);\n}\nPromise.prototype.call = function (methodName) {\n    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}\n    if (!true) {\n        if (canEvaluate) {\n            var maybeCaller = getMethodCaller(methodName);\n            if (maybeCaller !== null) {\n                return this._then(\n                    maybeCaller, undefined, undefined, args, undefined);\n            }\n        }\n    }\n    args.push(methodName);\n    return this._then(caller, undefined, undefined, args, undefined);\n};\n\nfunction namedGetter(obj) {\n    return obj[this];\n}\nfunction indexedGetter(obj) {\n    var index = +this;\n    if (index < 0) index = Math.max(0, index + obj.length);\n    return obj[index];\n}\nPromise.prototype.get = function (propertyName) {\n    var isIndex = (typeof propertyName === \"number\");\n    var getter;\n    if (!isIndex) {\n        if (canEvaluate) {\n            var maybeGetter = getGetter(propertyName);\n            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n        } else {\n            getter = namedGetter;\n        }\n    } else {\n        getter = indexedGetter;\n    }\n    return this._then(getter, undefined, undefined, propertyName, undefined);\n};\n};\n\n},{\"./util.js\":38}],6:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise) {\nvar errors = _dereq_(\"./errors.js\");\nvar async = _dereq_(\"./async.js\");\nvar CancellationError = errors.CancellationError;\n\nPromise.prototype._cancel = function (reason) {\n    if (!this.isCancellable()) return this;\n    var parent;\n    var promiseToReject = this;\n    while ((parent = promiseToReject._cancellationParent) !== undefined &&\n        parent.isCancellable()) {\n        promiseToReject = parent;\n    }\n    this._unsetCancellable();\n    promiseToReject._target()._rejectCallback(reason, false, true);\n};\n\nPromise.prototype.cancel = function (reason) {\n    if (!this.isCancellable()) return this;\n    if (reason === undefined) reason = new CancellationError();\n    async.invokeLater(this._cancel, this, reason);\n    return this;\n};\n\nPromise.prototype.cancellable = function () {\n    if (this._cancellable()) return this;\n    async.enableTrampoline();\n    this._setCancellable();\n    this._cancellationParent = undefined;\n    return this;\n};\n\nPromise.prototype.uncancellable = function () {\n    var ret = this.then();\n    ret._unsetCancellable();\n    return ret;\n};\n\nPromise.prototype.fork = function (didFulfill, didReject, didProgress) {\n    var ret = this._then(didFulfill, didReject, didProgress,\n                         undefined, undefined);\n\n    ret._setCancellable();\n    ret._cancellationParent = undefined;\n    return ret;\n};\n};\n\n},{\"./async.js\":2,\"./errors.js\":13}],7:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function() {\nvar async = _dereq_(\"./async.js\");\nvar util = _dereq_(\"./util.js\");\nvar bluebirdFramePattern =\n    /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](main|debug|zalgo|instrumented)/;\nvar stackFramePattern = null;\nvar formatStack = null;\nvar indentStackFrames = false;\nvar warn;\n\nfunction CapturedTrace(parent) {\n    this._parent = parent;\n    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n    captureStackTrace(this, CapturedTrace);\n    if (length > 32) this.uncycle();\n}\nutil.inherits(CapturedTrace, Error);\n\nCapturedTrace.prototype.uncycle = function() {\n    var length = this._length;\n    if (length < 2) return;\n    var nodes = [];\n    var stackToIndex = {};\n\n    for (var i = 0, node = this; node !== undefined; ++i) {\n        nodes.push(node);\n        node = node._parent;\n    }\n    length = this._length = i;\n    for (var i = length - 1; i >= 0; --i) {\n        var stack = nodes[i].stack;\n        if (stackToIndex[stack] === undefined) {\n            stackToIndex[stack] = i;\n        }\n    }\n    for (var i = 0; i < length; ++i) {\n        var currentStack = nodes[i].stack;\n        var index = stackToIndex[currentStack];\n        if (index !== undefined && index !== i) {\n            if (index > 0) {\n                nodes[index - 1]._parent = undefined;\n                nodes[index - 1]._length = 1;\n            }\n            nodes[i]._parent = undefined;\n            nodes[i]._length = 1;\n            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\n            if (index < length - 1) {\n                cycleEdgeNode._parent = nodes[index + 1];\n                cycleEdgeNode._parent.uncycle();\n                cycleEdgeNode._length =\n                    cycleEdgeNode._parent._length + 1;\n            } else {\n                cycleEdgeNode._parent = undefined;\n                cycleEdgeNode._length = 1;\n            }\n            var currentChildLength = cycleEdgeNode._length + 1;\n            for (var j = i - 2; j >= 0; --j) {\n                nodes[j]._length = currentChildLength;\n                currentChildLength++;\n            }\n            return;\n        }\n    }\n};\n\nCapturedTrace.prototype.parent = function() {\n    return this._parent;\n};\n\nCapturedTrace.prototype.hasParent = function() {\n    return this._parent !== undefined;\n};\n\nCapturedTrace.prototype.attachExtraTrace = function(error) {\n    if (error.__stackCleaned__) return;\n    this.uncycle();\n    var parsed = CapturedTrace.parseStackAndMessage(error);\n    var message = parsed.message;\n    var stacks = [parsed.stack];\n\n    var trace = this;\n    while (trace !== undefined) {\n        stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n        trace = trace._parent;\n    }\n    removeCommonRoots(stacks);\n    removeDuplicateOrEmptyJumps(stacks);\n    util.notEnumerableProp(error, \"stack\", reconstructStack(message, stacks));\n    util.notEnumerableProp(error, \"__stackCleaned__\", true);\n};\n\nfunction reconstructStack(message, stacks) {\n    for (var i = 0; i < stacks.length - 1; ++i) {\n        stacks[i].push(\"From previous event:\");\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    if (i < stacks.length) {\n        stacks[i] = stacks[i].join(\"\\n\");\n    }\n    return message + \"\\n\" + stacks.join(\"\\n\");\n}\n\nfunction removeDuplicateOrEmptyJumps(stacks) {\n    for (var i = 0; i < stacks.length; ++i) {\n        if (stacks[i].length === 0 ||\n            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {\n            stacks.splice(i, 1);\n            i--;\n        }\n    }\n}\n\nfunction removeCommonRoots(stacks) {\n    var current = stacks[0];\n    for (var i = 1; i < stacks.length; ++i) {\n        var prev = stacks[i];\n        var currentLastIndex = current.length - 1;\n        var currentLastLine = current[currentLastIndex];\n        var commonRootMeetPoint = -1;\n\n        for (var j = prev.length - 1; j >= 0; --j) {\n            if (prev[j] === currentLastLine) {\n                commonRootMeetPoint = j;\n                break;\n            }\n        }\n\n        for (var j = commonRootMeetPoint; j >= 0; --j) {\n            var line = prev[j];\n            if (current[currentLastIndex] === line) {\n                current.pop();\n                currentLastIndex--;\n            } else {\n                break;\n            }\n        }\n        current = prev;\n    }\n}\n\nfunction cleanStack(stack) {\n    var ret = [];\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        var isTraceLine = stackFramePattern.test(line) ||\n            \"    (No stack trace)\" === line;\n        var isInternalFrame = isTraceLine && shouldIgnore(line);\n        if (isTraceLine && !isInternalFrame) {\n            if (indentStackFrames && line.charAt(0) !== \" \") {\n                line = \"    \" + line;\n            }\n            ret.push(line);\n        }\n    }\n    return ret;\n}\n\nfunction stackFramesAsArray(error) {\n    var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n    for (var i = 0; i < stack.length; ++i) {\n        var line = stack[i];\n        if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n            break;\n        }\n    }\n    if (i > 0) {\n        stack = stack.slice(i);\n    }\n    return stack;\n}\n\nCapturedTrace.parseStackAndMessage = function(error) {\n    var stack = error.stack;\n    var message = error.toString();\n    stack = typeof stack === \"string\" && stack.length > 0\n                ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n    return {\n        message: message,\n        stack: cleanStack(stack)\n    };\n};\n\nCapturedTrace.formatAndLogError = function(error, title) {\n    if (typeof console !== \"undefined\") {\n        var message;\n        if (typeof error === \"object\" || typeof error === \"function\") {\n            var stack = error.stack;\n            message = title + formatStack(stack, error);\n        } else {\n            message = title + String(error);\n        }\n        if (typeof warn === \"function\") {\n            warn(message);\n        } else if (typeof console.log === \"function\" ||\n            typeof console.log === \"object\") {\n            console.log(message);\n        }\n    }\n};\n\nCapturedTrace.unhandledRejection = function (reason) {\n    CapturedTrace.formatAndLogError(reason, \"^--- With additional stack trace: \");\n};\n\nCapturedTrace.isSupported = function () {\n    return typeof captureStackTrace === \"function\";\n};\n\nCapturedTrace.fireRejectionEvent =\nfunction(name, localHandler, reason, promise) {\n    var localEventFired = false;\n    try {\n        if (typeof localHandler === \"function\") {\n            localEventFired = true;\n            if (name === \"rejectionHandled\") {\n                localHandler(promise);\n            } else {\n                localHandler(reason, promise);\n            }\n        }\n    } catch (e) {\n        async.throwLater(e);\n    }\n\n    var globalEventFired = false;\n    try {\n        globalEventFired = fireGlobalEvent(name, reason, promise);\n    } catch (e) {\n        globalEventFired = true;\n        async.throwLater(e);\n    }\n\n    var domEventFired = false;\n    if (fireDomEvent) {\n        try {\n            domEventFired = fireDomEvent(name.toLowerCase(), {\n                reason: reason,\n                promise: promise\n            });\n        } catch (e) {\n            domEventFired = true;\n            async.throwLater(e);\n        }\n    }\n\n    if (!globalEventFired && !localEventFired && !domEventFired &&\n        name === \"unhandledRejection\") {\n        CapturedTrace.formatAndLogError(reason, \"Unhandled rejection \");\n    }\n};\n\nfunction formatNonError(obj) {\n    var str;\n    if (typeof obj === \"function\") {\n        str = \"[function \" +\n            (obj.name || \"anonymous\") +\n            \"]\";\n    } else {\n        str = obj.toString();\n        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n        if (ruselessToString.test(str)) {\n            try {\n                var newStr = JSON.stringify(obj);\n                str = newStr;\n            }\n            catch(e) {\n\n            }\n        }\n        if (str.length === 0) {\n            str = \"(empty array)\";\n        }\n    }\n    return (\"(<\" + snip(str) + \">, no stack trace)\");\n}\n\nfunction snip(str) {\n    var maxChars = 41;\n    if (str.length < maxChars) {\n        return str;\n    }\n    return str.substr(0, maxChars - 3) + \"...\";\n}\n\nvar shouldIgnore = function() { return false; };\nvar parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\nfunction parseLineInfo(line) {\n    var matches = line.match(parseLineInfoRegex);\n    if (matches) {\n        return {\n            fileName: matches[1],\n            line: parseInt(matches[2], 10)\n        };\n    }\n}\nCapturedTrace.setBounds = function(firstLineError, lastLineError) {\n    if (!CapturedTrace.isSupported()) return;\n    var firstStackLines = firstLineError.stack.split(\"\\n\");\n    var lastStackLines = lastLineError.stack.split(\"\\n\");\n    var firstIndex = -1;\n    var lastIndex = -1;\n    var firstFileName;\n    var lastFileName;\n    for (var i = 0; i < firstStackLines.length; ++i) {\n        var result = parseLineInfo(firstStackLines[i]);\n        if (result) {\n            firstFileName = result.fileName;\n            firstIndex = result.line;\n            break;\n        }\n    }\n    for (var i = 0; i < lastStackLines.length; ++i) {\n        var result = parseLineInfo(lastStackLines[i]);\n        if (result) {\n            lastFileName = result.fileName;\n            lastIndex = result.line;\n            break;\n        }\n    }\n    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||\n        firstFileName !== lastFileName || firstIndex >= lastIndex) {\n        return;\n    }\n\n    shouldIgnore = function(line) {\n        if (bluebirdFramePattern.test(line)) return true;\n        var info = parseLineInfo(line);\n        if (info) {\n            if (info.fileName === firstFileName &&\n                (firstIndex <= info.line && info.line <= lastIndex)) {\n                return true;\n            }\n        }\n        return false;\n    };\n};\n\nvar captureStackTrace = (function stackDetection() {\n    var v8stackFramePattern = /^\\s*at\\s*/;\n    var v8stackFormatter = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if (error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    if (typeof Error.stackTraceLimit === \"number\" &&\n        typeof Error.captureStackTrace === \"function\") {\n        Error.stackTraceLimit = Error.stackTraceLimit + 6;\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        var captureStackTrace = Error.captureStackTrace;\n\n        shouldIgnore = function(line) {\n            return bluebirdFramePattern.test(line);\n        };\n        return function(receiver, ignoreUntil) {\n            Error.stackTraceLimit = Error.stackTraceLimit + 6;\n            captureStackTrace(receiver, ignoreUntil);\n            Error.stackTraceLimit = Error.stackTraceLimit - 6;\n        };\n    }\n    var err = new Error();\n\n    if (typeof err.stack === \"string\" &&\n        err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n        stackFramePattern = /@/;\n        formatStack = v8stackFormatter;\n        indentStackFrames = true;\n        return function captureStackTrace(o) {\n            o.stack = new Error().stack;\n        };\n    }\n\n    var hasStackAfterThrow;\n    try { throw new Error(); }\n    catch(e) {\n        hasStackAfterThrow = (\"stack\" in e);\n    }\n    if (!(\"stack\" in err) && hasStackAfterThrow &&\n        typeof Error.stackTraceLimit === \"number\") {\n        stackFramePattern = v8stackFramePattern;\n        formatStack = v8stackFormatter;\n        return function captureStackTrace(o) {\n            Error.stackTraceLimit = Error.stackTraceLimit + 6;\n            try { throw new Error(); }\n            catch(e) { o.stack = e.stack; }\n            Error.stackTraceLimit = Error.stackTraceLimit - 6;\n        };\n    }\n\n    formatStack = function(stack, error) {\n        if (typeof stack === \"string\") return stack;\n\n        if ((typeof error === \"object\" ||\n            typeof error === \"function\") &&\n            error.name !== undefined &&\n            error.message !== undefined) {\n            return error.toString();\n        }\n        return formatNonError(error);\n    };\n\n    return null;\n\n})([]);\n\nvar fireDomEvent;\nvar fireGlobalEvent = (function() {\n    if (util.isNode) {\n        return function(name, reason, promise) {\n            if (name === \"rejectionHandled\") {\n                return process.emit(name, promise);\n            } else {\n                return process.emit(name, reason, promise);\n            }\n        };\n    } else {\n        var customEventWorks = false;\n        var anyEventWorks = true;\n        try {\n            var ev = new self.CustomEvent(\"test\");\n            customEventWorks = ev instanceof CustomEvent;\n        } catch (e) {}\n        if (!customEventWorks) {\n            try {\n                var event = document.createEvent(\"CustomEvent\");\n                event.initCustomEvent(\"testingtheevent\", false, true, {});\n                self.dispatchEvent(event);\n            } catch (e) {\n                anyEventWorks = false;\n            }\n        }\n        if (anyEventWorks) {\n            fireDomEvent = function(type, detail) {\n                var event;\n                if (customEventWorks) {\n                    event = new self.CustomEvent(type, {\n                        detail: detail,\n                        bubbles: false,\n                        cancelable: true\n                    });\n                } else if (self.dispatchEvent) {\n                    event = document.createEvent(\"CustomEvent\");\n                    event.initCustomEvent(type, false, true, detail);\n                }\n\n                return event ? !self.dispatchEvent(event) : false;\n            };\n        }\n\n        var toWindowMethodNameMap = {};\n        toWindowMethodNameMap[\"unhandledRejection\"] = (\"on\" +\n            \"unhandledRejection\").toLowerCase();\n        toWindowMethodNameMap[\"rejectionHandled\"] = (\"on\" +\n            \"rejectionHandled\").toLowerCase();\n\n        return function(name, reason, promise) {\n            var methodName = toWindowMethodNameMap[name];\n            var method = self[methodName];\n            if (!method) return false;\n            if (name === \"rejectionHandled\") {\n                method.call(self, promise);\n            } else {\n                method.call(self, reason, promise);\n            }\n            return true;\n        };\n    }\n})();\n\nif (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n    warn = function (message) {\n        console.warn(message);\n    };\n    if (util.isNode && process.stderr.isTTY) {\n        warn = function(message) {\n            process.stderr.write(\"\\u001b[31m\" + message + \"\\u001b[39m\\n\");\n        };\n    } else if (!util.isNode && typeof (new Error().stack) === \"string\") {\n        warn = function(message) {\n            console.warn(\"%c\" + message, \"color: red\");\n        };\n    }\n}\n\nreturn CapturedTrace;\n};\n\n},{\"./async.js\":2,\"./util.js\":38}],8:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(NEXT_FILTER) {\nvar util = _dereq_(\"./util.js\");\nvar errors = _dereq_(\"./errors.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar keys = _dereq_(\"./es5.js\").keys;\nvar TypeError = errors.TypeError;\n\nfunction CatchFilter(instances, callback, promise) {\n    this._instances = instances;\n    this._callback = callback;\n    this._promise = promise;\n}\n\nfunction safePredicate(predicate, e) {\n    var safeObject = {};\n    var retfilter = tryCatch(predicate).call(safeObject, e);\n\n    if (retfilter === errorObj) return retfilter;\n\n    var safeKeys = keys(safeObject);\n    if (safeKeys.length) {\n        errorObj.e = new TypeError(\"Catch filter must inherit from Error or be a simple predicate function\\u000a\\u000a    See http://goo.gl/o84o68\\u000a\");\n        return errorObj;\n    }\n    return retfilter;\n}\n\nCatchFilter.prototype.doFilter = function (e) {\n    var cb = this._callback;\n    var promise = this._promise;\n    var boundTo = promise._boundValue();\n    for (var i = 0, len = this._instances.length; i < len; ++i) {\n        var item = this._instances[i];\n        var itemIsErrorType = item === Error ||\n            (item != null && item.prototype instanceof Error);\n\n        if (itemIsErrorType && e instanceof item) {\n            var ret = tryCatch(cb).call(boundTo, e);\n            if (ret === errorObj) {\n                NEXT_FILTER.e = ret.e;\n                return NEXT_FILTER;\n            }\n            return ret;\n        } else if (typeof item === \"function\" && !itemIsErrorType) {\n            var shouldHandle = safePredicate(item, e);\n            if (shouldHandle === errorObj) {\n                e = errorObj.e;\n                break;\n            } else if (shouldHandle) {\n                var ret = tryCatch(cb).call(boundTo, e);\n                if (ret === errorObj) {\n                    NEXT_FILTER.e = ret.e;\n                    return NEXT_FILTER;\n                }\n                return ret;\n            }\n        }\n    }\n    NEXT_FILTER.e = e;\n    return NEXT_FILTER;\n};\n\nreturn CatchFilter;\n};\n\n},{\"./errors.js\":13,\"./es5.js\":14,\"./util.js\":38}],9:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, CapturedTrace, isDebugging) {\nvar contextStack = [];\nfunction Context() {\n    this._trace = new CapturedTrace(peekContext());\n}\nContext.prototype._pushContext = function () {\n    if (!isDebugging()) return;\n    if (this._trace !== undefined) {\n        contextStack.push(this._trace);\n    }\n};\n\nContext.prototype._popContext = function () {\n    if (!isDebugging()) return;\n    if (this._trace !== undefined) {\n        contextStack.pop();\n    }\n};\n\nfunction createContext() {\n    if (isDebugging()) return new Context();\n}\n\nfunction peekContext() {\n    var lastIndex = contextStack.length - 1;\n    if (lastIndex >= 0) {\n        return contextStack[lastIndex];\n    }\n    return undefined;\n}\n\nPromise.prototype._peekContext = peekContext;\nPromise.prototype._pushContext = Context.prototype._pushContext;\nPromise.prototype._popContext = Context.prototype._popContext;\n\nreturn createContext;\n};\n\n},{}],10:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, CapturedTrace) {\nvar getDomain = Promise._getDomain;\nvar async = _dereq_(\"./async.js\");\nvar Warning = _dereq_(\"./errors.js\").Warning;\nvar util = _dereq_(\"./util.js\");\nvar canAttachTrace = util.canAttachTrace;\nvar unhandledRejectionHandled;\nvar possiblyUnhandledRejection;\nvar debugging = false || (util.isNode &&\n                    (!!process.env[\"BLUEBIRD_DEBUG\"] ||\n                     process.env[\"NODE_ENV\"] === \"development\"));\n\nif (util.isNode && process.env[\"BLUEBIRD_DEBUG\"] == 0) debugging = false;\n\nif (debugging) {\n    async.disableTrampolineIfNecessary();\n}\n\nPromise.prototype._ignoreRejections = function() {\n    this._unsetRejectionIsUnhandled();\n    this._bitField = this._bitField | 16777216;\n};\n\nPromise.prototype._ensurePossibleRejectionHandled = function () {\n    if ((this._bitField & 16777216) !== 0) return;\n    this._setRejectionIsUnhandled();\n    async.invokeLater(this._notifyUnhandledRejection, this, undefined);\n};\n\nPromise.prototype._notifyUnhandledRejectionIsHandled = function () {\n    CapturedTrace.fireRejectionEvent(\"rejectionHandled\",\n                                  unhandledRejectionHandled, undefined, this);\n};\n\nPromise.prototype._notifyUnhandledRejection = function () {\n    if (this._isRejectionUnhandled()) {\n        var reason = this._getCarriedStackTrace() || this._settledValue;\n        this._setUnhandledRejectionIsNotified();\n        CapturedTrace.fireRejectionEvent(\"unhandledRejection\",\n                                      possiblyUnhandledRejection, reason, this);\n    }\n};\n\nPromise.prototype._setUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField | 524288;\n};\n\nPromise.prototype._unsetUnhandledRejectionIsNotified = function () {\n    this._bitField = this._bitField & (~524288);\n};\n\nPromise.prototype._isUnhandledRejectionNotified = function () {\n    return (this._bitField & 524288) > 0;\n};\n\nPromise.prototype._setRejectionIsUnhandled = function () {\n    this._bitField = this._bitField | 2097152;\n};\n\nPromise.prototype._unsetRejectionIsUnhandled = function () {\n    this._bitField = this._bitField & (~2097152);\n    if (this._isUnhandledRejectionNotified()) {\n        this._unsetUnhandledRejectionIsNotified();\n        this._notifyUnhandledRejectionIsHandled();\n    }\n};\n\nPromise.prototype._isRejectionUnhandled = function () {\n    return (this._bitField & 2097152) > 0;\n};\n\nPromise.prototype._setCarriedStackTrace = function (capturedTrace) {\n    this._bitField = this._bitField | 1048576;\n    this._fulfillmentHandler0 = capturedTrace;\n};\n\nPromise.prototype._isCarryingStackTrace = function () {\n    return (this._bitField & 1048576) > 0;\n};\n\nPromise.prototype._getCarriedStackTrace = function () {\n    return this._isCarryingStackTrace()\n        ? this._fulfillmentHandler0\n        : undefined;\n};\n\nPromise.prototype._captureStackTrace = function () {\n    if (debugging) {\n        this._trace = new CapturedTrace(this._peekContext());\n    }\n    return this;\n};\n\nPromise.prototype._attachExtraTrace = function (error, ignoreSelf) {\n    if (debugging && canAttachTrace(error)) {\n        var trace = this._trace;\n        if (trace !== undefined) {\n            if (ignoreSelf) trace = trace._parent;\n        }\n        if (trace !== undefined) {\n            trace.attachExtraTrace(error);\n        } else if (!error.__stackCleaned__) {\n            var parsed = CapturedTrace.parseStackAndMessage(error);\n            util.notEnumerableProp(error, \"stack\",\n                parsed.message + \"\\n\" + parsed.stack.join(\"\\n\"));\n            util.notEnumerableProp(error, \"__stackCleaned__\", true);\n        }\n    }\n};\n\nPromise.prototype._warn = function(message) {\n    var warning = new Warning(message);\n    var ctx = this._peekContext();\n    if (ctx) {\n        ctx.attachExtraTrace(warning);\n    } else {\n        var parsed = CapturedTrace.parseStackAndMessage(warning);\n        warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n    }\n    CapturedTrace.formatAndLogError(warning, \"\");\n};\n\nPromise.onPossiblyUnhandledRejection = function (fn) {\n    var domain = getDomain();\n    possiblyUnhandledRejection =\n        typeof fn === \"function\" ? (domain === null ? fn : domain.bind(fn))\n                                 : undefined;\n};\n\nPromise.onUnhandledRejectionHandled = function (fn) {\n    var domain = getDomain();\n    unhandledRejectionHandled =\n        typeof fn === \"function\" ? (domain === null ? fn : domain.bind(fn))\n                                 : undefined;\n};\n\nPromise.longStackTraces = function () {\n    if (async.haveItemsQueued() &&\n        debugging === false\n   ) {\n        throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/DT1qyG\\u000a\");\n    }\n    debugging = CapturedTrace.isSupported();\n    if (debugging) {\n        async.disableTrampolineIfNecessary();\n    }\n};\n\nPromise.hasLongStackTraces = function () {\n    return debugging && CapturedTrace.isSupported();\n};\n\nif (!CapturedTrace.isSupported()) {\n    Promise.longStackTraces = function(){};\n    debugging = false;\n}\n\nreturn function() {\n    return debugging;\n};\n};\n\n},{\"./async.js\":2,\"./errors.js\":13,\"./util.js\":38}],11:[function(_dereq_,module,exports){\n\"use strict\";\nvar util = _dereq_(\"./util.js\");\nvar isPrimitive = util.isPrimitive;\n\nmodule.exports = function(Promise) {\nvar returner = function () {\n    return this;\n};\nvar thrower = function () {\n    throw this;\n};\nvar returnUndefined = function() {};\nvar throwUndefined = function() {\n    throw undefined;\n};\n\nvar wrapper = function (value, action) {\n    if (action === 1) {\n        return function () {\n            throw value;\n        };\n    } else if (action === 2) {\n        return function () {\n            return value;\n        };\n    }\n};\n\n\nPromise.prototype[\"return\"] =\nPromise.prototype.thenReturn = function (value) {\n    if (value === undefined) return this.then(returnUndefined);\n\n    if (isPrimitive(value)) {\n        return this._then(\n            wrapper(value, 2),\n            undefined,\n            undefined,\n            undefined,\n            undefined\n       );\n    } else if (value instanceof Promise) {\n        value._ignoreRejections();\n    }\n    return this._then(returner, undefined, undefined, value, undefined);\n};\n\nPromise.prototype[\"throw\"] =\nPromise.prototype.thenThrow = function (reason) {\n    if (reason === undefined) return this.then(throwUndefined);\n\n    if (isPrimitive(reason)) {\n        return this._then(\n            wrapper(reason, 1),\n            undefined,\n            undefined,\n            undefined,\n            undefined\n       );\n    }\n    return this._then(thrower, undefined, undefined, reason, undefined);\n};\n};\n\n},{\"./util.js\":38}],12:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseReduce = Promise.reduce;\n\nPromise.prototype.each = function (fn) {\n    return PromiseReduce(this, fn, null, INTERNAL);\n};\n\nPromise.each = function (promises, fn) {\n    return PromiseReduce(promises, fn, null, INTERNAL);\n};\n};\n\n},{}],13:[function(_dereq_,module,exports){\n\"use strict\";\nvar es5 = _dereq_(\"./es5.js\");\nvar Objectfreeze = es5.freeze;\nvar util = _dereq_(\"./util.js\");\nvar inherits = util.inherits;\nvar notEnumerableProp = util.notEnumerableProp;\n\nfunction subError(nameProperty, defaultMessage) {\n    function SubError(message) {\n        if (!(this instanceof SubError)) return new SubError(message);\n        notEnumerableProp(this, \"message\",\n            typeof message === \"string\" ? message : defaultMessage);\n        notEnumerableProp(this, \"name\", nameProperty);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            Error.call(this);\n        }\n    }\n    inherits(SubError, Error);\n    return SubError;\n}\n\nvar _TypeError, _RangeError;\nvar Warning = subError(\"Warning\", \"warning\");\nvar CancellationError = subError(\"CancellationError\", \"cancellation error\");\nvar TimeoutError = subError(\"TimeoutError\", \"timeout error\");\nvar AggregateError = subError(\"AggregateError\", \"aggregate error\");\ntry {\n    _TypeError = TypeError;\n    _RangeError = RangeError;\n} catch(e) {\n    _TypeError = subError(\"TypeError\", \"type error\");\n    _RangeError = subError(\"RangeError\", \"range error\");\n}\n\nvar methods = (\"join pop push shift unshift slice filter forEach some \" +\n    \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\nfor (var i = 0; i < methods.length; ++i) {\n    if (typeof Array.prototype[methods[i]] === \"function\") {\n        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n    }\n}\n\nes5.defineProperty(AggregateError.prototype, \"length\", {\n    value: 0,\n    configurable: false,\n    writable: true,\n    enumerable: true\n});\nAggregateError.prototype[\"isOperational\"] = true;\nvar level = 0;\nAggregateError.prototype.toString = function() {\n    var indent = Array(level * 4 + 1).join(\" \");\n    var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n    level++;\n    indent = Array(level * 4 + 1).join(\" \");\n    for (var i = 0; i < this.length; ++i) {\n        var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n        var lines = str.split(\"\\n\");\n        for (var j = 0; j < lines.length; ++j) {\n            lines[j] = indent + lines[j];\n        }\n        str = lines.join(\"\\n\");\n        ret += str + \"\\n\";\n    }\n    level--;\n    return ret;\n};\n\nfunction OperationalError(message) {\n    if (!(this instanceof OperationalError))\n        return new OperationalError(message);\n    notEnumerableProp(this, \"name\", \"OperationalError\");\n    notEnumerableProp(this, \"message\", message);\n    this.cause = message;\n    this[\"isOperational\"] = true;\n\n    if (message instanceof Error) {\n        notEnumerableProp(this, \"message\", message.message);\n        notEnumerableProp(this, \"stack\", message.stack);\n    } else if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n    }\n\n}\ninherits(OperationalError, Error);\n\nvar errorTypes = Error[\"__BluebirdErrorTypes__\"];\nif (!errorTypes) {\n    errorTypes = Objectfreeze({\n        CancellationError: CancellationError,\n        TimeoutError: TimeoutError,\n        OperationalError: OperationalError,\n        RejectionError: OperationalError,\n        AggregateError: AggregateError\n    });\n    notEnumerableProp(Error, \"__BluebirdErrorTypes__\", errorTypes);\n}\n\nmodule.exports = {\n    Error: Error,\n    TypeError: _TypeError,\n    RangeError: _RangeError,\n    CancellationError: errorTypes.CancellationError,\n    OperationalError: errorTypes.OperationalError,\n    TimeoutError: errorTypes.TimeoutError,\n    AggregateError: errorTypes.AggregateError,\n    Warning: Warning\n};\n\n},{\"./es5.js\":14,\"./util.js\":38}],14:[function(_dereq_,module,exports){\nvar isES5 = (function(){\n    \"use strict\";\n    return this === undefined;\n})();\n\nif (isES5) {\n    module.exports = {\n        freeze: Object.freeze,\n        defineProperty: Object.defineProperty,\n        getDescriptor: Object.getOwnPropertyDescriptor,\n        keys: Object.keys,\n        names: Object.getOwnPropertyNames,\n        getPrototypeOf: Object.getPrototypeOf,\n        isArray: Array.isArray,\n        isES5: isES5,\n        propertyIsWritable: function(obj, prop) {\n            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n            return !!(!descriptor || descriptor.writable || descriptor.set);\n        }\n    };\n} else {\n    var has = {}.hasOwnProperty;\n    var str = {}.toString;\n    var proto = {}.constructor.prototype;\n\n    var ObjectKeys = function (o) {\n        var ret = [];\n        for (var key in o) {\n            if (has.call(o, key)) {\n                ret.push(key);\n            }\n        }\n        return ret;\n    };\n\n    var ObjectGetDescriptor = function(o, key) {\n        return {value: o[key]};\n    };\n\n    var ObjectDefineProperty = function (o, key, desc) {\n        o[key] = desc.value;\n        return o;\n    };\n\n    var ObjectFreeze = function (obj) {\n        return obj;\n    };\n\n    var ObjectGetPrototypeOf = function (obj) {\n        try {\n            return Object(obj).constructor.prototype;\n        }\n        catch (e) {\n            return proto;\n        }\n    };\n\n    var ArrayIsArray = function (obj) {\n        try {\n            return str.call(obj) === \"[object Array]\";\n        }\n        catch(e) {\n            return false;\n        }\n    };\n\n    module.exports = {\n        isArray: ArrayIsArray,\n        keys: ObjectKeys,\n        names: ObjectKeys,\n        defineProperty: ObjectDefineProperty,\n        getDescriptor: ObjectGetDescriptor,\n        freeze: ObjectFreeze,\n        getPrototypeOf: ObjectGetPrototypeOf,\n        isES5: isES5,\n        propertyIsWritable: function() {\n            return true;\n        }\n    };\n}\n\n},{}],15:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseMap = Promise.map;\n\nPromise.prototype.filter = function (fn, options) {\n    return PromiseMap(this, fn, options, INTERNAL);\n};\n\nPromise.filter = function (promises, fn, options) {\n    return PromiseMap(promises, fn, options, INTERNAL);\n};\n};\n\n},{}],16:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {\nvar util = _dereq_(\"./util.js\");\nvar isPrimitive = util.isPrimitive;\nvar thrower = util.thrower;\n\nfunction returnThis() {\n    return this;\n}\nfunction throwThis() {\n    throw this;\n}\nfunction return$(r) {\n    return function() {\n        return r;\n    };\n}\nfunction throw$(r) {\n    return function() {\n        throw r;\n    };\n}\nfunction promisedFinally(ret, reasonOrValue, isFulfilled) {\n    var then;\n    if (isPrimitive(reasonOrValue)) {\n        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);\n    } else {\n        then = isFulfilled ? returnThis : throwThis;\n    }\n    return ret._then(then, thrower, undefined, reasonOrValue, undefined);\n}\n\nfunction finallyHandler(reasonOrValue) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    var ret = promise._isBound()\n                    ? handler.call(promise._boundValue())\n                    : handler();\n\n    if (ret !== undefined) {\n        var maybePromise = tryConvertToPromise(ret, promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            return promisedFinally(maybePromise, reasonOrValue,\n                                    promise.isFulfilled());\n        }\n    }\n\n    if (promise.isRejected()) {\n        NEXT_FILTER.e = reasonOrValue;\n        return NEXT_FILTER;\n    } else {\n        return reasonOrValue;\n    }\n}\n\nfunction tapHandler(value) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    var ret = promise._isBound()\n                    ? handler.call(promise._boundValue(), value)\n                    : handler(value);\n\n    if (ret !== undefined) {\n        var maybePromise = tryConvertToPromise(ret, promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            return promisedFinally(maybePromise, value, true);\n        }\n    }\n    return value;\n}\n\nPromise.prototype._passThroughHandler = function (handler, isFinally) {\n    if (typeof handler !== \"function\") return this.then();\n\n    var promiseAndHandler = {\n        promise: this,\n        handler: handler\n    };\n\n    return this._then(\n            isFinally ? finallyHandler : tapHandler,\n            isFinally ? finallyHandler : undefined, undefined,\n            promiseAndHandler, undefined);\n};\n\nPromise.prototype.lastly =\nPromise.prototype[\"finally\"] = function (handler) {\n    return this._passThroughHandler(handler, true);\n};\n\nPromise.prototype.tap = function (handler) {\n    return this._passThroughHandler(handler, false);\n};\n};\n\n},{\"./util.js\":38}],17:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise,\n                          apiRejection,\n                          INTERNAL,\n                          tryConvertToPromise) {\nvar errors = _dereq_(\"./errors.js\");\nvar TypeError = errors.TypeError;\nvar util = _dereq_(\"./util.js\");\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nvar yieldHandlers = [];\n\nfunction promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n    for (var i = 0; i < yieldHandlers.length; ++i) {\n        traceParent._pushContext();\n        var result = tryCatch(yieldHandlers[i])(value);\n        traceParent._popContext();\n        if (result === errorObj) {\n            traceParent._pushContext();\n            var ret = Promise.reject(errorObj.e);\n            traceParent._popContext();\n            return ret;\n        }\n        var maybePromise = tryConvertToPromise(result, traceParent);\n        if (maybePromise instanceof Promise) return maybePromise;\n    }\n    return null;\n}\n\nfunction PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n    var promise = this._promise = new Promise(INTERNAL);\n    promise._captureStackTrace();\n    this._stack = stack;\n    this._generatorFunction = generatorFunction;\n    this._receiver = receiver;\n    this._generator = undefined;\n    this._yieldHandlers = typeof yieldHandler === \"function\"\n        ? [yieldHandler].concat(yieldHandlers)\n        : yieldHandlers;\n}\n\nPromiseSpawn.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseSpawn.prototype._run = function () {\n    this._generator = this._generatorFunction.call(this._receiver);\n    this._receiver =\n        this._generatorFunction = undefined;\n    this._next(undefined);\n};\n\nPromiseSpawn.prototype._continue = function (result) {\n    if (result === errorObj) {\n        return this._promise._rejectCallback(result.e, false, true);\n    }\n\n    var value = result.value;\n    if (result.done === true) {\n        this._promise._resolveCallback(value);\n    } else {\n        var maybePromise = tryConvertToPromise(value, this._promise);\n        if (!(maybePromise instanceof Promise)) {\n            maybePromise =\n                promiseFromYieldHandler(maybePromise,\n                                        this._yieldHandlers,\n                                        this._promise);\n            if (maybePromise === null) {\n                this._throw(\n                    new TypeError(\n                        \"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/4Y4pDk\\u000a\\u000a\".replace(\"%s\", value) +\n                        \"From coroutine:\\u000a\" +\n                        this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")\n                    )\n                );\n                return;\n            }\n        }\n        maybePromise._then(\n            this._next,\n            this._throw,\n            undefined,\n            this,\n            null\n       );\n    }\n};\n\nPromiseSpawn.prototype._throw = function (reason) {\n    this._promise._attachExtraTrace(reason);\n    this._promise._pushContext();\n    var result = tryCatch(this._generator[\"throw\"])\n        .call(this._generator, reason);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromiseSpawn.prototype._next = function (value) {\n    this._promise._pushContext();\n    var result = tryCatch(this._generator.next).call(this._generator, value);\n    this._promise._popContext();\n    this._continue(result);\n};\n\nPromise.coroutine = function (generatorFunction, options) {\n    if (typeof generatorFunction !== \"function\") {\n        throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/6Vqhm0\\u000a\");\n    }\n    var yieldHandler = Object(options).yieldHandler;\n    var PromiseSpawn$ = PromiseSpawn;\n    var stack = new Error().stack;\n    return function () {\n        var generator = generatorFunction.apply(this, arguments);\n        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,\n                                      stack);\n        spawn._generator = generator;\n        spawn._next(undefined);\n        return spawn.promise();\n    };\n};\n\nPromise.coroutine.addYieldHandler = function(fn) {\n    if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    yieldHandlers.push(fn);\n};\n\nPromise.spawn = function (generatorFunction) {\n    if (typeof generatorFunction !== \"function\") {\n        return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/6Vqhm0\\u000a\");\n    }\n    var spawn = new PromiseSpawn(generatorFunction, this);\n    var ret = spawn.promise();\n    spawn._run(Promise.spawn);\n    return ret;\n};\n};\n\n},{\"./errors.js\":13,\"./util.js\":38}],18:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports =\nfunction(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {\nvar util = _dereq_(\"./util.js\");\nvar canEvaluate = util.canEvaluate;\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar reject;\n\nif (!true) {\nif (canEvaluate) {\n    var thenCallback = function(i) {\n        return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var caller = function(count) {\n        var values = [];\n        for (var i = 1; i <= count; ++i) values.push(\"holder.p\" + i);\n        return new Function(\"holder\", \"                                      \\n\\\n            'use strict';                                                    \\n\\\n            var callback = holder.fn;                                        \\n\\\n            return callback(values);                                         \\n\\\n            \".replace(/values/g, values.join(\", \")));\n    };\n    var thenCallbacks = [];\n    var callers = [undefined];\n    for (var i = 1; i <= 5; ++i) {\n        thenCallbacks.push(thenCallback(i));\n        callers.push(caller(i));\n    }\n\n    var Holder = function(total, fn) {\n        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;\n        this.fn = fn;\n        this.total = total;\n        this.now = 0;\n    };\n\n    Holder.prototype.callers = callers;\n    Holder.prototype.checkFulfillment = function(promise) {\n        var now = this.now;\n        now++;\n        var total = this.total;\n        if (now >= total) {\n            var handler = this.callers[total];\n            promise._pushContext();\n            var ret = tryCatch(handler)(this);\n            promise._popContext();\n            if (ret === errorObj) {\n                promise._rejectCallback(ret.e, false, true);\n            } else {\n                promise._resolveCallback(ret);\n            }\n        } else {\n            this.now = now;\n        }\n    };\n\n    var reject = function (reason) {\n        this._reject(reason);\n    };\n}\n}\n\nPromise.join = function () {\n    var last = arguments.length - 1;\n    var fn;\n    if (last > 0 && typeof arguments[last] === \"function\") {\n        fn = arguments[last];\n        if (!true) {\n            if (last < 6 && canEvaluate) {\n                var ret = new Promise(INTERNAL);\n                ret._captureStackTrace();\n                var holder = new Holder(last, fn);\n                var callbacks = thenCallbacks;\n                for (var i = 0; i < last; ++i) {\n                    var maybePromise = tryConvertToPromise(arguments[i], ret);\n                    if (maybePromise instanceof Promise) {\n                        maybePromise = maybePromise._target();\n                        if (maybePromise._isPending()) {\n                            maybePromise._then(callbacks[i], reject,\n                                               undefined, ret, holder);\n                        } else if (maybePromise._isFulfilled()) {\n                            callbacks[i].call(ret,\n                                              maybePromise._value(), holder);\n                        } else {\n                            ret._reject(maybePromise._reason());\n                        }\n                    } else {\n                        callbacks[i].call(ret, maybePromise, holder);\n                    }\n                }\n                return ret;\n            }\n        }\n    }\n    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}\n    if (fn) args.pop();\n    var ret = new PromiseArray(args).promise();\n    return fn !== undefined ? ret.spread(fn) : ret;\n};\n\n};\n\n},{\"./util.js\":38}],19:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL) {\nvar getDomain = Promise._getDomain;\nvar async = _dereq_(\"./async.js\");\nvar util = _dereq_(\"./util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nvar PENDING = {};\nvar EMPTY_ARRAY = [];\n\nfunction MappingPromiseArray(promises, fn, limit, _filter) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    var domain = getDomain();\n    this._callback = domain === null ? fn : domain.bind(fn);\n    this._preservedValues = _filter === INTERNAL\n        ? new Array(this.length())\n        : null;\n    this._limit = limit;\n    this._inFlight = 0;\n    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;\n    async.invoke(init, this, undefined);\n}\nutil.inherits(MappingPromiseArray, PromiseArray);\nfunction init() {this._init$(undefined, -2);}\n\nMappingPromiseArray.prototype._init = function () {};\n\nMappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var limit = this._limit;\n    if (values[index] === PENDING) {\n        values[index] = value;\n        if (limit >= 1) {\n            this._inFlight--;\n            this._drainQueue();\n            if (this._isResolved()) return;\n        }\n    } else {\n        if (limit >= 1 && this._inFlight >= limit) {\n            values[index] = value;\n            this._queue.push(index);\n            return;\n        }\n        if (preservedValues !== null) preservedValues[index] = value;\n\n        var callback = this._callback;\n        var receiver = this._promise._boundValue();\n        this._promise._pushContext();\n        var ret = tryCatch(callback).call(receiver, value, index, length);\n        this._promise._popContext();\n        if (ret === errorObj) return this._reject(ret.e);\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            if (maybePromise._isPending()) {\n                if (limit >= 1) this._inFlight++;\n                values[index] = PENDING;\n                return maybePromise._proxyPromiseArray(this, index);\n            } else if (maybePromise._isFulfilled()) {\n                ret = maybePromise._value();\n            } else {\n                return this._reject(maybePromise._reason());\n            }\n        }\n        values[index] = ret;\n    }\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= length) {\n        if (preservedValues !== null) {\n            this._filter(values, preservedValues);\n        } else {\n            this._resolve(values);\n        }\n\n    }\n};\n\nMappingPromiseArray.prototype._drainQueue = function () {\n    var queue = this._queue;\n    var limit = this._limit;\n    var values = this._values;\n    while (queue.length > 0 && this._inFlight < limit) {\n        if (this._isResolved()) return;\n        var index = queue.pop();\n        this._promiseFulfilled(values[index], index);\n    }\n};\n\nMappingPromiseArray.prototype._filter = function (booleans, values) {\n    var len = values.length;\n    var ret = new Array(len);\n    var j = 0;\n    for (var i = 0; i < len; ++i) {\n        if (booleans[i]) ret[j++] = values[i];\n    }\n    ret.length = j;\n    this._resolve(ret);\n};\n\nMappingPromiseArray.prototype.preservedValues = function () {\n    return this._preservedValues;\n};\n\nfunction map(promises, fn, options, _filter) {\n    var limit = typeof options === \"object\" && options !== null\n        ? options.concurrency\n        : 0;\n    limit = typeof limit === \"number\" &&\n        isFinite(limit) && limit >= 1 ? limit : 0;\n    return new MappingPromiseArray(promises, fn, limit, _filter);\n}\n\nPromise.prototype.map = function (fn, options) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\n    return map(this, fn, options, null).promise();\n};\n\nPromise.map = function (promises, fn, options, _filter) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    return map(promises, fn, options, _filter).promise();\n};\n\n\n};\n\n},{\"./async.js\":2,\"./util.js\":38}],20:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports =\nfunction(Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar util = _dereq_(\"./util.js\");\nvar tryCatch = util.tryCatch;\n\nPromise.method = function (fn) {\n    if (typeof fn !== \"function\") {\n        throw new Promise.TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    }\n    return function () {\n        var ret = new Promise(INTERNAL);\n        ret._captureStackTrace();\n        ret._pushContext();\n        var value = tryCatch(fn).apply(this, arguments);\n        ret._popContext();\n        ret._resolveFromSyncValue(value);\n        return ret;\n    };\n};\n\nPromise.attempt = Promise[\"try\"] = function (fn, args, ctx) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    }\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._pushContext();\n    var value = util.isArray(args)\n        ? tryCatch(fn).apply(ctx, args)\n        : tryCatch(fn).call(ctx, args);\n    ret._popContext();\n    ret._resolveFromSyncValue(value);\n    return ret;\n};\n\nPromise.prototype._resolveFromSyncValue = function (value) {\n    if (value === util.errorObj) {\n        this._rejectCallback(value.e, false, true);\n    } else {\n        this._resolveCallback(value, true);\n    }\n};\n};\n\n},{\"./util.js\":38}],21:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise) {\nvar util = _dereq_(\"./util.js\");\nvar async = _dereq_(\"./async.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nfunction spreadAdapter(val, nodeback) {\n    var promise = this;\n    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n    var ret =\n        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nfunction successAdapter(val, nodeback) {\n    var promise = this;\n    var receiver = promise._boundValue();\n    var ret = val === undefined\n        ? tryCatch(nodeback).call(receiver, null)\n        : tryCatch(nodeback).call(receiver, null, val);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\nfunction errorAdapter(reason, nodeback) {\n    var promise = this;\n    if (!reason) {\n        var target = promise._target();\n        var newReason = target._getCarriedStackTrace();\n        newReason.cause = reason;\n        reason = newReason;\n    }\n    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);\n    if (ret === errorObj) {\n        async.throwLater(ret.e);\n    }\n}\n\nPromise.prototype.asCallback =\nPromise.prototype.nodeify = function (nodeback, options) {\n    if (typeof nodeback == \"function\") {\n        var adapter = successAdapter;\n        if (options !== undefined && Object(options).spread) {\n            adapter = spreadAdapter;\n        }\n        this._then(\n            adapter,\n            errorAdapter,\n            undefined,\n            this,\n            nodeback\n        );\n    }\n    return this;\n};\n};\n\n},{\"./async.js\":2,\"./util.js\":38}],22:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, PromiseArray) {\nvar util = _dereq_(\"./util.js\");\nvar async = _dereq_(\"./async.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\n\nPromise.prototype.progressed = function (handler) {\n    return this._then(undefined, undefined, handler, undefined, undefined);\n};\n\nPromise.prototype._progress = function (progressValue) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._target()._progressUnchecked(progressValue);\n\n};\n\nPromise.prototype._progressHandlerAt = function (index) {\n    return index === 0\n        ? this._progressHandler0\n        : this[(index << 2) + index - 5 + 2];\n};\n\nPromise.prototype._doProgressWith = function (progression) {\n    var progressValue = progression.value;\n    var handler = progression.handler;\n    var promise = progression.promise;\n    var receiver = progression.receiver;\n\n    var ret = tryCatch(handler).call(receiver, progressValue);\n    if (ret === errorObj) {\n        if (ret.e != null &&\n            ret.e.name !== \"StopProgressPropagation\") {\n            var trace = util.canAttachTrace(ret.e)\n                ? ret.e : new Error(util.toString(ret.e));\n            promise._attachExtraTrace(trace);\n            promise._progress(ret.e);\n        }\n    } else if (ret instanceof Promise) {\n        ret._then(promise._progress, null, null, promise, undefined);\n    } else {\n        promise._progress(ret);\n    }\n};\n\n\nPromise.prototype._progressUnchecked = function (progressValue) {\n    var len = this._length();\n    var progress = this._progress;\n    for (var i = 0; i < len; i++) {\n        var handler = this._progressHandlerAt(i);\n        var promise = this._promiseAt(i);\n        if (!(promise instanceof Promise)) {\n            var receiver = this._receiverAt(i);\n            if (typeof handler === \"function\") {\n                handler.call(receiver, progressValue, promise);\n            } else if (receiver instanceof PromiseArray &&\n                       !receiver._isResolved()) {\n                receiver._promiseProgressed(progressValue, promise);\n            }\n            continue;\n        }\n\n        if (typeof handler === \"function\") {\n            async.invoke(this._doProgressWith, this, {\n                handler: handler,\n                promise: promise,\n                receiver: this._receiverAt(i),\n                value: progressValue\n            });\n        } else {\n            async.invoke(progress, promise, progressValue);\n        }\n    }\n};\n};\n\n},{\"./async.js\":2,\"./util.js\":38}],23:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function() {\nvar makeSelfResolutionError = function () {\n    return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/LhFpo0\\u000a\");\n};\nvar reflect = function() {\n    return new Promise.PromiseInspection(this._target());\n};\nvar apiRejection = function(msg) {\n    return Promise.reject(new TypeError(msg));\n};\n\nvar util = _dereq_(\"./util.js\");\n\nvar getDomain;\nif (util.isNode) {\n    getDomain = function() {\n        var ret = process.domain;\n        if (ret === undefined) ret = null;\n        return ret;\n    };\n} else {\n    getDomain = function() {\n        return null;\n    };\n}\nutil.notEnumerableProp(Promise, \"_getDomain\", getDomain);\n\nvar UNDEFINED_BINDING = {};\nvar async = _dereq_(\"./async.js\");\nvar errors = _dereq_(\"./errors.js\");\nvar TypeError = Promise.TypeError = errors.TypeError;\nPromise.RangeError = errors.RangeError;\nPromise.CancellationError = errors.CancellationError;\nPromise.TimeoutError = errors.TimeoutError;\nPromise.OperationalError = errors.OperationalError;\nPromise.RejectionError = errors.OperationalError;\nPromise.AggregateError = errors.AggregateError;\nvar INTERNAL = function(){};\nvar APPLY = {};\nvar NEXT_FILTER = {e: null};\nvar tryConvertToPromise = _dereq_(\"./thenables.js\")(Promise, INTERNAL);\nvar PromiseArray =\n    _dereq_(\"./promise_array.js\")(Promise, INTERNAL,\n                                    tryConvertToPromise, apiRejection);\nvar CapturedTrace = _dereq_(\"./captured_trace.js\")();\nvar isDebugging = _dereq_(\"./debuggability.js\")(Promise, CapturedTrace);\n /*jshint unused:false*/\nvar createContext =\n    _dereq_(\"./context.js\")(Promise, CapturedTrace, isDebugging);\nvar CatchFilter = _dereq_(\"./catch_filter.js\")(NEXT_FILTER);\nvar PromiseResolver = _dereq_(\"./promise_resolver.js\");\nvar nodebackForPromise = PromiseResolver._nodebackForPromise;\nvar errorObj = util.errorObj;\nvar tryCatch = util.tryCatch;\nfunction Promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"the promise constructor requires a resolver function\\u000a\\u000a    See http://goo.gl/EC22Yn\\u000a\");\n    }\n    if (this.constructor !== Promise) {\n        throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/KsIlge\\u000a\");\n    }\n    this._bitField = 0;\n    this._fulfillmentHandler0 = undefined;\n    this._rejectionHandler0 = undefined;\n    this._progressHandler0 = undefined;\n    this._promise0 = undefined;\n    this._receiver0 = undefined;\n    this._settledValue = undefined;\n    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n    var len = arguments.length;\n    if (len > 1) {\n        var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (typeof item === \"function\") {\n                catchInstances[j++] = item;\n            } else {\n                return Promise.reject(\n                    new TypeError(\"Catch filter must inherit from Error or be a simple predicate function\\u000a\\u000a    See http://goo.gl/o84o68\\u000a\"));\n            }\n        }\n        catchInstances.length = j;\n        fn = arguments[i];\n        var catchFilter = new CatchFilter(catchInstances, fn, this);\n        return this._then(undefined, catchFilter.doFilter, undefined,\n            catchFilter, undefined);\n    }\n    return this._then(undefined, fn, undefined, undefined, undefined);\n};\n\nPromise.prototype.reflect = function () {\n    return this._then(reflect, reflect, undefined, this, undefined);\n};\n\nPromise.prototype.then = function (didFulfill, didReject, didProgress) {\n    if (isDebugging() && arguments.length > 0 &&\n        typeof didFulfill !== \"function\" &&\n        typeof didReject !== \"function\") {\n        var msg = \".then() only accepts functions but was passed: \" +\n                util.classString(didFulfill);\n        if (arguments.length > 1) {\n            msg += \", \" + util.classString(didReject);\n        }\n        this._warn(msg);\n    }\n    return this._then(didFulfill, didReject, didProgress,\n        undefined, undefined);\n};\n\nPromise.prototype.done = function (didFulfill, didReject, didProgress) {\n    var promise = this._then(didFulfill, didReject, didProgress,\n        undefined, undefined);\n    promise._setIsFinal();\n};\n\nPromise.prototype.spread = function (didFulfill, didReject) {\n    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);\n};\n\nPromise.prototype.isCancellable = function () {\n    return !this.isResolved() &&\n        this._cancellable();\n};\n\nPromise.prototype.toJSON = function () {\n    var ret = {\n        isFulfilled: false,\n        isRejected: false,\n        fulfillmentValue: undefined,\n        rejectionReason: undefined\n    };\n    if (this.isFulfilled()) {\n        ret.fulfillmentValue = this.value();\n        ret.isFulfilled = true;\n    } else if (this.isRejected()) {\n        ret.rejectionReason = this.reason();\n        ret.isRejected = true;\n    }\n    return ret;\n};\n\nPromise.prototype.all = function () {\n    return new PromiseArray(this).promise();\n};\n\nPromise.prototype.error = function (fn) {\n    return this.caught(util.originatesFromRejection, fn);\n};\n\nPromise.is = function (val) {\n    return val instanceof Promise;\n};\n\nPromise.fromNode = function(fn) {\n    var ret = new Promise(INTERNAL);\n    var result = tryCatch(fn)(nodebackForPromise(ret));\n    if (result === errorObj) {\n        ret._rejectCallback(result.e, true, true);\n    }\n    return ret;\n};\n\nPromise.all = function (promises) {\n    return new PromiseArray(promises).promise();\n};\n\nPromise.defer = Promise.pending = function () {\n    var promise = new Promise(INTERNAL);\n    return new PromiseResolver(promise);\n};\n\nPromise.cast = function (obj) {\n    var ret = tryConvertToPromise(obj);\n    if (!(ret instanceof Promise)) {\n        var val = ret;\n        ret = new Promise(INTERNAL);\n        ret._fulfillUnchecked(val);\n    }\n    return ret;\n};\n\nPromise.resolve = Promise.fulfilled = Promise.cast;\n\nPromise.reject = Promise.rejected = function (reason) {\n    var ret = new Promise(INTERNAL);\n    ret._captureStackTrace();\n    ret._rejectCallback(reason, true);\n    return ret;\n};\n\nPromise.setScheduler = function(fn) {\n    if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    var prev = async._schedule;\n    async._schedule = fn;\n    return prev;\n};\n\nPromise.prototype._then = function (\n    didFulfill,\n    didReject,\n    didProgress,\n    receiver,\n    internalData\n) {\n    var haveInternalData = internalData !== undefined;\n    var ret = haveInternalData ? internalData : new Promise(INTERNAL);\n\n    if (!haveInternalData) {\n        ret._propagateFrom(this, 4 | 1);\n        ret._captureStackTrace();\n    }\n\n    var target = this._target();\n    if (target !== this) {\n        if (receiver === undefined) receiver = this._boundTo;\n        if (!haveInternalData) ret._setIsMigrated();\n    }\n\n    var callbackIndex = target._addCallbacks(didFulfill,\n                                             didReject,\n                                             didProgress,\n                                             ret,\n                                             receiver,\n                                             getDomain());\n\n    if (target._isResolved() && !target._isSettlePromisesQueued()) {\n        async.invoke(\n            target._settlePromiseAtPostResolution, target, callbackIndex);\n    }\n\n    return ret;\n};\n\nPromise.prototype._settlePromiseAtPostResolution = function (index) {\n    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();\n    this._settlePromiseAt(index);\n};\n\nPromise.prototype._length = function () {\n    return this._bitField & 131071;\n};\n\nPromise.prototype._isFollowingOrFulfilledOrRejected = function () {\n    return (this._bitField & 939524096) > 0;\n};\n\nPromise.prototype._isFollowing = function () {\n    return (this._bitField & 536870912) === 536870912;\n};\n\nPromise.prototype._setLength = function (len) {\n    this._bitField = (this._bitField & -131072) |\n        (len & 131071);\n};\n\nPromise.prototype._setFulfilled = function () {\n    this._bitField = this._bitField | 268435456;\n};\n\nPromise.prototype._setRejected = function () {\n    this._bitField = this._bitField | 134217728;\n};\n\nPromise.prototype._setFollowing = function () {\n    this._bitField = this._bitField | 536870912;\n};\n\nPromise.prototype._setIsFinal = function () {\n    this._bitField = this._bitField | 33554432;\n};\n\nPromise.prototype._isFinal = function () {\n    return (this._bitField & 33554432) > 0;\n};\n\nPromise.prototype._cancellable = function () {\n    return (this._bitField & 67108864) > 0;\n};\n\nPromise.prototype._setCancellable = function () {\n    this._bitField = this._bitField | 67108864;\n};\n\nPromise.prototype._unsetCancellable = function () {\n    this._bitField = this._bitField & (~67108864);\n};\n\nPromise.prototype._setIsMigrated = function () {\n    this._bitField = this._bitField | 4194304;\n};\n\nPromise.prototype._unsetIsMigrated = function () {\n    this._bitField = this._bitField & (~4194304);\n};\n\nPromise.prototype._isMigrated = function () {\n    return (this._bitField & 4194304) > 0;\n};\n\nPromise.prototype._receiverAt = function (index) {\n    var ret = index === 0\n        ? this._receiver0\n        : this[\n            index * 5 - 5 + 4];\n    if (ret === UNDEFINED_BINDING) {\n        return undefined;\n    } else if (ret === undefined && this._isBound()) {\n        return this._boundValue();\n    }\n    return ret;\n};\n\nPromise.prototype._promiseAt = function (index) {\n    return index === 0\n        ? this._promise0\n        : this[index * 5 - 5 + 3];\n};\n\nPromise.prototype._fulfillmentHandlerAt = function (index) {\n    return index === 0\n        ? this._fulfillmentHandler0\n        : this[index * 5 - 5 + 0];\n};\n\nPromise.prototype._rejectionHandlerAt = function (index) {\n    return index === 0\n        ? this._rejectionHandler0\n        : this[index * 5 - 5 + 1];\n};\n\nPromise.prototype._boundValue = function() {\n    var ret = this._boundTo;\n    if (ret !== undefined) {\n        if (ret instanceof Promise) {\n            if (ret.isFulfilled()) {\n                return ret.value();\n            } else {\n                return undefined;\n            }\n        }\n    }\n    return ret;\n};\n\nPromise.prototype._migrateCallbacks = function (follower, index) {\n    var fulfill = follower._fulfillmentHandlerAt(index);\n    var reject = follower._rejectionHandlerAt(index);\n    var progress = follower._progressHandlerAt(index);\n    var promise = follower._promiseAt(index);\n    var receiver = follower._receiverAt(index);\n    if (promise instanceof Promise) promise._setIsMigrated();\n    if (receiver === undefined) receiver = UNDEFINED_BINDING;\n    this._addCallbacks(fulfill, reject, progress, promise, receiver, null);\n};\n\nPromise.prototype._addCallbacks = function (\n    fulfill,\n    reject,\n    progress,\n    promise,\n    receiver,\n    domain\n) {\n    var index = this._length();\n\n    if (index >= 131071 - 5) {\n        index = 0;\n        this._setLength(0);\n    }\n\n    if (index === 0) {\n        this._promise0 = promise;\n        if (receiver !== undefined) this._receiver0 = receiver;\n        if (typeof fulfill === \"function\" && !this._isCarryingStackTrace()) {\n            this._fulfillmentHandler0 =\n                domain === null ? fulfill : domain.bind(fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this._rejectionHandler0 =\n                domain === null ? reject : domain.bind(reject);\n        }\n        if (typeof progress === \"function\") {\n            this._progressHandler0 =\n                domain === null ? progress : domain.bind(progress);\n        }\n    } else {\n        var base = index * 5 - 5;\n        this[base + 3] = promise;\n        this[base + 4] = receiver;\n        if (typeof fulfill === \"function\") {\n            this[base + 0] =\n                domain === null ? fulfill : domain.bind(fulfill);\n        }\n        if (typeof reject === \"function\") {\n            this[base + 1] =\n                domain === null ? reject : domain.bind(reject);\n        }\n        if (typeof progress === \"function\") {\n            this[base + 2] =\n                domain === null ? progress : domain.bind(progress);\n        }\n    }\n    this._setLength(index + 1);\n    return index;\n};\n\nPromise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {\n    var index = this._length();\n\n    if (index >= 131071 - 5) {\n        index = 0;\n        this._setLength(0);\n    }\n    if (index === 0) {\n        this._promise0 = promiseSlotValue;\n        this._receiver0 = receiver;\n    } else {\n        var base = index * 5 - 5;\n        this[base + 3] = promiseSlotValue;\n        this[base + 4] = receiver;\n    }\n    this._setLength(index + 1);\n};\n\nPromise.prototype._proxyPromiseArray = function (promiseArray, index) {\n    this._setProxyHandlers(promiseArray, index);\n};\n\nPromise.prototype._resolveCallback = function(value, shouldBind) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    if (value === this)\n        return this._rejectCallback(makeSelfResolutionError(), false, true);\n    var maybePromise = tryConvertToPromise(value, this);\n    if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n\n    var propagationFlags = 1 | (shouldBind ? 4 : 0);\n    this._propagateFrom(maybePromise, propagationFlags);\n    var promise = maybePromise._target();\n    if (promise._isPending()) {\n        var len = this._length();\n        for (var i = 0; i < len; ++i) {\n            promise._migrateCallbacks(this, i);\n        }\n        this._setFollowing();\n        this._setLength(0);\n        this._setFollowee(promise);\n    } else if (promise._isFulfilled()) {\n        this._fulfillUnchecked(promise._value());\n    } else {\n        this._rejectUnchecked(promise._reason(),\n            promise._getCarriedStackTrace());\n    }\n};\n\nPromise.prototype._rejectCallback =\nfunction(reason, synchronous, shouldNotMarkOriginatingFromRejection) {\n    if (!shouldNotMarkOriginatingFromRejection) {\n        util.markAsOriginatingFromRejection(reason);\n    }\n    var trace = util.ensureErrorObject(reason);\n    var hasStack = trace === reason;\n    this._attachExtraTrace(trace, synchronous ? hasStack : false);\n    this._reject(reason, hasStack ? undefined : trace);\n};\n\nPromise.prototype._resolveFromResolver = function (resolver) {\n    var promise = this;\n    this._captureStackTrace();\n    this._pushContext();\n    var synchronous = true;\n    var r = tryCatch(resolver)(function(value) {\n        if (promise === null) return;\n        promise._resolveCallback(value);\n        promise = null;\n    }, function (reason) {\n        if (promise === null) return;\n        promise._rejectCallback(reason, synchronous);\n        promise = null;\n    });\n    synchronous = false;\n    this._popContext();\n\n    if (r !== undefined && r === errorObj && promise !== null) {\n        promise._rejectCallback(r.e, true, true);\n        promise = null;\n    }\n};\n\nPromise.prototype._settlePromiseFromHandler = function (\n    handler, receiver, value, promise\n) {\n    if (promise._isRejected()) return;\n    promise._pushContext();\n    var x;\n    if (receiver === APPLY && !this._isRejected()) {\n        x = tryCatch(handler).apply(this._boundValue(), value);\n    } else {\n        x = tryCatch(handler).call(receiver, value);\n    }\n    promise._popContext();\n\n    if (x === errorObj || x === promise || x === NEXT_FILTER) {\n        var err = x === promise ? makeSelfResolutionError() : x.e;\n        promise._rejectCallback(err, false, true);\n    } else {\n        promise._resolveCallback(x);\n    }\n};\n\nPromise.prototype._target = function() {\n    var ret = this;\n    while (ret._isFollowing()) ret = ret._followee();\n    return ret;\n};\n\nPromise.prototype._followee = function() {\n    return this._rejectionHandler0;\n};\n\nPromise.prototype._setFollowee = function(promise) {\n    this._rejectionHandler0 = promise;\n};\n\nPromise.prototype._cleanValues = function () {\n    if (this._cancellable()) {\n        this._cancellationParent = undefined;\n    }\n};\n\nPromise.prototype._propagateFrom = function (parent, flags) {\n    if ((flags & 1) > 0 && parent._cancellable()) {\n        this._setCancellable();\n        this._cancellationParent = parent;\n    }\n    if ((flags & 4) > 0 && parent._isBound()) {\n        this._setBoundTo(parent._boundTo);\n    }\n};\n\nPromise.prototype._fulfill = function (value) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._fulfillUnchecked(value);\n};\n\nPromise.prototype._reject = function (reason, carriedStackTrace) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._rejectUnchecked(reason, carriedStackTrace);\n};\n\nPromise.prototype._settlePromiseAt = function (index) {\n    var promise = this._promiseAt(index);\n    var isPromise = promise instanceof Promise;\n\n    if (isPromise && promise._isMigrated()) {\n        promise._unsetIsMigrated();\n        return async.invoke(this._settlePromiseAt, this, index);\n    }\n    var handler = this._isFulfilled()\n        ? this._fulfillmentHandlerAt(index)\n        : this._rejectionHandlerAt(index);\n\n    var carriedStackTrace =\n        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;\n    var value = this._settledValue;\n    var receiver = this._receiverAt(index);\n    this._clearCallbackDataAtIndex(index);\n\n    if (typeof handler === \"function\") {\n        if (!isPromise) {\n            handler.call(receiver, value, promise);\n        } else {\n            this._settlePromiseFromHandler(handler, receiver, value, promise);\n        }\n    } else if (receiver instanceof PromiseArray) {\n        if (!receiver._isResolved()) {\n            if (this._isFulfilled()) {\n                receiver._promiseFulfilled(value, promise);\n            }\n            else {\n                receiver._promiseRejected(value, promise);\n            }\n        }\n    } else if (isPromise) {\n        if (this._isFulfilled()) {\n            promise._fulfill(value);\n        } else {\n            promise._reject(value, carriedStackTrace);\n        }\n    }\n\n    if (index >= 4 && (index & 31) === 4)\n        async.invokeLater(this._setLength, this, 0);\n};\n\nPromise.prototype._clearCallbackDataAtIndex = function(index) {\n    if (index === 0) {\n        if (!this._isCarryingStackTrace()) {\n            this._fulfillmentHandler0 = undefined;\n        }\n        this._rejectionHandler0 =\n        this._progressHandler0 =\n        this._receiver0 =\n        this._promise0 = undefined;\n    } else {\n        var base = index * 5 - 5;\n        this[base + 3] =\n        this[base + 4] =\n        this[base + 0] =\n        this[base + 1] =\n        this[base + 2] = undefined;\n    }\n};\n\nPromise.prototype._isSettlePromisesQueued = function () {\n    return (this._bitField &\n            -1073741824) === -1073741824;\n};\n\nPromise.prototype._setSettlePromisesQueued = function () {\n    this._bitField = this._bitField | -1073741824;\n};\n\nPromise.prototype._unsetSettlePromisesQueued = function () {\n    this._bitField = this._bitField & (~-1073741824);\n};\n\nPromise.prototype._queueSettlePromises = function() {\n    async.settlePromises(this);\n    this._setSettlePromisesQueued();\n};\n\nPromise.prototype._fulfillUnchecked = function (value) {\n    if (value === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._rejectUnchecked(err, undefined);\n    }\n    this._setFulfilled();\n    this._settledValue = value;\n    this._cleanValues();\n\n    if (this._length() > 0) {\n        this._queueSettlePromises();\n    }\n};\n\nPromise.prototype._rejectUncheckedCheckError = function (reason) {\n    var trace = util.ensureErrorObject(reason);\n    this._rejectUnchecked(reason, trace === reason ? undefined : trace);\n};\n\nPromise.prototype._rejectUnchecked = function (reason, trace) {\n    if (reason === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._rejectUnchecked(err);\n    }\n    this._setRejected();\n    this._settledValue = reason;\n    this._cleanValues();\n\n    if (this._isFinal()) {\n        async.throwLater(function(e) {\n            if (\"stack\" in e) {\n                async.invokeFirst(\n                    CapturedTrace.unhandledRejection, undefined, e);\n            }\n            throw e;\n        }, trace === undefined ? reason : trace);\n        return;\n    }\n\n    if (trace !== undefined && trace !== reason) {\n        this._setCarriedStackTrace(trace);\n    }\n\n    if (this._length() > 0) {\n        this._queueSettlePromises();\n    } else {\n        this._ensurePossibleRejectionHandled();\n    }\n};\n\nPromise.prototype._settlePromises = function () {\n    this._unsetSettlePromisesQueued();\n    var len = this._length();\n    for (var i = 0; i < len; i++) {\n        this._settlePromiseAt(i);\n    }\n};\n\nutil.notEnumerableProp(Promise,\n                       \"_makeSelfResolutionError\",\n                       makeSelfResolutionError);\n\n_dereq_(\"./progress.js\")(Promise, PromiseArray);\n_dereq_(\"./method.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n_dereq_(\"./bind.js\")(Promise, INTERNAL, tryConvertToPromise);\n_dereq_(\"./finally.js\")(Promise, NEXT_FILTER, tryConvertToPromise);\n_dereq_(\"./direct_resolve.js\")(Promise);\n_dereq_(\"./synchronous_inspection.js\")(Promise);\n_dereq_(\"./join.js\")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);\nPromise.Promise = Promise;\n_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);\n_dereq_('./cancel.js')(Promise);\n_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);\n_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);\n_dereq_('./nodeify.js')(Promise);\n_dereq_('./call_get.js')(Promise);\n_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);\n_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);\n_dereq_('./settle.js')(Promise, PromiseArray);\n_dereq_('./some.js')(Promise, PromiseArray, apiRejection);\n_dereq_('./promisify.js')(Promise, INTERNAL);\n_dereq_('./any.js')(Promise);\n_dereq_('./each.js')(Promise, INTERNAL);\n_dereq_('./timers.js')(Promise, INTERNAL);\n_dereq_('./filter.js')(Promise, INTERNAL);\n                                                         \n    util.toFastProperties(Promise);                                          \n    util.toFastProperties(Promise.prototype);                                \n    function fillTypes(value) {                                              \n        var p = new Promise(INTERNAL);                                       \n        p._fulfillmentHandler0 = value;                                      \n        p._rejectionHandler0 = value;                                        \n        p._progressHandler0 = value;                                         \n        p._promise0 = value;                                                 \n        p._receiver0 = value;                                                \n        p._settledValue = value;                                             \n    }                                                                        \n    // Complete slack tracking, opt out of field-type tracking and           \n    // stabilize map                                                         \n    fillTypes({a: 1});                                                       \n    fillTypes({b: 2});                                                       \n    fillTypes({c: 3});                                                       \n    fillTypes(1);                                                            \n    fillTypes(function(){});                                                 \n    fillTypes(undefined);                                                    \n    fillTypes(false);                                                        \n    fillTypes(new Promise(INTERNAL));                                        \n    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       \n    return Promise;                                                          \n\n};\n\n},{\"./any.js\":1,\"./async.js\":2,\"./bind.js\":3,\"./call_get.js\":5,\"./cancel.js\":6,\"./captured_trace.js\":7,\"./catch_filter.js\":8,\"./context.js\":9,\"./debuggability.js\":10,\"./direct_resolve.js\":11,\"./each.js\":12,\"./errors.js\":13,\"./filter.js\":15,\"./finally.js\":16,\"./generators.js\":17,\"./join.js\":18,\"./map.js\":19,\"./method.js\":20,\"./nodeify.js\":21,\"./progress.js\":22,\"./promise_array.js\":24,\"./promise_resolver.js\":25,\"./promisify.js\":26,\"./props.js\":27,\"./race.js\":29,\"./reduce.js\":30,\"./settle.js\":32,\"./some.js\":33,\"./synchronous_inspection.js\":34,\"./thenables.js\":35,\"./timers.js\":36,\"./using.js\":37,\"./util.js\":38}],24:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL, tryConvertToPromise,\n    apiRejection) {\nvar util = _dereq_(\"./util.js\");\nvar isArray = util.isArray;\n\nfunction toResolutionValue(val) {\n    switch(val) {\n    case -2: return [];\n    case -3: return {};\n    }\n}\n\nfunction PromiseArray(values) {\n    var promise = this._promise = new Promise(INTERNAL);\n    var parent;\n    if (values instanceof Promise) {\n        parent = values;\n        promise._propagateFrom(parent, 1 | 4);\n    }\n    this._values = values;\n    this._length = 0;\n    this._totalResolved = 0;\n    this._init(undefined, -2);\n}\nPromiseArray.prototype.length = function () {\n    return this._length;\n};\n\nPromiseArray.prototype.promise = function () {\n    return this._promise;\n};\n\nPromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n    var values = tryConvertToPromise(this._values, this._promise);\n    if (values instanceof Promise) {\n        values = values._target();\n        this._values = values;\n        if (values._isFulfilled()) {\n            values = values._value();\n            if (!isArray(values)) {\n                var err = new Promise.TypeError(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\");\n                this.__hardReject__(err);\n                return;\n            }\n        } else if (values._isPending()) {\n            values._then(\n                init,\n                this._reject,\n                undefined,\n                this,\n                resolveValueIfEmpty\n           );\n            return;\n        } else {\n            this._reject(values._reason());\n            return;\n        }\n    } else if (!isArray(values)) {\n        this._promise._reject(apiRejection(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\")._reason());\n        return;\n    }\n\n    if (values.length === 0) {\n        if (resolveValueIfEmpty === -5) {\n            this._resolveEmptyArray();\n        }\n        else {\n            this._resolve(toResolutionValue(resolveValueIfEmpty));\n        }\n        return;\n    }\n    var len = this.getActualLength(values.length);\n    this._length = len;\n    this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n    var promise = this._promise;\n    for (var i = 0; i < len; ++i) {\n        var isResolved = this._isResolved();\n        var maybePromise = tryConvertToPromise(values[i], promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            if (isResolved) {\n                maybePromise._ignoreRejections();\n            } else if (maybePromise._isPending()) {\n                maybePromise._proxyPromiseArray(this, i);\n            } else if (maybePromise._isFulfilled()) {\n                this._promiseFulfilled(maybePromise._value(), i);\n            } else {\n                this._promiseRejected(maybePromise._reason(), i);\n            }\n        } else if (!isResolved) {\n            this._promiseFulfilled(maybePromise, i);\n        }\n    }\n};\n\nPromiseArray.prototype._isResolved = function () {\n    return this._values === null;\n};\n\nPromiseArray.prototype._resolve = function (value) {\n    this._values = null;\n    this._promise._fulfill(value);\n};\n\nPromiseArray.prototype.__hardReject__ =\nPromiseArray.prototype._reject = function (reason) {\n    this._values = null;\n    this._promise._rejectCallback(reason, false, true);\n};\n\nPromiseArray.prototype._promiseProgressed = function (progressValue, index) {\n    this._promise._progress({\n        index: index,\n        value: progressValue\n    });\n};\n\n\nPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n    }\n};\n\nPromiseArray.prototype._promiseRejected = function (reason, index) {\n    this._totalResolved++;\n    this._reject(reason);\n};\n\nPromiseArray.prototype.shouldCopyValues = function () {\n    return true;\n};\n\nPromiseArray.prototype.getActualLength = function (len) {\n    return len;\n};\n\nreturn PromiseArray;\n};\n\n},{\"./util.js\":38}],25:[function(_dereq_,module,exports){\n\"use strict\";\nvar util = _dereq_(\"./util.js\");\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar errors = _dereq_(\"./errors.js\");\nvar TimeoutError = errors.TimeoutError;\nvar OperationalError = errors.OperationalError;\nvar haveGetters = util.haveGetters;\nvar es5 = _dereq_(\"./es5.js\");\n\nfunction isUntypedError(obj) {\n    return obj instanceof Error &&\n        es5.getPrototypeOf(obj) === Error.prototype;\n}\n\nvar rErrorKey = /^(?:name|message|stack|cause)$/;\nfunction wrapAsOperationalError(obj) {\n    var ret;\n    if (isUntypedError(obj)) {\n        ret = new OperationalError(obj);\n        ret.name = obj.name;\n        ret.message = obj.message;\n        ret.stack = obj.stack;\n        var keys = es5.keys(obj);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!rErrorKey.test(key)) {\n                ret[key] = obj[key];\n            }\n        }\n        return ret;\n    }\n    util.markAsOriginatingFromRejection(obj);\n    return obj;\n}\n\nfunction nodebackForPromise(promise) {\n    return function(err, value) {\n        if (promise === null) return;\n\n        if (err) {\n            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n            promise._attachExtraTrace(wrapped);\n            promise._reject(wrapped);\n        } else if (arguments.length > 2) {\n            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}\n            promise._fulfill(args);\n        } else {\n            promise._fulfill(value);\n        }\n\n        promise = null;\n    };\n}\n\n\nvar PromiseResolver;\nif (!haveGetters) {\n    PromiseResolver = function (promise) {\n        this.promise = promise;\n        this.asCallback = nodebackForPromise(promise);\n        this.callback = this.asCallback;\n    };\n}\nelse {\n    PromiseResolver = function (promise) {\n        this.promise = promise;\n    };\n}\nif (haveGetters) {\n    var prop = {\n        get: function() {\n            return nodebackForPromise(this.promise);\n        }\n    };\n    es5.defineProperty(PromiseResolver.prototype, \"asCallback\", prop);\n    es5.defineProperty(PromiseResolver.prototype, \"callback\", prop);\n}\n\nPromiseResolver._nodebackForPromise = nodebackForPromise;\n\nPromiseResolver.prototype.toString = function () {\n    return \"[object PromiseResolver]\";\n};\n\nPromiseResolver.prototype.resolve =\nPromiseResolver.prototype.fulfill = function (value) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n    }\n    this.promise._resolveCallback(value);\n};\n\nPromiseResolver.prototype.reject = function (reason) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n    }\n    this.promise._rejectCallback(reason);\n};\n\nPromiseResolver.prototype.progress = function (value) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n    }\n    this.promise._progress(value);\n};\n\nPromiseResolver.prototype.cancel = function (err) {\n    this.promise.cancel(err);\n};\n\nPromiseResolver.prototype.timeout = function () {\n    this.reject(new TimeoutError(\"timeout\"));\n};\n\nPromiseResolver.prototype.isResolved = function () {\n    return this.promise.isResolved();\n};\n\nPromiseResolver.prototype.toJSON = function () {\n    return this.promise.toJSON();\n};\n\nmodule.exports = PromiseResolver;\n\n},{\"./errors.js\":13,\"./es5.js\":14,\"./util.js\":38}],26:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar THIS = {};\nvar util = _dereq_(\"./util.js\");\nvar nodebackForPromise = _dereq_(\"./promise_resolver.js\")\n    ._nodebackForPromise;\nvar withAppended = util.withAppended;\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar canEvaluate = util.canEvaluate;\nvar TypeError = _dereq_(\"./errors\").TypeError;\nvar defaultSuffix = \"Async\";\nvar defaultPromisified = {__isPromisified__: true};\nvar noCopyProps = [\n    \"arity\",    \"length\",\n    \"name\",\n    \"arguments\",\n    \"caller\",\n    \"callee\",\n    \"prototype\",\n    \"__isPromisified__\"\n];\nvar noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\nvar defaultFilter = function(name) {\n    return util.isIdentifier(name) &&\n        name.charAt(0) !== \"_\" &&\n        name !== \"constructor\";\n};\n\nfunction propsFilter(key) {\n    return !noCopyPropsPattern.test(key);\n}\n\nfunction isPromisified(fn) {\n    try {\n        return fn.__isPromisified__ === true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n\nfunction hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix,\n                                            defaultPromisified);\n    return val ? isPromisified(val) : false;\n}\nfunction checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n        var key = ret[i];\n        if (suffixRegexp.test(key)) {\n            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n            for (var j = 0; j < ret.length; j += 2) {\n                if (ret[j] === keyWithoutAsyncSuffix) {\n                    throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/iWrZbw\\u000a\"\n                        .replace(\"%s\", suffix));\n                }\n            }\n        }\n    }\n}\n\nfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var value = obj[key];\n        var passesDefaultFilter = filter === defaultFilter\n            ? true : defaultFilter(key, value, obj);\n        if (typeof value === \"function\" &&\n            !isPromisified(value) &&\n            !hasPromisified(obj, key, suffix) &&\n            filter(key, value, obj, passesDefaultFilter)) {\n            ret.push(key, value);\n        }\n    }\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n}\n\nvar escapeIdentRegex = function(str) {\n    return str.replace(/([$])/, \"\\\\$\");\n};\n\nvar makeNodePromisifiedEval;\nif (!true) {\nvar switchCaseArgumentOrder = function(likelyArgumentCount) {\n    var ret = [likelyArgumentCount];\n    var min = Math.max(0, likelyArgumentCount - 1 - 3);\n    for(var i = likelyArgumentCount - 1; i >= min; --i) {\n        ret.push(i);\n    }\n    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {\n        ret.push(i);\n    }\n    return ret;\n};\n\nvar argumentSequence = function(argumentCount) {\n    return util.filledRange(argumentCount, \"_arg\", \"\");\n};\n\nvar parameterDeclaration = function(parameterCount) {\n    return util.filledRange(\n        Math.max(parameterCount, 3), \"_arg\", \"\");\n};\n\nvar parameterCount = function(fn) {\n    if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n    }\n    return 0;\n};\n\nmakeNodePromisifiedEval =\nfunction(callback, receiver, originalName, fn) {\n    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n    var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n    function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n        if (shouldProxyThis) {\n            ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n        } else {\n            ret = receiver === undefined\n                ? \"ret = callback({{args}}, nodeback); break;\\n\"\n                : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n        }\n        return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n    }\n\n    function generateArgumentSwitchCase() {\n        var ret = \"\";\n        for (var i = 0; i < argumentOrder.length; ++i) {\n            ret += \"case \" + argumentOrder[i] +\":\" +\n                generateCallForArgumentCount(argumentOrder[i]);\n        }\n\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", (shouldProxyThis\n                                ? \"ret = callback.apply(this, args);\\n\"\n                                : \"ret = callback.apply(receiver, args);\\n\"));\n        return ret;\n    }\n\n    var getFunctionCode = typeof callback === \"string\"\n                                ? (\"this != null ? this['\"+callback+\"'] : fn\")\n                                : \"fn\";\n\n    return new Function(\"Promise\",\n                        \"fn\",\n                        \"receiver\",\n                        \"withAppended\",\n                        \"maybeWrapAsError\",\n                        \"nodebackForPromise\",\n                        \"tryCatch\",\n                        \"errorObj\",\n                        \"notEnumerableProp\",\n                        \"INTERNAL\",\"'use strict';                            \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise);                      \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n        \"\n        .replace(\"Parameters\", parameterDeclaration(newParameterCount))\n        .replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase())\n        .replace(\"[GetFunctionCode]\", getFunctionCode))(\n            Promise,\n            fn,\n            receiver,\n            withAppended,\n            maybeWrapAsError,\n            nodebackForPromise,\n            util.tryCatch,\n            util.errorObj,\n            util.notEnumerableProp,\n            INTERNAL\n        );\n};\n}\n\nfunction makeNodePromisifiedClosure(callback, receiver, _, fn) {\n    var defaultThis = (function() {return this;})();\n    var method = callback;\n    if (typeof method === \"string\") {\n        callback = fn;\n    }\n    function promisified() {\n        var _receiver = receiver;\n        if (receiver === THIS) _receiver = this;\n        var promise = new Promise(INTERNAL);\n        promise._captureStackTrace();\n        var cb = typeof method === \"string\" && this !== defaultThis\n            ? this[method] : callback;\n        var fn = nodebackForPromise(promise);\n        try {\n            cb.apply(_receiver, withAppended(arguments, fn));\n        } catch(e) {\n            promise._rejectCallback(maybeWrapAsError(e), true, true);\n        }\n        return promise;\n    }\n    util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n    return promisified;\n}\n\nvar makeNodePromisified = canEvaluate\n    ? makeNodePromisifiedEval\n    : makeNodePromisifiedClosure;\n\nfunction promisifyAll(obj, suffix, filter, promisifier) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods =\n        promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n    for (var i = 0, len = methods.length; i < len; i+= 2) {\n        var key = methods[i];\n        var fn = methods[i+1];\n        var promisifiedKey = key + suffix;\n        if (promisifier === makeNodePromisified) {\n            obj[promisifiedKey] =\n                makeNodePromisified(key, THIS, key, fn, suffix);\n        } else {\n            var promisified = promisifier(fn, function() {\n                return makeNodePromisified(key, THIS, key, fn, suffix);\n            });\n            util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n            obj[promisifiedKey] = promisified;\n        }\n    }\n    util.toFastProperties(obj);\n    return obj;\n}\n\nfunction promisify(callback, receiver) {\n    return makeNodePromisified(callback, receiver, undefined, callback);\n}\n\nPromise.promisify = function (fn, receiver) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    }\n    if (isPromisified(fn)) {\n        return fn;\n    }\n    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);\n    util.copyDescriptors(fn, ret, propsFilter);\n    return ret;\n};\n\nPromise.promisifyAll = function (target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n        throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/9ITlV0\\u000a\");\n    }\n    options = Object(options);\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n    if (!util.isIdentifier(suffix)) {\n        throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/8FZo5V\\u000a\");\n    }\n\n    var keys = util.inheritedDataKeys(target);\n    for (var i = 0; i < keys.length; ++i) {\n        var value = target[keys[i]];\n        if (keys[i] !== \"constructor\" &&\n            util.isClass(value)) {\n            promisifyAll(value.prototype, suffix, filter, promisifier);\n            promisifyAll(value, suffix, filter, promisifier);\n        }\n    }\n\n    return promisifyAll(target, suffix, filter, promisifier);\n};\n};\n\n\n},{\"./errors\":13,\"./promise_resolver.js\":25,\"./util.js\":38}],27:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(\n    Promise, PromiseArray, tryConvertToPromise, apiRejection) {\nvar util = _dereq_(\"./util.js\");\nvar isObject = util.isObject;\nvar es5 = _dereq_(\"./es5.js\");\n\nfunction PropertiesPromiseArray(obj) {\n    var keys = es5.keys(obj);\n    var len = keys.length;\n    var values = new Array(len * 2);\n    for (var i = 0; i < len; ++i) {\n        var key = keys[i];\n        values[i] = obj[key];\n        values[i + len] = key;\n    }\n    this.constructor$(values);\n}\nutil.inherits(PropertiesPromiseArray, PromiseArray);\n\nPropertiesPromiseArray.prototype._init = function () {\n    this._init$(undefined, -3) ;\n};\n\nPropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        var val = {};\n        var keyOffset = this.length();\n        for (var i = 0, len = this.length(); i < len; ++i) {\n            val[this._values[i + keyOffset]] = this._values[i];\n        }\n        this._resolve(val);\n    }\n};\n\nPropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {\n    this._promise._progress({\n        key: this._values[index + this.length()],\n        value: value\n    });\n};\n\nPropertiesPromiseArray.prototype.shouldCopyValues = function () {\n    return false;\n};\n\nPropertiesPromiseArray.prototype.getActualLength = function (len) {\n    return len >> 1;\n};\n\nfunction props(promises) {\n    var ret;\n    var castValue = tryConvertToPromise(promises);\n\n    if (!isObject(castValue)) {\n        return apiRejection(\"cannot await properties of a non-object\\u000a\\u000a    See http://goo.gl/OsFKC8\\u000a\");\n    } else if (castValue instanceof Promise) {\n        ret = castValue._then(\n            Promise.props, undefined, undefined, undefined, undefined);\n    } else {\n        ret = new PropertiesPromiseArray(castValue).promise();\n    }\n\n    if (castValue instanceof Promise) {\n        ret._propagateFrom(castValue, 4);\n    }\n    return ret;\n}\n\nPromise.prototype.props = function () {\n    return props(this);\n};\n\nPromise.props = function (promises) {\n    return props(promises);\n};\n};\n\n},{\"./es5.js\":14,\"./util.js\":38}],28:[function(_dereq_,module,exports){\n\"use strict\";\nfunction arrayMove(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n        src[j + srcIndex] = void 0;\n    }\n}\n\nfunction Queue(capacity) {\n    this._capacity = capacity;\n    this._length = 0;\n    this._front = 0;\n}\n\nQueue.prototype._willBeOverCapacity = function (size) {\n    return this._capacity < size;\n};\n\nQueue.prototype._pushOne = function (arg) {\n    var length = this.length();\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = arg;\n    this._length = length + 1;\n};\n\nQueue.prototype._unshiftOne = function(value) {\n    var capacity = this._capacity;\n    this._checkCapacity(this.length() + 1);\n    var front = this._front;\n    var i = (((( front - 1 ) &\n                    ( capacity - 1) ) ^ capacity ) - capacity );\n    this[i] = value;\n    this._front = i;\n    this._length = this.length() + 1;\n};\n\nQueue.prototype.unshift = function(fn, receiver, arg) {\n    this._unshiftOne(arg);\n    this._unshiftOne(receiver);\n    this._unshiftOne(fn);\n};\n\nQueue.prototype.push = function (fn, receiver, arg) {\n    var length = this.length() + 3;\n    if (this._willBeOverCapacity(length)) {\n        this._pushOne(fn);\n        this._pushOne(receiver);\n        this._pushOne(arg);\n        return;\n    }\n    var j = this._front + length - 3;\n    this._checkCapacity(length);\n    var wrapMask = this._capacity - 1;\n    this[(j + 0) & wrapMask] = fn;\n    this[(j + 1) & wrapMask] = receiver;\n    this[(j + 2) & wrapMask] = arg;\n    this._length = length;\n};\n\nQueue.prototype.shift = function () {\n    var front = this._front,\n        ret = this[front];\n\n    this[front] = undefined;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length--;\n    return ret;\n};\n\nQueue.prototype.length = function () {\n    return this._length;\n};\n\nQueue.prototype._checkCapacity = function (size) {\n    if (this._capacity < size) {\n        this._resizeTo(this._capacity << 1);\n    }\n};\n\nQueue.prototype._resizeTo = function (capacity) {\n    var oldCapacity = this._capacity;\n    this._capacity = capacity;\n    var front = this._front;\n    var length = this._length;\n    var moveItemsCount = (front + length) & (oldCapacity - 1);\n    arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n};\n\nmodule.exports = Queue;\n\n},{}],29:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(\n    Promise, INTERNAL, tryConvertToPromise, apiRejection) {\nvar isArray = _dereq_(\"./util.js\").isArray;\n\nvar raceLater = function (promise) {\n    return promise.then(function(array) {\n        return race(array, promise);\n    });\n};\n\nfunction race(promises, parent) {\n    var maybePromise = tryConvertToPromise(promises);\n\n    if (maybePromise instanceof Promise) {\n        return raceLater(maybePromise);\n    } else if (!isArray(promises)) {\n        return apiRejection(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\");\n    }\n\n    var ret = new Promise(INTERNAL);\n    if (parent !== undefined) {\n        ret._propagateFrom(parent, 4 | 1);\n    }\n    var fulfill = ret._fulfill;\n    var reject = ret._reject;\n    for (var i = 0, len = promises.length; i < len; ++i) {\n        var val = promises[i];\n\n        if (val === undefined && !(i in promises)) {\n            continue;\n        }\n\n        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n    }\n    return ret;\n}\n\nPromise.race = function (promises) {\n    return race(promises, undefined);\n};\n\nPromise.prototype.race = function () {\n    return race(this, undefined);\n};\n\n};\n\n},{\"./util.js\":38}],30:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise,\n                          PromiseArray,\n                          apiRejection,\n                          tryConvertToPromise,\n                          INTERNAL) {\nvar getDomain = Promise._getDomain;\nvar async = _dereq_(\"./async.js\");\nvar util = _dereq_(\"./util.js\");\nvar tryCatch = util.tryCatch;\nvar errorObj = util.errorObj;\nfunction ReductionPromiseArray(promises, fn, accum, _each) {\n    this.constructor$(promises);\n    this._promise._captureStackTrace();\n    this._preservedValues = _each === INTERNAL ? [] : null;\n    this._zerothIsAccum = (accum === undefined);\n    this._gotAccum = false;\n    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);\n    this._valuesPhase = undefined;\n    var maybePromise = tryConvertToPromise(accum, this._promise);\n    var rejected = false;\n    var isPromise = maybePromise instanceof Promise;\n    if (isPromise) {\n        maybePromise = maybePromise._target();\n        if (maybePromise._isPending()) {\n            maybePromise._proxyPromiseArray(this, -1);\n        } else if (maybePromise._isFulfilled()) {\n            accum = maybePromise._value();\n            this._gotAccum = true;\n        } else {\n            this._reject(maybePromise._reason());\n            rejected = true;\n        }\n    }\n    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;\n    var domain = getDomain();\n    this._callback = domain === null ? fn : domain.bind(fn);\n    this._accum = accum;\n    if (!rejected) async.invoke(init, this, undefined);\n}\nfunction init() {\n    this._init$(undefined, -5);\n}\nutil.inherits(ReductionPromiseArray, PromiseArray);\n\nReductionPromiseArray.prototype._init = function () {};\n\nReductionPromiseArray.prototype._resolveEmptyArray = function () {\n    if (this._gotAccum || this._zerothIsAccum) {\n        this._resolve(this._preservedValues !== null\n                        ? [] : this._accum);\n    }\n};\n\nReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var values = this._values;\n    values[index] = value;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var isEach = preservedValues !== null;\n    var gotAccum = this._gotAccum;\n    var valuesPhase = this._valuesPhase;\n    var valuesPhaseIndex;\n    if (!valuesPhase) {\n        valuesPhase = this._valuesPhase = new Array(length);\n        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {\n            valuesPhase[valuesPhaseIndex] = 0;\n        }\n    }\n    valuesPhaseIndex = valuesPhase[index];\n\n    if (index === 0 && this._zerothIsAccum) {\n        this._accum = value;\n        this._gotAccum = gotAccum = true;\n        valuesPhase[index] = ((valuesPhaseIndex === 0)\n            ? 1 : 2);\n    } else if (index === -1) {\n        this._accum = value;\n        this._gotAccum = gotAccum = true;\n    } else {\n        if (valuesPhaseIndex === 0) {\n            valuesPhase[index] = 1;\n        } else {\n            valuesPhase[index] = 2;\n            this._accum = value;\n        }\n    }\n    if (!gotAccum) return;\n\n    var callback = this._callback;\n    var receiver = this._promise._boundValue();\n    var ret;\n\n    for (var i = this._reducingIndex; i < length; ++i) {\n        valuesPhaseIndex = valuesPhase[i];\n        if (valuesPhaseIndex === 2) {\n            this._reducingIndex = i + 1;\n            continue;\n        }\n        if (valuesPhaseIndex !== 1) return;\n        value = values[i];\n        this._promise._pushContext();\n        if (isEach) {\n            preservedValues.push(value);\n            ret = tryCatch(callback).call(receiver, value, i, length);\n        }\n        else {\n            ret = tryCatch(callback)\n                .call(receiver, this._accum, value, i, length);\n        }\n        this._promise._popContext();\n\n        if (ret === errorObj) return this._reject(ret.e);\n\n        var maybePromise = tryConvertToPromise(ret, this._promise);\n        if (maybePromise instanceof Promise) {\n            maybePromise = maybePromise._target();\n            if (maybePromise._isPending()) {\n                valuesPhase[i] = 4;\n                return maybePromise._proxyPromiseArray(this, i);\n            } else if (maybePromise._isFulfilled()) {\n                ret = maybePromise._value();\n            } else {\n                return this._reject(maybePromise._reason());\n            }\n        }\n\n        this._reducingIndex = i + 1;\n        this._accum = ret;\n    }\n\n    this._resolve(isEach ? preservedValues : this._accum);\n};\n\nfunction reduce(promises, fn, initialValue, _each) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n    return array.promise();\n}\n\nPromise.prototype.reduce = function (fn, initialValue) {\n    return reduce(this, fn, initialValue, null);\n};\n\nPromise.reduce = function (promises, fn, initialValue, _each) {\n    return reduce(promises, fn, initialValue, _each);\n};\n};\n\n},{\"./async.js\":2,\"./util.js\":38}],31:[function(_dereq_,module,exports){\n\"use strict\";\nvar schedule;\nvar util = _dereq_(\"./util\");\nvar noAsyncScheduler = function() {\n    throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/m3OTXk\\u000a\");\n};\nif (util.isNode && typeof MutationObserver === \"undefined\") {\n    var GlobalSetImmediate = global.setImmediate;\n    var ProcessNextTick = process.nextTick;\n    schedule = util.isRecentNode\n                ? function(fn) { GlobalSetImmediate.call(global, fn); }\n                : function(fn) { ProcessNextTick.call(process, fn); };\n} else if ((typeof MutationObserver !== \"undefined\") &&\n          !(typeof window !== \"undefined\" &&\n            window.navigator &&\n            window.navigator.standalone)) {\n    schedule = function(fn) {\n        var div = document.createElement(\"div\");\n        var observer = new MutationObserver(fn);\n        observer.observe(div, {attributes: true});\n        return function() { div.classList.toggle(\"foo\"); };\n    };\n    schedule.isStatic = true;\n} else if (typeof setImmediate !== \"undefined\") {\n    schedule = function (fn) {\n        setImmediate(fn);\n    };\n} else if (typeof setTimeout !== \"undefined\") {\n    schedule = function (fn) {\n        setTimeout(fn, 0);\n    };\n} else {\n    schedule = noAsyncScheduler;\n}\nmodule.exports = schedule;\n\n},{\"./util\":38}],32:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports =\n    function(Promise, PromiseArray) {\nvar PromiseInspection = Promise.PromiseInspection;\nvar util = _dereq_(\"./util.js\");\n\nfunction SettledPromiseArray(values) {\n    this.constructor$(values);\n}\nutil.inherits(SettledPromiseArray, PromiseArray);\n\nSettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n    this._values[index] = inspection;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n    }\n};\n\nSettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 268435456;\n    ret._settledValue = value;\n    this._promiseResolved(index, ret);\n};\nSettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n    var ret = new PromiseInspection();\n    ret._bitField = 134217728;\n    ret._settledValue = reason;\n    this._promiseResolved(index, ret);\n};\n\nPromise.settle = function (promises) {\n    return new SettledPromiseArray(promises).promise();\n};\n\nPromise.prototype.settle = function () {\n    return new SettledPromiseArray(this).promise();\n};\n};\n\n},{\"./util.js\":38}],33:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports =\nfunction(Promise, PromiseArray, apiRejection) {\nvar util = _dereq_(\"./util.js\");\nvar RangeError = _dereq_(\"./errors.js\").RangeError;\nvar AggregateError = _dereq_(\"./errors.js\").AggregateError;\nvar isArray = util.isArray;\n\n\nfunction SomePromiseArray(values) {\n    this.constructor$(values);\n    this._howMany = 0;\n    this._unwrap = false;\n    this._initialized = false;\n}\nutil.inherits(SomePromiseArray, PromiseArray);\n\nSomePromiseArray.prototype._init = function () {\n    if (!this._initialized) {\n        return;\n    }\n    if (this._howMany === 0) {\n        this._resolve([]);\n        return;\n    }\n    this._init$(undefined, -5);\n    var isArrayResolved = isArray(this._values);\n    if (!this._isResolved() &&\n        isArrayResolved &&\n        this._howMany > this._canPossiblyFulfill()) {\n        this._reject(this._getRangeError(this.length()));\n    }\n};\n\nSomePromiseArray.prototype.init = function () {\n    this._initialized = true;\n    this._init();\n};\n\nSomePromiseArray.prototype.setUnwrap = function () {\n    this._unwrap = true;\n};\n\nSomePromiseArray.prototype.howMany = function () {\n    return this._howMany;\n};\n\nSomePromiseArray.prototype.setHowMany = function (count) {\n    this._howMany = count;\n};\n\nSomePromiseArray.prototype._promiseFulfilled = function (value) {\n    this._addFulfilled(value);\n    if (this._fulfilled() === this.howMany()) {\n        this._values.length = this.howMany();\n        if (this.howMany() === 1 && this._unwrap) {\n            this._resolve(this._values[0]);\n        } else {\n            this._resolve(this._values);\n        }\n    }\n\n};\nSomePromiseArray.prototype._promiseRejected = function (reason) {\n    this._addRejected(reason);\n    if (this.howMany() > this._canPossiblyFulfill()) {\n        var e = new AggregateError();\n        for (var i = this.length(); i < this._values.length; ++i) {\n            e.push(this._values[i]);\n        }\n        this._reject(e);\n    }\n};\n\nSomePromiseArray.prototype._fulfilled = function () {\n    return this._totalResolved;\n};\n\nSomePromiseArray.prototype._rejected = function () {\n    return this._values.length - this.length();\n};\n\nSomePromiseArray.prototype._addRejected = function (reason) {\n    this._values.push(reason);\n};\n\nSomePromiseArray.prototype._addFulfilled = function (value) {\n    this._values[this._totalResolved++] = value;\n};\n\nSomePromiseArray.prototype._canPossiblyFulfill = function () {\n    return this.length() - this._rejected();\n};\n\nSomePromiseArray.prototype._getRangeError = function (count) {\n    var message = \"Input array must contain at least \" +\n            this._howMany + \" items but contains only \" + count + \" items\";\n    return new RangeError(message);\n};\n\nSomePromiseArray.prototype._resolveEmptyArray = function () {\n    this._reject(this._getRangeError(0));\n};\n\nfunction some(promises, howMany) {\n    if ((howMany | 0) !== howMany || howMany < 0) {\n        return apiRejection(\"expecting a positive integer\\u000a\\u000a    See http://goo.gl/1wAmHx\\u000a\");\n    }\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    ret.setHowMany(howMany);\n    ret.init();\n    return promise;\n}\n\nPromise.some = function (promises, howMany) {\n    return some(promises, howMany);\n};\n\nPromise.prototype.some = function (howMany) {\n    return some(this, howMany);\n};\n\nPromise._SomePromiseArray = SomePromiseArray;\n};\n\n},{\"./errors.js\":13,\"./util.js\":38}],34:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise) {\nfunction PromiseInspection(promise) {\n    if (promise !== undefined) {\n        promise = promise._target();\n        this._bitField = promise._bitField;\n        this._settledValue = promise._settledValue;\n    }\n    else {\n        this._bitField = 0;\n        this._settledValue = undefined;\n    }\n}\n\nPromiseInspection.prototype.value = function () {\n    if (!this.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/hc1DLj\\u000a\");\n    }\n    return this._settledValue;\n};\n\nPromiseInspection.prototype.error =\nPromiseInspection.prototype.reason = function () {\n    if (!this.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/hPuiwB\\u000a\");\n    }\n    return this._settledValue;\n};\n\nPromiseInspection.prototype.isFulfilled =\nPromise.prototype._isFulfilled = function () {\n    return (this._bitField & 268435456) > 0;\n};\n\nPromiseInspection.prototype.isRejected =\nPromise.prototype._isRejected = function () {\n    return (this._bitField & 134217728) > 0;\n};\n\nPromiseInspection.prototype.isPending =\nPromise.prototype._isPending = function () {\n    return (this._bitField & 402653184) === 0;\n};\n\nPromiseInspection.prototype.isResolved =\nPromise.prototype._isResolved = function () {\n    return (this._bitField & 402653184) > 0;\n};\n\nPromise.prototype.isPending = function() {\n    return this._target()._isPending();\n};\n\nPromise.prototype.isRejected = function() {\n    return this._target()._isRejected();\n};\n\nPromise.prototype.isFulfilled = function() {\n    return this._target()._isFulfilled();\n};\n\nPromise.prototype.isResolved = function() {\n    return this._target()._isResolved();\n};\n\nPromise.prototype._value = function() {\n    return this._settledValue;\n};\n\nPromise.prototype._reason = function() {\n    this._unsetRejectionIsUnhandled();\n    return this._settledValue;\n};\n\nPromise.prototype.value = function() {\n    var target = this._target();\n    if (!target.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/hc1DLj\\u000a\");\n    }\n    return target._settledValue;\n};\n\nPromise.prototype.reason = function() {\n    var target = this._target();\n    if (!target.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/hPuiwB\\u000a\");\n    }\n    target._unsetRejectionIsUnhandled();\n    return target._settledValue;\n};\n\n\nPromise.PromiseInspection = PromiseInspection;\n};\n\n},{}],35:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar util = _dereq_(\"./util.js\");\nvar errorObj = util.errorObj;\nvar isObject = util.isObject;\n\nfunction tryConvertToPromise(obj, context) {\n    if (isObject(obj)) {\n        if (obj instanceof Promise) {\n            return obj;\n        }\n        else if (isAnyBluebirdPromise(obj)) {\n            var ret = new Promise(INTERNAL);\n            obj._then(\n                ret._fulfillUnchecked,\n                ret._rejectUncheckedCheckError,\n                ret._progressUnchecked,\n                ret,\n                null\n            );\n            return ret;\n        }\n        var then = util.tryCatch(getThen)(obj);\n        if (then === errorObj) {\n            if (context) context._pushContext();\n            var ret = Promise.reject(then.e);\n            if (context) context._popContext();\n            return ret;\n        } else if (typeof then === \"function\") {\n            return doThenable(obj, then, context);\n        }\n    }\n    return obj;\n}\n\nfunction getThen(obj) {\n    return obj.then;\n}\n\nvar hasProp = {}.hasOwnProperty;\nfunction isAnyBluebirdPromise(obj) {\n    return hasProp.call(obj, \"_promise0\");\n}\n\nfunction doThenable(x, then, context) {\n    var promise = new Promise(INTERNAL);\n    var ret = promise;\n    if (context) context._pushContext();\n    promise._captureStackTrace();\n    if (context) context._popContext();\n    var synchronous = true;\n    var result = util.tryCatch(then).call(x,\n                                        resolveFromThenable,\n                                        rejectFromThenable,\n                                        progressFromThenable);\n    synchronous = false;\n    if (promise && result === errorObj) {\n        promise._rejectCallback(result.e, true, true);\n        promise = null;\n    }\n\n    function resolveFromThenable(value) {\n        if (!promise) return;\n        promise._resolveCallback(value);\n        promise = null;\n    }\n\n    function rejectFromThenable(reason) {\n        if (!promise) return;\n        promise._rejectCallback(reason, synchronous, true);\n        promise = null;\n    }\n\n    function progressFromThenable(value) {\n        if (!promise) return;\n        if (typeof promise._progress === \"function\") {\n            promise._progress(value);\n        }\n    }\n    return ret;\n}\n\nreturn tryConvertToPromise;\n};\n\n},{\"./util.js\":38}],36:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar util = _dereq_(\"./util.js\");\nvar TimeoutError = Promise.TimeoutError;\n\nvar afterTimeout = function (promise, message) {\n    if (!promise.isPending()) return;\n    \n    var err;\n    if(!util.isPrimitive(message) && (message instanceof Error)) {\n        err = message;\n    } else {\n        if (typeof message !== \"string\") {\n            message = \"operation timed out\";\n        }\n        err = new TimeoutError(message);\n    }\n    util.markAsOriginatingFromRejection(err);\n    promise._attachExtraTrace(err);\n    promise._cancel(err);\n};\n\nvar afterValue = function(value) { return delay(+this).thenReturn(value); };\nvar delay = Promise.delay = function (value, ms) {\n    if (ms === undefined) {\n        ms = value;\n        value = undefined;\n        var ret = new Promise(INTERNAL);\n        setTimeout(function() { ret._fulfill(); }, ms);\n        return ret;\n    }\n    ms = +ms;\n    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);\n};\n\nPromise.prototype.delay = function (ms) {\n    return delay(this, ms);\n};\n\nfunction successClear(value) {\n    var handle = this;\n    if (handle instanceof Number) handle = +handle;\n    clearTimeout(handle);\n    return value;\n}\n\nfunction failureClear(reason) {\n    var handle = this;\n    if (handle instanceof Number) handle = +handle;\n    clearTimeout(handle);\n    throw reason;\n}\n\nPromise.prototype.timeout = function (ms, message) {\n    ms = +ms;\n    var ret = this.then().cancellable();\n    ret._cancellationParent = this;\n    var handle = setTimeout(function timeoutTimeout() {\n        afterTimeout(ret, message);\n    }, ms);\n    return ret._then(successClear, failureClear, undefined, handle, undefined);\n};\n\n};\n\n},{\"./util.js\":38}],37:[function(_dereq_,module,exports){\n\"use strict\";\nmodule.exports = function (Promise, apiRejection, tryConvertToPromise,\n    createContext) {\n    var TypeError = _dereq_(\"./errors.js\").TypeError;\n    var inherits = _dereq_(\"./util.js\").inherits;\n    var PromiseInspection = Promise.PromiseInspection;\n\n    function inspectionMapper(inspections) {\n        var len = inspections.length;\n        for (var i = 0; i < len; ++i) {\n            var inspection = inspections[i];\n            if (inspection.isRejected()) {\n                return Promise.reject(inspection.error());\n            }\n            inspections[i] = inspection._settledValue;\n        }\n        return inspections;\n    }\n\n    function thrower(e) {\n        setTimeout(function(){throw e;}, 0);\n    }\n\n    function castPreservingDisposable(thenable) {\n        var maybePromise = tryConvertToPromise(thenable);\n        if (maybePromise !== thenable &&\n            typeof thenable._isDisposable === \"function\" &&\n            typeof thenable._getDisposer === \"function\" &&\n            thenable._isDisposable()) {\n            maybePromise._setDisposable(thenable._getDisposer());\n        }\n        return maybePromise;\n    }\n    function dispose(resources, inspection) {\n        var i = 0;\n        var len = resources.length;\n        var ret = Promise.defer();\n        function iterator() {\n            if (i >= len) return ret.resolve();\n            var maybePromise = castPreservingDisposable(resources[i++]);\n            if (maybePromise instanceof Promise &&\n                maybePromise._isDisposable()) {\n                try {\n                    maybePromise = tryConvertToPromise(\n                        maybePromise._getDisposer().tryDispose(inspection),\n                        resources.promise);\n                } catch (e) {\n                    return thrower(e);\n                }\n                if (maybePromise instanceof Promise) {\n                    return maybePromise._then(iterator, thrower,\n                                              null, null, null);\n                }\n            }\n            iterator();\n        }\n        iterator();\n        return ret.promise;\n    }\n\n    function disposerSuccess(value) {\n        var inspection = new PromiseInspection();\n        inspection._settledValue = value;\n        inspection._bitField = 268435456;\n        return dispose(this, inspection).thenReturn(value);\n    }\n\n    function disposerFail(reason) {\n        var inspection = new PromiseInspection();\n        inspection._settledValue = reason;\n        inspection._bitField = 134217728;\n        return dispose(this, inspection).thenThrow(reason);\n    }\n\n    function Disposer(data, promise, context) {\n        this._data = data;\n        this._promise = promise;\n        this._context = context;\n    }\n\n    Disposer.prototype.data = function () {\n        return this._data;\n    };\n\n    Disposer.prototype.promise = function () {\n        return this._promise;\n    };\n\n    Disposer.prototype.resource = function () {\n        if (this.promise().isFulfilled()) {\n            return this.promise().value();\n        }\n        return null;\n    };\n\n    Disposer.prototype.tryDispose = function(inspection) {\n        var resource = this.resource();\n        var context = this._context;\n        if (context !== undefined) context._pushContext();\n        var ret = resource !== null\n            ? this.doDispose(resource, inspection) : null;\n        if (context !== undefined) context._popContext();\n        this._promise._unsetDisposable();\n        this._data = null;\n        return ret;\n    };\n\n    Disposer.isDisposer = function (d) {\n        return (d != null &&\n                typeof d.resource === \"function\" &&\n                typeof d.tryDispose === \"function\");\n    };\n\n    function FunctionDisposer(fn, promise, context) {\n        this.constructor$(fn, promise, context);\n    }\n    inherits(FunctionDisposer, Disposer);\n\n    FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n        var fn = this.data();\n        return fn.call(resource, resource, inspection);\n    };\n\n    function maybeUnwrapDisposer(value) {\n        if (Disposer.isDisposer(value)) {\n            this.resources[this.index]._setDisposable(value);\n            return value.promise();\n        }\n        return value;\n    }\n\n    Promise.using = function () {\n        var len = arguments.length;\n        if (len < 2) return apiRejection(\n                        \"you must pass at least 2 arguments to Promise.using\");\n        var fn = arguments[len - 1];\n        if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n\n        var input;\n        var spreadArgs = true;\n        if (len === 2 && Array.isArray(arguments[0])) {\n            input = arguments[0];\n            len = input.length;\n            spreadArgs = false;\n        } else {\n            input = arguments;\n            len--;\n        }\n        var resources = new Array(len);\n        for (var i = 0; i < len; ++i) {\n            var resource = input[i];\n            if (Disposer.isDisposer(resource)) {\n                var disposer = resource;\n                resource = resource.promise();\n                resource._setDisposable(disposer);\n            } else {\n                var maybePromise = tryConvertToPromise(resource);\n                if (maybePromise instanceof Promise) {\n                    resource =\n                        maybePromise._then(maybeUnwrapDisposer, null, null, {\n                            resources: resources,\n                            index: i\n                    }, undefined);\n                }\n            }\n            resources[i] = resource;\n        }\n\n        var promise = Promise.settle(resources)\n            .then(inspectionMapper)\n            .then(function(vals) {\n                promise._pushContext();\n                var ret;\n                try {\n                    ret = spreadArgs\n                        ? fn.apply(undefined, vals) : fn.call(undefined,  vals);\n                } finally {\n                    promise._popContext();\n                }\n                return ret;\n            })\n            ._then(\n                disposerSuccess, disposerFail, undefined, resources, undefined);\n        resources.promise = promise;\n        return promise;\n    };\n\n    Promise.prototype._setDisposable = function (disposer) {\n        this._bitField = this._bitField | 262144;\n        this._disposer = disposer;\n    };\n\n    Promise.prototype._isDisposable = function () {\n        return (this._bitField & 262144) > 0;\n    };\n\n    Promise.prototype._getDisposer = function () {\n        return this._disposer;\n    };\n\n    Promise.prototype._unsetDisposable = function () {\n        this._bitField = this._bitField & (~262144);\n        this._disposer = undefined;\n    };\n\n    Promise.prototype.disposer = function (fn) {\n        if (typeof fn === \"function\") {\n            return new FunctionDisposer(fn, this, createContext());\n        }\n        throw new TypeError();\n    };\n\n};\n\n},{\"./errors.js\":13,\"./util.js\":38}],38:[function(_dereq_,module,exports){\n\"use strict\";\nvar es5 = _dereq_(\"./es5.js\");\nvar canEvaluate = typeof navigator == \"undefined\";\nvar haveGetters = (function(){\n    try {\n        var o = {};\n        es5.defineProperty(o, \"f\", {\n            get: function () {\n                return 3;\n            }\n        });\n        return o.f === 3;\n    }\n    catch (e) {\n        return false;\n    }\n\n})();\n\nvar errorObj = {e: {}};\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        var target = tryCatchTarget;\n        tryCatchTarget = null;\n        return target.apply(this, arguments);\n    } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n\nvar inherits = function(Child, Parent) {\n    var hasProp = {}.hasOwnProperty;\n\n    function T() {\n        this.constructor = Child;\n        this.constructor$ = Parent;\n        for (var propertyName in Parent.prototype) {\n            if (hasProp.call(Parent.prototype, propertyName) &&\n                propertyName.charAt(propertyName.length-1) !== \"$\"\n           ) {\n                this[propertyName + \"$\"] = Parent.prototype[propertyName];\n            }\n        }\n    }\n    T.prototype = Parent.prototype;\n    Child.prototype = new T();\n    return Child.prototype;\n};\n\n\nfunction isPrimitive(val) {\n    return val == null || val === true || val === false ||\n        typeof val === \"string\" || typeof val === \"number\";\n\n}\n\nfunction isObject(value) {\n    return !isPrimitive(value);\n}\n\nfunction maybeWrapAsError(maybeError) {\n    if (!isPrimitive(maybeError)) return maybeError;\n\n    return new Error(safeToString(maybeError));\n}\n\nfunction withAppended(target, appendee) {\n    var len = target.length;\n    var ret = new Array(len + 1);\n    var i;\n    for (i = 0; i < len; ++i) {\n        ret[i] = target[i];\n    }\n    ret[i] = appendee;\n    return ret;\n}\n\nfunction getDataPropertyOrDefault(obj, key, defaultValue) {\n    if (es5.isES5) {\n        var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n        if (desc != null) {\n            return desc.get == null && desc.set == null\n                    ? desc.value\n                    : defaultValue;\n        }\n    } else {\n        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n    }\n}\n\nfunction notEnumerableProp(obj, name, value) {\n    if (isPrimitive(obj)) return obj;\n    var descriptor = {\n        value: value,\n        configurable: true,\n        enumerable: false,\n        writable: true\n    };\n    es5.defineProperty(obj, name, descriptor);\n    return obj;\n}\n\nfunction thrower(r) {\n    throw r;\n}\n\nvar inheritedDataKeys = (function() {\n    var excludedPrototypes = [\n        Array.prototype,\n        Object.prototype,\n        Function.prototype\n    ];\n\n    var isExcludedProto = function(val) {\n        for (var i = 0; i < excludedPrototypes.length; ++i) {\n            if (excludedPrototypes[i] === val) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    if (es5.isES5) {\n        var getKeys = Object.getOwnPropertyNames;\n        return function(obj) {\n            var ret = [];\n            var visitedKeys = Object.create(null);\n            while (obj != null && !isExcludedProto(obj)) {\n                var keys;\n                try {\n                    keys = getKeys(obj);\n                } catch (e) {\n                    return ret;\n                }\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (visitedKeys[key]) continue;\n                    visitedKeys[key] = true;\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n                    if (desc != null && desc.get == null && desc.set == null) {\n                        ret.push(key);\n                    }\n                }\n                obj = es5.getPrototypeOf(obj);\n            }\n            return ret;\n        };\n    } else {\n        var hasProp = {}.hasOwnProperty;\n        return function(obj) {\n            if (isExcludedProto(obj)) return [];\n            var ret = [];\n\n            /*jshint forin:false */\n            enumeration: for (var key in obj) {\n                if (hasProp.call(obj, key)) {\n                    ret.push(key);\n                } else {\n                    for (var i = 0; i < excludedPrototypes.length; ++i) {\n                        if (hasProp.call(excludedPrototypes[i], key)) {\n                            continue enumeration;\n                        }\n                    }\n                    ret.push(key);\n                }\n            }\n            return ret;\n        };\n    }\n\n})();\n\nvar thisAssignmentPattern = /this\\s*\\.\\s*\\S+\\s*=/;\nfunction isClass(fn) {\n    try {\n        if (typeof fn === \"function\") {\n            var keys = es5.names(fn.prototype);\n\n            var hasMethods = es5.isES5 && keys.length > 1;\n            var hasMethodsOtherThanConstructor = keys.length > 0 &&\n                !(keys.length === 1 && keys[0] === \"constructor\");\n            var hasThisAssignmentAndStaticMethods =\n                thisAssignmentPattern.test(fn + \"\") && es5.names(fn).length > 0;\n\n            if (hasMethods || hasMethodsOtherThanConstructor ||\n                hasThisAssignmentAndStaticMethods) {\n                return true;\n            }\n        }\n        return false;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction toFastProperties(obj) {\n    /*jshint -W027,-W055,-W031*/\n    function f() {}\n    f.prototype = obj;\n    var l = 8;\n    while (l--) new f();\n    return obj;\n    eval(obj);\n}\n\nvar rident = /^[a-z$_][a-z$_0-9]*$/i;\nfunction isIdentifier(str) {\n    return rident.test(str);\n}\n\nfunction filledRange(count, prefix, suffix) {\n    var ret = new Array(count);\n    for(var i = 0; i < count; ++i) {\n        ret[i] = prefix + i + suffix;\n    }\n    return ret;\n}\n\nfunction safeToString(obj) {\n    try {\n        return obj + \"\";\n    } catch (e) {\n        return \"[no string representation]\";\n    }\n}\n\nfunction markAsOriginatingFromRejection(e) {\n    try {\n        notEnumerableProp(e, \"isOperational\", true);\n    }\n    catch(ignore) {}\n}\n\nfunction originatesFromRejection(e) {\n    if (e == null) return false;\n    return ((e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError) ||\n        e[\"isOperational\"] === true);\n}\n\nfunction canAttachTrace(obj) {\n    return obj instanceof Error && es5.propertyIsWritable(obj, \"stack\");\n}\n\nvar ensureErrorObject = (function() {\n    if (!(\"stack\" in new Error())) {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            try {throw new Error(safeToString(value));}\n            catch(err) {return err;}\n        };\n    } else {\n        return function(value) {\n            if (canAttachTrace(value)) return value;\n            return new Error(safeToString(value));\n        };\n    }\n})();\n\nfunction classString(obj) {\n    return {}.toString.call(obj);\n}\n\nfunction copyDescriptors(from, to, filter) {\n    var keys = es5.names(from);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        if (filter(key)) {\n            try {\n                es5.defineProperty(to, key, es5.getDescriptor(from, key));\n            } catch (ignore) {}\n        }\n    }\n}\n\nvar ret = {\n    isClass: isClass,\n    isIdentifier: isIdentifier,\n    inheritedDataKeys: inheritedDataKeys,\n    getDataPropertyOrDefault: getDataPropertyOrDefault,\n    thrower: thrower,\n    isArray: es5.isArray,\n    haveGetters: haveGetters,\n    notEnumerableProp: notEnumerableProp,\n    isPrimitive: isPrimitive,\n    isObject: isObject,\n    canEvaluate: canEvaluate,\n    errorObj: errorObj,\n    tryCatch: tryCatch,\n    inherits: inherits,\n    withAppended: withAppended,\n    maybeWrapAsError: maybeWrapAsError,\n    toFastProperties: toFastProperties,\n    filledRange: filledRange,\n    toString: safeToString,\n    canAttachTrace: canAttachTrace,\n    ensureErrorObject: ensureErrorObject,\n    originatesFromRejection: originatesFromRejection,\n    markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n    classString: classString,\n    copyDescriptors: copyDescriptors,\n    hasDevTools: typeof chrome !== \"undefined\" && chrome &&\n                 typeof chrome.loadTimes === \"function\",\n    isNode: typeof process !== \"undefined\" &&\n        classString(process).toLowerCase() === \"[object process]\"\n};\nret.isRecentNode = ret.isNode && (function() {\n    var version = process.versions.node.split(\".\").map(Number);\n    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);\n})();\n\nif (ret.isNode) ret.toFastProperties(process);\n\ntry {throw new Error(); } catch (e) {ret.lastLineError = e;}\nmodule.exports = ret;\n\n},{\"./es5.js\":14}]},{},[4])(4)\n});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/signalk-client/~/bluebird/js/browser/bluebird.js\n ** module id = 10\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 11\n ** module chunks = 0\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/timers-browserify/main.js\n ** module id = 12\n ** module chunks = 0\n **/","/**\n * Promise wrapper for superagent\n */\n\nfunction wrap(superagent, Promise) {\n  /**\n   * Request object similar to superagent.Request, but with end() returning\n   * a promise.\n   */\n  function PromiseRequest() {\n    superagent.Request.apply(this, arguments);\n  }\n\n  // Inherit form superagent.Request\n  PromiseRequest.prototype = Object.create(superagent.Request.prototype);\n\n  /** Send request and get a promise that `end` was emitted */\n  PromiseRequest.prototype.end = function(cb) {\n    var _end = superagent.Request.prototype.end;\n    var self = this;\n\n    return new Promise(function(accept, reject) {\n      _end.call(self, function(err, response) {\n        if (cb) {\n          cb(err, response);\n        }\n\n        if (err) {\n          err.response = response;\n          reject(err);\n        } else {\n          accept(response);\n        }\n      });\n    });\n  };\n\n  /** Provide a more promise-y interface */\n  PromiseRequest.prototype.then = function(resolve, reject) {\n    var _end = superagent.Request.prototype.end;\n    var self = this;\n\n    return new Promise(function(accept, reject) {\n      _end.call(self, function(err, response) {\n        if (err) {\n          err.response = response;\n          reject(err);\n        } else {\n          accept(response);\n        }\n      });\n    }).then(resolve, reject);\n  };\n\n  /**\n   * Request builder with same interface as superagent.\n   * It is convenient to import this as `request` in place of superagent.\n   */\n  var request = function(method, url) {\n    return new PromiseRequest(method, url);\n  };\n\n  /** Helper for making an options request */\n  request.options = function(url) {\n    return request('OPTIONS', url);\n  }\n\n  /** Helper for making a head request */\n  request.head = function(url, data) {\n    var req = request('HEAD', url);\n    if (data) {\n      req.send(data);\n    }\n    return req;\n  };\n\n  /** Helper for making a get request */\n  request.get = function(url, data) {\n    var req = request('GET', url);\n    if (data) {\n      req.query(data);\n    }\n    return req;\n  };\n\n  /** Helper for making a post request */\n  request.post = function(url, data) {\n    var req = request('POST', url);\n    if (data) {\n      req.send(data);\n    }\n    return req;\n  };\n\n  /** Helper for making a put request */\n  request.put = function(url, data) {\n    var req = request('PUT', url);\n    if (data) {\n      req.send(data);\n    }\n    return req;\n  };\n\n  /** Helper for making a patch request */\n  request.patch = function(url, data) {\n    var req = request('PATCH', url);\n    if (data) {\n      req.send(data);\n    }\n    return req;\n  };\n\n  /** Helper for making a delete request */\n  request.del = function(url) {\n    return request('DELETE', url);\n  };\n\n  // Export the request builder\n  return request;\n}\n\nmodule.exports = wrap;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/signalk-client/~/superagent-promise/index.js\n ** module id = 13\n ** module chunks = 0\n **/","/**\n * Module dependencies.\n */\n\nvar Emitter = require('emitter');\nvar reduce = require('reduce');\n\n/**\n * Root reference for iframes.\n */\n\nvar root;\nif (typeof window !== 'undefined') { // Browser window\n  root = window;\n} else if (typeof self !== 'undefined') { // Web Worker\n  root = self;\n} else { // Other environments\n  root = this;\n}\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * TODO: future proof, move to compoent land\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isHost(obj) {\n  var str = {}.toString.call(obj);\n\n  switch (str) {\n    case '[object File]':\n    case '[object Blob]':\n    case '[object FormData]':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  return false;\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    if (null != obj[key]) {\n      pushEncodedKeyValuePair(pairs, key, obj[key]);\n        }\n      }\n  return pairs.join('&');\n}\n\n/**\n * Helps 'serialize' with serializing arrays.\n * Mutates the pairs array.\n *\n * @param {Array} pairs\n * @param {String} key\n * @param {Mixed} val\n */\n\nfunction pushEncodedKeyValuePair(pairs, key, val) {\n  if (Array.isArray(val)) {\n    return val.forEach(function(v) {\n      pushEncodedKeyValuePair(pairs, key, v);\n    });\n  }\n  pairs.push(encodeURIComponent(key)\n    + '=' + encodeURIComponent(val));\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var parts;\n  var pair;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'application/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Check if `mime` is json or has +json structured syntax suffix.\n *\n * @param {String} mime\n * @return {Boolean}\n * @api private\n */\n\nfunction isJSON(mime) {\n  return /[\\/+]json\\b/.test(mime);\n}\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction type(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction params(str){\n  return reduce(str.split(/ *; */), function(obj, str){\n    var parts = str.split(/ *= */)\n      , key = parts.shift()\n      , val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req, options) {\n  options = options || {};\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  this.setStatusProperties(this.xhr.status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this.setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD'\n    ? this.parseBody(this.text ? this.text : this.xhr.response)\n    : null;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponse.prototype.get = function(field){\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponse.prototype.setHeaderProperties = function(header){\n  // content-type\n  var ct = this.header['content-type'] || '';\n  this.type = type(ct);\n\n  // params\n  var obj = params(ct);\n  for (var key in obj) this[key] = obj[key];\n};\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype.parseBody = function(str){\n  var parse = request.parse[this.type];\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponse.prototype.setStatusProperties = function(status){\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n\n  var type = status / 100 | 0;\n\n  // status / class\n  this.status = this.statusCode = status;\n  this.statusType = type;\n\n  // basics\n  this.info = 1 == type;\n  this.ok = 2 == type;\n  this.clientError = 4 == type;\n  this.serverError = 5 == type;\n  this.error = (4 == type || 5 == type)\n    ? this.toError()\n    : false;\n\n  // sugar\n  this.accepted = 202 == status;\n  this.noContent = 204 == status;\n  this.badRequest = 400 == status;\n  this.unauthorized = 401 == status;\n  this.notAcceptable = 406 == status;\n  this.notFound = 404 == status;\n  this.forbidden = 403 == status;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  Emitter.call(this);\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {};\n  this._header = {};\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      // issue #675: return the raw response if the response parsing fails\n      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    if (err) {\n      return self.callback(err, res);\n    }\n\n    if (res.status >= 200 && res.status < 300) {\n      return self.callback(err, res);\n    }\n\n    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n    new_err.original = err;\n    new_err.response = res;\n    new_err.status = res.status;\n\n    self.callback(new_err, res);\n  });\n}\n\n/**\n * Mixin `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Allow for extension\n */\n\nRequest.prototype.use = function(fn) {\n  fn(this);\n  return this;\n}\n\n/**\n * Set timeout to `ms`.\n *\n * @param {Number} ms\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.timeout = function(ms){\n  this._timeout = ms;\n  return this;\n};\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.clearTimeout = function(){\n  this._timeout = 0;\n  clearTimeout(this._timer);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  if (this.aborted) return;\n  this.aborted = true;\n  this.xhr.abort();\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Get case-insensitive header `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api private\n */\n\nRequest.prototype.getHeader = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Force given parser\n *\n * Sets the body parser no matter type.\n *\n * @param {Function}\n * @api public\n */\n\nRequest.prototype.parse = function(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} pass\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass){\n  var str = btoa(user + ':' + pass);\n  this.set('Authorization', 'Basic ' + str);\n  return this;\n};\n\n/**\n* Add query-string `val`.\n*\n* Examples:\n*\n*   request.get('/shoes')\n*     .query('size=10')\n*     .query({ color: 'blue' })\n*\n* @param {Object|String} val\n* @return {Request} for chaining\n* @api public\n*/\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Write the field `name` and `val` for \"multipart/form-data\"\n * request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n * ```\n *\n * @param {String} name\n * @param {String|Blob|File} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.field = function(name, val){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(name, val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `filename`.\n *\n * ``` js\n * request.post('/upload')\n *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String} filename\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, filename){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(field, file, filename);\n  return this;\n};\n\n/**\n * Send `data`, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // querystring\n *       request.get('/search')\n *         .end(callback)\n *\n *       // multiple data \"writes\"\n *       request.get('/search')\n *         .send({ search: 'query' })\n *         .send({ range: '1..5' })\n *         .send({ order: 'desc' })\n *         .end(callback)\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"}')\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n  *      request.post('/user')\n  *        .send('name=tobi')\n  *        .send('species=ferret')\n  *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.send = function(data){\n  var obj = isObject(data);\n  var type = this.getHeader('Content-Type');\n\n  // merge\n  if (obj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    if (!type) this.type('form');\n    type = this.getHeader('Content-Type');\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!obj || isHost(data)) return this;\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  var fn = this._callback;\n  this.clearTimeout();\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n  err.crossDomain = true;\n\n  err.status = this.status;\n  err.method = this.method;\n  err.url = this.url;\n\n  this.callback(err);\n};\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequest.prototype.timeoutError = function(){\n  var timeout = this._timeout;\n  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  this.callback(err);\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequest.prototype.withCredentials = function(){\n  this._withCredentials = true;\n  return this;\n};\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  var self = this;\n  var xhr = this.xhr = request.getXHR();\n  var query = this._query.join('&');\n  var timeout = this._timeout;\n  var data = this._formData || this._data;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // state change\n  xhr.onreadystatechange = function(){\n    if (4 != xhr.readyState) return;\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (0 == status) {\n      if (self.timedout) return self.timeoutError();\n      if (self.aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(e){\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    xhr.onprogress = handleProgress;\n  }\n  try {\n    if (xhr.upload && this.hasListeners('progress')) {\n      xhr.upload.onprogress = handleProgress;\n    }\n  } catch(e) {\n    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n    // Reported here:\n    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n  }\n\n  // timeout\n  if (timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self.timedout = true;\n      self.abort();\n    }, timeout);\n  }\n\n  // querystring\n  if (query) {\n    query = request.serializeObject(query);\n    this.url += ~this.url.indexOf('?')\n      ? '&' + query\n      : '?' + query;\n  }\n\n  // initiate request\n  xhr.open(this.method, this.url, true);\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n    // serialize stuff\n    var contentType = this.getHeader('Content-Type');\n    var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n    xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  // send stuff\n  this.emit('request', this);\n\n  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n  // We need null here if data is undefined\n  xhr.send(typeof data !== 'undefined' ? data : null);\n  return this;\n};\n\n/**\n * Faux promise support\n *\n * @param {Function} fulfill\n * @param {Function} reject\n * @return {Request}\n */\n\nRequest.prototype.then = function (fulfill, reject) {\n  return this.end(function(err, res) {\n    err ? reject(err) : fulfill(res);\n  });\n}\n\n/**\n * Expose `Request`.\n */\n\nrequest.Request = Request;\n\n/**\n * Issue a request:\n *\n * Examples:\n *\n *    request('GET', '/users').end(callback)\n *    request('/users').end(callback)\n *    request('/users', callback)\n *\n * @param {String} method\n * @param {String|Function} url or callback\n * @return {Request}\n * @api public\n */\n\nfunction request(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new Request('GET', method);\n  }\n\n  return new Request(method, url);\n}\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nfunction del(url, fn){\n  var req = request('DELETE', url);\n  if (fn) req.end(fn);\n  return req;\n};\n\nrequest.del = del;\nrequest.delete = del;\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * Expose `request`.\n */\n\nmodule.exports = request;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/signalk-client/~/superagent/lib/client.js\n ** module id = 14\n ** module chunks = 0\n **/","\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/signalk-client/~/superagent/~/component-emitter/index.js\n ** module id = 15\n ** module chunks = 0\n **/","\n/**\n * Reduce `arr` with `fn`.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @param {Mixed} initial\n *\n * TODO: combatible error handling?\n */\n\nmodule.exports = function(arr, fn, initial){  \n  var idx = 0;\n  var len = arr.length;\n  var curr = arguments.length == 3\n    ? initial\n    : arr[idx++];\n\n  while (idx < len) {\n    curr = fn.call(null, curr, arr[idx], ++idx, arr);\n  }\n  \n  return curr;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/signalk-client/~/superagent/~/reduce-component/index.js\n ** module id = 16\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/util/util.js\n ** module id = 17\n ** module chunks = 0\n **/","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/util/support/isBufferBrowser.js\n ** module id = 18\n ** module chunks = 0\n **/","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/util/~/inherits/inherits_browser.js\n ** module id = 19\n ** module chunks = 0\n **/"],"sourceRoot":""}